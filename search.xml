<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>C++复习！！！（课本：谭老爷爷版）</title>
      <link href="/2018/06/24/c++%E5%A4%8D%E4%B9%A0/"/>
      <url>/2018/06/24/c++%E5%A4%8D%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h3 id="一、从C到C"><a href="#一、从C到C" class="headerlink" title="一、从C到C++"></a><font color="DarkViolet"><center>一、从C到C++</center></font></h3><hr><h4 id="C-如何实现I-O？它的优势在哪里？"><a href="#C-如何实现I-O？它的优势在哪里？" class="headerlink" title="C++如何实现I/O？它的优势在哪里？"></a>C++如何实现I/O？它的优势在哪里？</h4><ul><li>1、c++中I/O的概念<blockquote><p>在c++中有一个<strong>stream</strong>，这个类，所有的I/O都以这个“流”为基础，包括我们认识的文件I/O。stream有两个重要的运算符:</p><ul><li>a、<strong>插入器（&lt;&lt;）</strong>：向流输入数据。</li><li>b、<strong>析取器（&gt;&gt;）</strong>：从流中读取数据。</li></ul></blockquote></li><li>2、与c语言相比之下的优势<blockquote><p>1、最大的好处时完成了对流操作的<strong>封装</strong>。原来文件操作都是一个个分开的函数，现在的操作都是对象的方法。<br>2、stream适用于设备输入和输出的。fstream是stream的派生类，即文件流（设备对象是文件），作为文件在c++中的一个抽象对象。</p></blockquote></li></ul><hr><h4 id="什么是重载函数？如何区分重载函数？"><a href="#什么是重载函数？如何区分重载函数？" class="headerlink" title="什么是重载函数？如何区分重载函数？"></a>什么是重载函数？如何区分重载函数？</h4><ul><li>1、什么是重载函数？<blockquote><p>c++允许在同一作用域中用同意函数名来定义多个函数，这些函数的参数个数和参数类型不相同，这些同名的函数用来实现不同的功能，这就是<strong>函数的重载</strong>，即一个<strong>函数名多用</strong>。</p></blockquote></li><li>2、区分函数重载<blockquote><ul><li>1、<strong>函数形参的个数</strong>；</li><li>2、<strong>函数形参的类型</strong>；</li><li>3、<strong>形参的顺序</strong>；</li><li>4、<strong>不能把返回值作为函数重载的条件</strong>，原因是编辑器在编译时不回去判断函数的返回类型，函数只有调用后，编译器才会去验证返回类型，所以返回值类型不能做为函数重载的依据；</li><li>5、<strong>常函数const可以作为函数重载的判断依据</strong>，原因：重载[]运算符时，有没有const的区别是：有const只读，没有const读写都可以。</li></ul></blockquote></li></ul><hr><h4 id="什么是函数模板？为什么要使用函数模板？"><a href="#什么是函数模板？为什么要使用函数模板？" class="headerlink" title="什么是函数模板？为什么要使用函数模板？"></a>什么是函数模板？为什么要使用函数模板？</h4><ul><li>1、什么是函数模板？<blockquote><p>建立一个通用函数，其函数类型和形参不具体指定，用一个虚函数的类型来代表，这个通用的函数就称为<strong>函数模板</strong>。</p><blockquote><p>例：max函数模板<br> <code>template&lt;typename T&gt;T max(T a, T b, T c) {}</code></p></blockquote></blockquote></li><li>2、为什么要使用函数模板？<blockquote><p><strong>简化</strong>对同名的知识形参类型不同的函数的定义。</p></blockquote></li></ul><hr><h4 id="使用带有默认参数的函数时，要注意些什么？"><a href="#使用带有默认参数的函数时，要注意些什么？" class="headerlink" title="使用带有默认参数的函数时，要注意些什么？"></a>使用带有默认参数的函数时，要注意些什么？</h4><ul><li><blockquote><p>1、如果函数的定义在函数调用之前，则应在函数定义中给出默认值。</p></blockquote></li><li><blockquote><p>2、一个函数不能既作为重载函数，又作为有默认参数的函数。</p></blockquote></li></ul><hr><h4 id="什么是变量的引用？要注意什么？"><a href="#什么是变量的引用？要注意什么？" class="headerlink" title="什么是变量的引用？要注意什么？"></a>什么是变量的引用？要注意什么？</h4><ul><li><blockquote><p>在c++中，变量的“引用”就是变量的别名，因此，<strong>引用</strong>又称<strong>别名</strong>。<br>建立“引用”的作用是为一个变量再起另一个名字，一边在需要时可以方便、间接地引用该变量。<br>对一个变量的“引用”的所有的操作，实际上都是对其所代表的（原来的）变量的操作。</p><blockquote><p>例：有一个变量a，想给他起一个别名b</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line">int &amp;b = a;</span><br></pre></td></tr></table></figure></blockquote></blockquote></li><li><blockquote><p>ATTENTION:由于引用不是独立的变量，编译系统给它单独分配储存单元，因此，在建立引用时只有声明没有定义，只是声明它和原有某一变量的关系。</p></blockquote></li></ul><hr><h4 id="为什么要使用inline函数？"><a href="#为什么要使用inline函数？" class="headerlink" title="为什么要使用inline函数？"></a>为什么要使用inline函数？</h4><ul><li><blockquote><p>为了<strong>提高效率</strong>。</p></blockquote></li><li><blockquote><p>调用函数时需要一定的时间，如果有些函数需要频繁使用，则累计所用时间会很长，从而降低程序的执行效率。<br>c++提供一种提高效率的方法，即在编译时，将所调用函数的代码嵌入到主调函数中。这种嵌入到主调函数中的函数称为<strong>内联函数</strong>。</p></blockquote></li></ul><hr><h4 id="作用域限定符“-”的作用是什么"><a href="#作用域限定符“-”的作用是什么" class="headerlink" title="作用域限定符“::”的作用是什么"></a>作用域限定符“::”的作用是什么</h4><ul><li><blockquote><p>在c++中，不同作用域内声明的变量可以同名，当局部变量和全局变量同名时，在局部变量中引用全局变量用到作用域限定符“<strong>::</strong>”。<br>当全局变量和局部变量名字相同，重载时，就规定：<br>用 “<strong>:: + 全局变量名</strong>” 来称呼全局变量。</p></blockquote></li></ul><hr><h3 id="二、类和对象"><a href="#二、类和对象" class="headerlink" title="二、类和对象"></a><font color="DarkViolet"><center>二、类和对象</center></font></h3><hr><p><strong><font size="6" color="OrangeRed"><center>程序 = 对象 + 对象</center></font></strong><br><strong><font size="6" color="OrangeRed"><center>对象 = 算法 + 数据结构</center></font></strong></p><hr><h4 id="什么是类？什么是对象？什么是抽象？什么是类的声明、类的定义？"><a href="#什么是类？什么是对象？什么是抽象？什么是类的声明、类的定义？" class="headerlink" title="什么是类？什么是对象？什么是抽象？什么是类的声明、类的定义？"></a>什么是类？什么是对象？什么是抽象？什么是类的声明、类的定义？</h4><ul><li><strong>对象</strong>：<blockquote><p>客观世界中任何一个事物都可以看成一个<strong>对象</strong>（object）。</p></blockquote></li><li><strong>类</strong>：<blockquote><p>类是所有面向对象语言的共同特征，所有面向对象的语言都提供了这种类型。</p></blockquote></li><li><strong>抽象</strong>：<blockquote><p><strong>类</strong>是<strong>对象</strong>的抽象，而对象是类的具体实例。</p></blockquote></li><li><strong>数据抽象</strong>: <blockquote><p>只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。数据抽象是一种依赖于接口和实现分离的编程（设计）技术。</p></blockquote></li><li><p><strong>类的声明</strong>：</p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class 类名 &#123;</span><br><span class="line">private:</span><br><span class="line">私有的数据和成员函数;</span><br><span class="line">public:</span><br><span class="line">公用的数据和成员函数;</span><br><span class="line">protected:</span><br><span class="line">受保护的数据和成员函数;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>类的定义</strong>：</p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//1、先声明，后定义：</span><br><span class="line">//(1)、</span><br><span class="line">class 类名 对象名1,对象名2,...;</span><br><span class="line">//(2)、</span><br><span class="line">类名 对象名1,对象名2,...;</span><br><span class="line"></span><br><span class="line">//2、声明同时定义：</span><br><span class="line">class 类名 &#123;</span><br><span class="line">private:</span><br><span class="line">私有的数据和成员函数;</span><br><span class="line">public:</span><br><span class="line">公用的数据和成员函数;</span><br><span class="line">protected:</span><br><span class="line">受保护的数据和成员函数;</span><br><span class="line">&#125;对象名1,对象名2,...;</span><br><span class="line"></span><br><span class="line">//3、不出现类名直接定义对象（非常 不建议 使用）：</span><br><span class="line">class &#123;</span><br><span class="line">private:</span><br><span class="line">私有的数据和成员函数;</span><br><span class="line">public:</span><br><span class="line">公用的数据和成员函数;</span><br><span class="line">protected:</span><br><span class="line">受保护的数据和成员函数;</span><br><span class="line">&#125;对象名1,对象名2,...;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="c-中有哪些权限限定符？各起什么作用？"><a href="#c-中有哪些权限限定符？各起什么作用？" class="headerlink" title="c++中有哪些权限限定符？各起什么作用？"></a>c++中有哪些权限限定符？各起什么作用？</h4><ul><li><strong>private</strong><blockquote><p>private将成员声明为<strong>私有成员</strong>，只能被<strong>本类中的成员函数</strong>引用，类外不能调用（友元类除外）。</p></blockquote></li><li><strong>public</strong><blockquote><p>public将成员声明为<strong>公有成员</strong>，既可以被<strong>本类成员函数</strong>所引用，也可以被<strong>类的作用域内的其他函数</strong>所引用。</p></blockquote></li><li><strong>protected</strong><blockquote><p>protected将成员声明为<strong>受保护成员</strong>，不能被类外访问，但是可以被<strong>派生类的成员函数</strong>访问。</p></blockquote></li></ul><hr><h4 id="什么是类的封装？封装的原则是什么？"><a href="#什么是类的封装？封装的原则是什么？" class="headerlink" title="什么是类的封装？封装的原则是什么？"></a>什么是类的封装？封装的原则是什么？</h4><ul><li><strong>1、什么是封装？</strong><blockquote><p><strong>封装</strong>可以隐藏实现细节，使代码模块化。<br><strong>封装</strong>是把过程和数据包围起来，对数据的访问只能通过已定义的界面。<br>在面向对象编程上可理解为：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p></blockquote></li><li><strong>2、封装的原则是什么？</strong><blockquote><p><strong>简化用户接口，隐藏实现细节，这个是封装的根本目的。</strong><br>封装的难点在于如何设计接口。<br><strong>其一</strong>：必须保证接口是功能的全集，即接口能够覆盖所有需求。不能完成必要功能的封装是没有意义的。<br><strong>其二</strong>：尽量使接口是最小冗余的。这是为了简化类使用者的学习和使用，难用的接口是最容易让人遗忘的。冗余接口的存在是被允许的，但必须保证冗余接口是有效的。也就是说，增加冗余接口会带来很大的好处，比如性能的飞升。<br><strong>其三</strong>：要保证接口是稳定的，将接口和实现分离，并将实现隐藏，就是为了能保护类使用者在类的实现细节改变的情况下，不必随时修改。一旦接口被公布，永远也不要改变它。</p></blockquote></li></ul><hr><h4 id="同一个类所定义的不同对象在调用同一个成员函数时，调用的是同一段代码吗？通过什么来区分各自的数据？"><a href="#同一个类所定义的不同对象在调用同一个成员函数时，调用的是同一段代码吗？通过什么来区分各自的数据？" class="headerlink" title="同一个类所定义的不同对象在调用同一个成员函数时，调用的是同一段代码吗？通过什么来区分各自的数据？"></a>同一个类所定义的不同对象在调用同一个成员函数时，调用的是同一段代码吗？通过什么来区分各自的数据？</h4><ul><li><blockquote><p><strong>是同一段代码</strong>。</p></blockquote></li><li><blockquote><p><strong>通过this指针</strong>：每一个成员函数中都包括这个指针的名字是固定的，称为this。<strong>它是指向对象的指针，他的值是当前被调用的成员函数所在的对象的起始地址</strong>。<br>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int Box::volume()&#123;</span><br><span class="line">return (height * width * length);</span><br><span class="line">&#125;</span><br><span class="line">//C++把它处理为:</span><br><span class="line">int Box::volume(Box * this)&#123;</span><br><span class="line">return (this-&gt;height * this-&gt;width * this-&gt;length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><hr><h4 id="类的成员函数和普通全局函数在形式上有什么区别？在本质上有什么区别？"><a href="#类的成员函数和普通全局函数在形式上有什么区别？在本质上有什么区别？" class="headerlink" title="类的成员函数和普通全局函数在形式上有什么区别？在本质上有什么区别？"></a>类的成员函数和普通全局函数在形式上有什么区别？在本质上有什么区别？</h4><ul><li><blockquote><p><strong>区别</strong>1：静态成员函数实际上是一个全局函数,不依赖一个类的对象. 而属于类，不创建对象也可调用，静态成员函数没有this指针。普通成员函数依赖一个类的对象,也就是它有一个隐藏的调用参数（this）指针,必须指向一个类的对象。</p></blockquote></li><li><blockquote><p><strong>区别2</strong>：静态函数只能访问类中的静态成员变量；</p></blockquote></li><li><blockquote><p><strong>区别3</strong>：如果成员函数想作为回调函数来使用，如创建线程等，一般只能将它定义为静态成员函数才行。</p></blockquote></li></ul><hr><h3 id="三、类和对象的进一步讨论"><a href="#三、类和对象的进一步讨论" class="headerlink" title="三、类和对象的进一步讨论"></a><font color="DarkViolet"><center>三、类和对象的进一步讨论</center></font></h3><hr><h4 id="构造函数、析构函数的英文单词是什么？"><a href="#构造函数、析构函数的英文单词是什么？" class="headerlink" title="构造函数、析构函数的英文单词是什么？"></a>构造函数、析构函数的英文单词是什么？</h4><ul><li><blockquote><p><strong>构造函数——constructor</strong></p></blockquote></li><li><blockquote><p><strong>析构函数——destructor</strong></p></blockquote></li></ul><hr><h4 id="构造函数的特点是什么？析构函数的特点是什么？"><a href="#构造函数的特点是什么？析构函数的特点是什么？" class="headerlink" title="构造函数的特点是什么？析构函数的特点是什么？"></a>构造函数的特点是什么？析构函数的特点是什么？</h4><ul><li><blockquote><p>c++提供构造函数，来处理对象的初始化。构造函数是一种<strong>特殊的成员函数</strong>，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。规则，只要你一实例化对象，系统自动回调用一个构造函数，就算不写，编译器也自动调用一次。</p></blockquote></li><li><blockquote><p>析构函数与构造函数同名，但该函数前面加~。析构函数<strong>没有参数</strong>，也<strong>没有返回值</strong>，而且<strong>不能重载</strong>，在<strong>一个类中只能有一个析构函数</strong>。当<strong>撤销对象时，编译器也会自动调用析构函数</strong>。<strong>每一个类必须有一个析构函数</strong>，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。</p></blockquote></li></ul><hr><h4 id="构造函数、析构函数的执行顺序是什么？"><a href="#构造函数、析构函数的执行顺序是什么？" class="headerlink" title="构造函数、析构函数的执行顺序是什么？"></a>构造函数、析构函数的执行顺序是什么？</h4><ul><li><blockquote><p><strong>先构造的先执行析构</strong>。</p></blockquote></li></ul><hr><h4 id="在C语言中，我们说main-函数是程序的入口，是最先被调用的函数，在C-中情况是这样吗？如果不是请说明原因，并举出实例。"><a href="#在C语言中，我们说main-函数是程序的入口，是最先被调用的函数，在C-中情况是这样吗？如果不是请说明原因，并举出实例。" class="headerlink" title="在C语言中，我们说main()函数是程序的入口，是最先被调用的函数，在C++中情况是这样吗？如果不是请说明原因，并举出实例。"></a>在C语言中，我们说main()函数是程序的入口，是最先被调用的函数，在C++中情况是这样吗？如果不是请说明原因，并举出实例。</h4><ul><li><blockquote><p><strong>c++中不是这样</strong>。</p></blockquote></li><li><blockquote><p>因为存在构造数据类型的定义对象定义，且对象为全局对象的话，则该类对象所属的构造类型的构造函数在main()函数之前执行。</p></blockquote></li></ul><hr><h4 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h4><p><center><strong><font color="Crimson" size="6">const在c++中要尽可能的使用</font></strong></center></p><ul><li><blockquote><p>const的作用是：<strong>数据的保护</strong></p></blockquote></li><li>常成员变量<blockquote><p>类的常成员变量是用const关键字声明的成员变量，<strong>其值不可改变</strong>，它的<strong>初始值必须通过构造函数的初始化列表方式完成</strong>。一般将一个类中不可改变的值声明为常成员变量。<br>但const成员变量有一个缺点：该类的所有对象都会const成员变量，而不是整个类共用一个。这种情况下，const常和static一起使用。</p></blockquote></li><li>const成员函数<blockquote><p>const成员函数语法为：<code>int Obj::Func const;</code>这表明成员函数Func const是个常成员函数，它的作用是表明<strong>只能引用类中的数据成员</strong>，而<strong>不能修改类中的数据成员</strong>。</p></blockquote></li><li>常对象<blockquote><p>语法为：<code>const obj o(10);</code> 或 <code>obj const o(10);</code><br>用const声明的对象为常对象，常对象必须初始化，<br>如果一个对象被声明为const对象，则该对象的数据成员不可修改。即const对象不能调用该对象的非const成员函数。</p></blockquote></li><li>指向const数据的指针<blockquote><p>定义指针时，在指针的类型<strong>前面</strong>加上const表明该指针指向的对象是个常量。</p></blockquote></li><li>const指针<blockquote><p>在定义指针时，在指针的<strong>前面</strong>加上const表明该指针是一个常量，它必须被初始化。</p></blockquote></li><li>const在参数中的使用<blockquote><p>const在参数类型为指针或引用时经常被使用，这表明这个指针或引用所指向的数据不允许被修改，这样就保证了在被调函数中不能因为误操作而改变了主调函数中的值。</p></blockquote></li></ul><hr><h4 id="初始化列表的语法是怎样的？"><a href="#初始化列表的语法是怎样的？" class="headerlink" title="初始化列表的语法是怎样的？"></a>初始化列表的语法是怎样的？</h4><ul><li>如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">类名::构造函数名([参数表])[:成员初始化表]&#123;</span><br><span class="line">[构造函数体]</span><br><span class="line">&#125;</span><br><span class="line">//例：</span><br><span class="line">class Student&#123;</span><br><span class="line">public:</span><br><span class="line">Student(int n, char s, nam[]):num(n), sex(s)&#123;</span><br><span class="line">    strcpy(name, nam);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">int num;</span><br><span class="line">    char sex;</span><br><span class="line">    int name[20];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="在C-中为什么使用new-delete，而不是malloc-free-来来动态创建对象？如何使用new-delete来动态创建数组？"><a href="#在C-中为什么使用new-delete，而不是malloc-free-来来动态创建对象？如何使用new-delete来动态创建数组？" class="headerlink" title="在C++中为什么使用new/delete，而不是malloc()/free()来来动态创建对象？如何使用new/delete来动态创建数组？"></a>在C++中为什么使用new/delete，而不是malloc()/free()来来动态创建对象？如何使用new/delete来动态创建数组？</h4><ul><li><blockquote><p>c语言中使用库函数malloc()和free()来动态申请和释放内存空间，但是存在两个问题：<br>1、分配的大小需人为计算;<br>2、只分配空间，而不涉及类型。<br>c++使用了运算符new和delete来取代malloc()和free()函数。<strong>动态分配/释放内存</strong>。</p></blockquote></li><li>例：动态创建一维数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    //动态分配一维数组</span><br><span class="line">    int *arr = new int [n];</span><br><span class="line">    for(int i = 0; i &lt; n; i++)</span><br><span class="line">    cin &gt;&gt; arr[i];</span><br><span class="line">    for(int i = 0; i &lt; n; i++)</span><br><span class="line">    cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    //释放arr数组</span><br><span class="line">    delete[] arr;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="什么是对象的复制？什么是对象的赋值？"><a href="#什么是对象的复制？什么是对象的赋值？" class="headerlink" title="什么是对象的复制？什么是对象的赋值？"></a>什么是对象的复制？什么是对象的赋值？</h4><ul><li>对象的赋值<blockquote><p>一般形式：<code>对象名1 = 对象名2；</code><br><strong>对象的赋值只是用赋值号右边的对象的数据覆盖了赋值号左边的的对象的数据成员</strong>。因此必须使用有默认参数值的构造函数，以保证左值能被初始化。</p></blockquote></li><li>对象的复制<blockquote><p>一般形式：<code>类名 对象2(对象1)；</code> 或 `类名 对象2 = 对象1;<br>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">pubilc:</span><br><span class="line"> Student ()&#123;m_strName=&quot;Jim&quot;;&#125;</span><br><span class="line">    /*</span><br><span class="line">    默认的拷贝构造函数：</span><br><span class="line">    Student (const Student &amp;stu)&#123;&#125;</span><br><span class="line">    */</span><br><span class="line">    Student(const Student &amp;stu)&#123;m_strName = stu.m_strName;&#125;</span><br><span class="line">    //显性定义的拷贝构造函数</span><br><span class="line">private:</span><br><span class="line"> string m_strName;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line"> Student stu1;</span><br><span class="line"> Student stu2 = stu1;</span><br><span class="line"> Student stu3(stu1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><hr><h4 id="什么是深拷贝-浅拷贝？-拷贝构造函数的语法如何？"><a href="#什么是深拷贝-浅拷贝？-拷贝构造函数的语法如何？" class="headerlink" title="什么是深拷贝/浅拷贝？ 拷贝构造函数的语法如何？"></a>什么是深拷贝/浅拷贝？ 拷贝构造函数的语法如何？</h4><ul><li>浅拷贝<blockquote><p>对象拷贝时，仅仅是简单的值拷贝，这称为“浅拷贝”，这是系统默认的拷贝模式，不需要编程实现。</p></blockquote></li><li>深拷贝<blockquote><p>对象拷贝时，对堆中的数据编程进行拷贝，这称为“深拷贝”，这种拷贝模式需要编程实现。</p></blockquote></li><li><strong>拷贝构造函数</strong><blockquote><p>拷贝构造函数中只有哟个参数，为本类对象的一个引用，并通常使用const修饰。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj(const obj &amp;o)&#123;</span><br><span class="line"> no = o.no;</span><br><span class="line">    cout &lt;&lt; &quot;copy constructor&quot; &lt;&lt; no &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><hr><h4 id="static数据成员和static成员函数的特点是什么？static成员函数有什么限制？static数据成员如何初始化？"><a href="#static数据成员和static成员函数的特点是什么？static成员函数有什么限制？static数据成员如何初始化？" class="headerlink" title="static数据成员和static成员函数的特点是什么？static成员函数有什么限制？static数据成员如何初始化？"></a>static数据成员和static成员函数的特点是什么？static成员函数有什么限制？static数据成员如何初始化？</h4><ul><li><blockquote><p><strong>static数据成员</strong>拥有一块单独的储存区（不再类对象内部），不管该类创造了多少个对象。所有该类的对象共享这块区域，这就为这些类之间提供了一种相互通信的方法，并且它不会占据对象的储存空间。他的名字是属于类的（例：Circle::PI），这样可以很大程度上解决全局数据的名字冲突问题。它是有权限控制的，也就是说他可以是private的。</p></blockquote></li><li><blockquote><p>除了数据成员能定义为static的，成员函数也可以定义为static的。与static数据成员一样，static成员函数也是属于类的，而不是属于对象的。static成员函数是属于类的，所以它没有this指针，不创建对象就可以被调用。它的这个特点决定了<strong>static成员函数只能访问类中的static数据成员和static成员函数</strong>。与类的static数据成员一样，<strong>推荐使用类方式引用类的static成员函数</strong>。</p></blockquote></li><li><blockquote><p>在类内提供的仅仅是static数据成员的声明（编译器没有给它分配空间），而不是定义，所以不能使用构造函数对其进行初始化，<strong>static数据成员的初始化必须在类外完成</strong>。static数据成员在使用时，既可以使用对象方式引用，也可以使用类方式引用，通常使用类方式引用，以表明它是一个static数据成员。</p></blockquote></li></ul><hr><h4 id="为什么要使用友元？哪些内容可以作为类的友元？我们对友元的态度是什么？"><a href="#为什么要使用友元？哪些内容可以作为类的友元？我们对友元的态度是什么？" class="headerlink" title="为什么要使用友元？哪些内容可以作为类的友元？我们对友元的态度是什么？"></a>为什么要使用友元？哪些内容可以作为类的友元？我们对友元的态度是什么？</h4><ul><li><blockquote><p>友元机制可以带来一些便利。</p></blockquote></li><li><blockquote><p>友元可以实现在类的外部访问一个类的<strong>private成员</strong></p></blockquote></li><li>友元机制虽然可以带来一些便利，但是它严重破坏了程序的封装性，也有影响程序的可读性，所以要<strong>慎重使用友元</strong>。</li></ul><hr><h3 id="四、运算符重载"><a href="#四、运算符重载" class="headerlink" title="四、运算符重载"></a><font color="DarkViolet"><center>四、运算符重载</center></font></h3><hr><h4 id="在C-中运算符被当作什么处理？如何重载运算符？重载运算符有什么好处？需要注意哪些问题？运算符重载一般以哪两种方式出现？该如何选择？"><a href="#在C-中运算符被当作什么处理？如何重载运算符？重载运算符有什么好处？需要注意哪些问题？运算符重载一般以哪两种方式出现？该如何选择？" class="headerlink" title="在C++中运算符被当作什么处理？如何重载运算符？重载运算符有什么好处？需要注意哪些问题？运算符重载一般以哪两种方式出现？该如何选择？"></a><a href="https://blog.csdn.net/u013982161/article/details/52830143" target="_blank" rel="noopener">在C++中运算符被当作什么处理？如何重载运算符？重载运算符有什么好处？需要注意哪些问题？运算符重载一般以哪两种方式出现？该如何选择？</a></h4><hr><h3 id="五、继承和派生"><a href="#五、继承和派生" class="headerlink" title="五、继承和派生"></a><font color="DarkViolet"><center>五、继承和派生</center></font></h3><hr><h4 id="继承的单词是什么？语法如何？继承方式限定符有哪些？作用分别是什么？"><a href="#继承的单词是什么？语法如何？继承方式限定符有哪些？作用分别是什么？" class="headerlink" title="继承的单词是什么？语法如何？继承方式限定符有哪些？作用分别是什么？"></a>继承的单词是什么？语法如何？继承方式限定符有哪些？作用分别是什么？</h4><ul><li><blockquote><p><strong>继承——inheritance</strong></p></blockquote></li><li><blockquote><p><strong>语法</strong>：</p></blockquote></li><li><blockquote><p><strong>继承方式限定符</strong>：<strong>private</strong>，<strong>public</strong>，<strong>protected</strong>。</p></blockquote></li></ul><hr><h4 id="继承发生时，在派生类的对象内部会有一个基类的对象，这个基类对象的初始化是由基类的构造函数完成的，那么如何在派生类中有选择的调用基类的非默认构造函数呢？"><a href="#继承发生时，在派生类的对象内部会有一个基类的对象，这个基类对象的初始化是由基类的构造函数完成的，那么如何在派生类中有选择的调用基类的非默认构造函数呢？" class="headerlink" title="继承发生时，在派生类的对象内部会有一个基类的对象，这个基类对象的初始化是由基类的构造函数完成的，那么如何在派生类中有选择的调用基类的非默认构造函数呢？"></a>继承发生时，在派生类的对象内部会有一个基类的对象，这个基类对象的初始化是由基类的构造函数完成的，那么如何在派生类中有选择的调用基类的非默认构造函数呢？</h4><hr><h4 id="继承发生时，派生类是否全部接收基类的成员？如果不是哪些成员不被继承。"><a href="#继承发生时，派生类是否全部接收基类的成员？如果不是哪些成员不被继承。" class="headerlink" title="继承发生时，派生类是否全部接收基类的成员？如果不是哪些成员不被继承。"></a>继承发生时，派生类是否全部接收基类的成员？如果不是哪些成员不被继承。</h4><hr><h4 id="组合（子对象）的作用是什么？如何有选择的调用对象成员的非默认构造函数？组合和继承都可以实现代码重用，那么什么时候选择组合，什么时候选择继承？"><a href="#组合（子对象）的作用是什么？如何有选择的调用对象成员的非默认构造函数？组合和继承都可以实现代码重用，那么什么时候选择组合，什么时候选择继承？" class="headerlink" title="组合（子对象）的作用是什么？如何有选择的调用对象成员的非默认构造函数？组合和继承都可以实现代码重用，那么什么时候选择组合，什么时候选择继承？"></a>组合（子对象）的作用是什么？如何有选择的调用对象成员的非默认构造函数？组合和继承都可以实现代码重用，那么什么时候选择组合，什么时候选择继承？</h4><hr><h4 id="当继承和组合都存在时，构造和析构的顺序如何？"><a href="#当继承和组合都存在时，构造和析构的顺序如何？" class="headerlink" title="当继承和组合都存在时，构造和析构的顺序如何？"></a>当继承和组合都存在时，构造和析构的顺序如何？</h4><hr><h4 id="哪些地方必须使用初始化列表？"><a href="#哪些地方必须使用初始化列表？" class="headerlink" title="哪些地方必须使用初始化列表？"></a>哪些地方必须使用初始化列表？</h4><hr><h4 id="什么是overriding、overload？什么是upcasting？"><a href="#什么是overriding、overload？什么是upcasting？" class="headerlink" title="什么是overriding、overload？什么是upcasting？"></a>什么是overriding、overload？什么是upcasting？</h4><hr><h4 id="多继承会带来什么问题？如何解决这个问题？对待多继承的态度是什么？"><a href="#多继承会带来什么问题？如何解决这个问题？对待多继承的态度是什么？" class="headerlink" title="多继承会带来什么问题？如何解决这个问题？对待多继承的态度是什么？"></a>多继承会带来什么问题？如何解决这个问题？对待多继承的态度是什么？</h4><hr><h3 id="六、多态性和虚函数"><a href="#六、多态性和虚函数" class="headerlink" title="六、多态性和虚函数"></a><font color="DarkViolet"><center>六、多态性和虚函数</center></font></h3><hr><h4 id="什么是多态性？英文单词是什么？它能给我们程序设计带来什么好处？"><a href="#什么是多态性？英文单词是什么？它能给我们程序设计带来什么好处？" class="headerlink" title="什么是多态性？英文单词是什么？它能给我们程序设计带来什么好处？"></a>什么是多态性？英文单词是什么？它能给我们程序设计带来什么好处？</h4><hr><h4 id="如何实现多态性？"><a href="#如何实现多态性？" class="headerlink" title="如何实现多态性？"></a>如何实现多态性？</h4><hr><h4 id="虚函数是如何实现的（考试不会考）？"><a href="#虚函数是如何实现的（考试不会考）？" class="headerlink" title="虚函数是如何实现的（考试不会考）？"></a>虚函数是如何实现的（考试不会考）？</h4><hr><h4 id="动态-静态绑定（binding、联编）的优缺点各是什么？"><a href="#动态-静态绑定（binding、联编）的优缺点各是什么？" class="headerlink" title="动态/静态绑定（binding、联编）的优缺点各是什么？"></a>动态/静态绑定（binding、联编）的优缺点各是什么？</h4><hr><h4 id="什么是纯虚函数？什么是抽象类？其意义各自是什么？"><a href="#什么是纯虚函数？什么是抽象类？其意义各自是什么？" class="headerlink" title="什么是纯虚函数？什么是抽象类？其意义各自是什么？"></a>什么是纯虚函数？什么是抽象类？其意义各自是什么？</h4><hr><h3 id="七、输入输出流"><a href="#七、输入输出流" class="headerlink" title="七、输入输出流"></a><font color="DarkViolet"><center>七、输入输出流</center></font></h3><hr><h4 id="C-I-O的优势在哪（和前面第一章的类似）？"><a href="#C-I-O的优势在哪（和前面第一章的类似）？" class="headerlink" title="C++I/O的优势在哪（和前面第一章的类似）？"></a>C++I/O的优势在哪（和前面第一章的类似）？</h4><hr><h4 id="标准输出流有哪些？它们之间的区别是什么？如何控制格式的输出？标准的输入流是什么？"><a href="#标准输出流有哪些？它们之间的区别是什么？如何控制格式的输出？标准的输入流是什么？" class="headerlink" title="标准输出流有哪些？它们之间的区别是什么？如何控制格式的输出？标准的输入流是什么？"></a>标准输出流有哪些？它们之间的区别是什么？如何控制格式的输出？标准的输入流是什么？</h4><hr><h4 id="如何使用文件流进行输入-输出（步骤）？"><a href="#如何使用文件流进行输入-输出（步骤）？" class="headerlink" title="如何使用文件流进行输入/输出（步骤）？"></a>如何使用文件流进行输入/输出（步骤）？</h4><hr><h4 id="什么是字符串流？它有什么用好处？"><a href="#什么是字符串流？它有什么用好处？" class="headerlink" title="什么是字符串流？它有什么用好处？"></a>什么是字符串流？它有什么用好处？</h4><hr><h3 id="八、C-工具"><a href="#八、C-工具" class="headerlink" title="八、C++工具"></a><font color="DarkViolet"><center>八、C++工具</center></font></h3><hr><h4 id="实现异常的三个关键字是什么？大致的作用是什么？"><a href="#实现异常的三个关键字是什么？大致的作用是什么？" class="headerlink" title="实现异常的三个关键字是什么？大致的作用是什么？"></a>实现异常的三个关键字是什么？大致的作用是什么？</h4>]]></content>
      
      
    </entry>
    
  
  
</search>
